<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta name="generator" content="Hugo 0.113.0">
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)">
		<meta property="og:title" content="Morfitronik" />
<meta property="og:description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://morfikov.github.io/" />

		<meta itemprop="name" content="Morfitronik">
<meta itemprop="description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)">
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Morfitronik"/>
<meta name="twitter:description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)"/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="alternate" type="application/rss+xml" href="https://morfikov.github.io/feed.xml" title="Morfitronik">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
			<div class="cards">
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/poradnik-maintainera-czyli-jak-zrobic-pakiet-deb/">Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb</a></h1>
	<div class="entry__content"><p>Debian posiada bardzo rozbudowany system robienia pakietów. Generalnie rzecz biorąc, to wszystkie z
nich musiały przejść przez ten proces zanim trafiły do głównego repozytorium dystrybucji. Dzięki
takiemu stanu rzeczy, nie musimy ręcznie powielać pracy szeregu innych osób i odpada nam
własnoręczna kompilacja pakietów, a wszyscy wiemy, że zajmuje ona cenny czas i zasoby. Paczki
<code>.deb</code> są tworzone ze źródeł i instalowane przy pomocy menadżera pakietów <code>aptitude</code>/<code>apt</code>/<code>dpkg</code> .
Nic jednak nie stoi na przeszkodzie by daną aplikację skompilować sobie ręcznie i zainstalować ją
przy pomocy <code>make install</code> . Problem w tym, że w taki sposób robi się śmietnik w naszym systemie i
śledzenie wszystkich zainstalowanych w ten sposób pakietów w pewnym momencie stanie się wręcz
niemożliwe. Dlatego też przydałby nam się mechanizm, który ułatwiłby nam nieco to zadanie. Debian
udostępnia szereg narzędzi, które są w stanie w pełni zautomatyzować cały ten proces budowy
pakietów. Ten poradnik zaś ma na celu zebranie wszystkich istotniejszych informacji związanych z
obsługą narzędzi takich jak <code>dh_make</code> , <code>dpkg-buildpackage</code> , <code>pbuilder</code> , <code>quilt</code> czy <code>lintian</code> ,
tak by tworzyć pakiety w prosty sposób i przy tym równając do najwyższych standardów debiana.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-12-07T20:26:45Z">Opublikowano: 07/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-wymusic-sprawdzenie-systemu-plikow-w-systemd/">Jak wymusić sprawdzenie systemu plików w systemd</a></h1>
	<div class="entry__content"><p>Jakiś czas temu opisywałem jak w systemach linux'owych przeprowadzić <a href="https://morfikov.github.io/post/sprawdzanie-bledow-systemu-plikow-ext4/">sprawdzenie systemu plików pod
kątem ewentualnych błędów</a>. Był tam
poświęcony kawałek na temat ręcznego wymuszenia takiego skanowania. Ten sposób, który został opisany
w tamtym wpisie działa wyśmienicie w przypadku sysvinit. Natomiast przy systemd mogą pojawić się
pewne problemy, w efekcie czego nie będziemy w stanie wymusić skanowania pewnych partycji.
Generalnie to rozchodzi się o tę główną, na której znajduje się system plików <code>/</code> . Postanowiłem się
przyjrzeć nieco temu mechanizmowi i sprawdzić czy faktycznie nic nie da się zrobić i czy musimy
czekać pełną ilość cykli startu systemu, by ten system plików został przez niego przeskanowany
automatycznie.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-12-04T20:11:46Z">Opublikowano: 04/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-zwiekszyc-predkosc-zapisu-w-urzadzeniach-usb/">Jak zwiększyć prędkość zapisu w urządzeniach USB</a></h1>
	<div class="entry__content"><p>Przeglądając sobie <a href="http://www.linux-usb.org/FAQ.html">FAQ dotyczący urządzeń USB</a> natknąłem się na
punkt, który opisywał parametr <code>max_sectors</code> . Niby nic wielkiego, w linux'ie jest przecie pełno
przeróżnych opcji, przy pomocy których jesteśmy w stanie zmienić szereg aspektów pracy naszego
systemu operacyjnego. Rzecz w tym, że parametr <code>max_sectors</code> potrafi nawet dość znacznie poprawić
wydajność urządzeń USB, w tym tych wszystkich pendrive'ach, w których prędkość zapisu pozostawia
wiele do życzenia. W tym wpisie postaramy się nieco dostosować ten parametr, tak by przyśpieszyć
transfer kopiowanych plików.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-12-02T17:06:40Z">Opublikowano: 02/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/profil-apparmora-i-jego-dokladna-budowa/">Profil AppArmor&#39;a i jego dokładna budowa</a></h1>
	<div class="entry__content"><p><a href="https://morfikov.github.io/post/apparmor-profilowanie-aplikacji/">Budowanie samych profili dla AppArmor'a</a>
nie jest jakoś szczególnie trudne, zwłaszcza, gdy do tego celu wykorzystujemy narzędzia dostępne w
pakiecie <code>apparmor-utils</code> . Dobrze jest jednak prześledzić sobie
<a href="http://manpages.ubuntu.com/manpages/xenial/en/man5/apparmor.d.5.html">manual</a>
<a href="http://manpages.ubuntu.com/manpages/xenial/en/man7/apparmor.7.html">AppArmor'a</a> oraz to, co twórcy
piszą na swojej stronie w <a href="http://wiki.apparmor.net/index.php/Documentation">oficjalnej
dokumentacji</a> projektu. Poniższy wpis powstał w
celu zrozumienia składni profili AppArmor'a, tak by jeszcze bardziej uprościć proces ich budowania.</p>
<p>Opis składni znajdujący się poniżej został zaczerpnięty z
<a href="http://wiki.apparmor.net/index.php/QuickProfileLanguage">wiki</a>
<a href="http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference">AppArmor'a</a>. Część z poniższych
informacji może nie mieć zastosowania w przypadku starszych wersji samego AppArmor'a.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-12-01T17:57:39Z">Opublikowano: 01/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-odzyskac-usuniete-z-dysku-pliki/">Jak odzyskać usunięte z dysku pliki</a></h1>
	<div class="entry__content"><p><a href="https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/">Całkowite usuwanie plików (shred)</a> jak i
<a href="https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/">zerowanie całych nośników</a> ma na celu
nieodwracalne zniszczenie danych. W tych podlinkowanych artykułach próbowaliśmy zatrzeć ślady po
skasowanych plikach. W tym wpisie zaś prześledzimy sobie co tak naprawdę się dzieje po utworzeniu i
skasowaniu pliku, a także spróbujemy odzyskać te z nich, które już nie istnieją w naszym systemie.
Ten artykuł będzie dotyczył jedynie systemu plików z rodziny <code>ext</code> , głównie <code>ext4</code> .</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-11-30T19:03:05Z">Opublikowano: 30/11/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/kodowanie-nazw-plikow-i-jego-zmiana/">Kodowanie nazw plików i jego zmiana</a></h1>
	<div class="entry__content"><p>Chciałem dziś wypakować sobie kilka plików, które były zebrane w paczkę <code>.zip</code> . Problem w tym, że
ta osoba, co te pliki pakowała, najwyraźniej robiła to na widnowsie no i nie użyła standardowego
kodowania, które jest wykorzystywane na każdym innym systemie, tj. UTF-8. Wobec tego, wszystkie
pliki mają w swoich nazwach znaczek <code>�</code> w miejscu polskich liter. Jako, że tych plików jest dość
dużo, to odpada ręczna edycja nazw i trzeba pomyśleć nad jakimś innym rozwiązaniem. Zmiana
kodowania nazw plików, to nie jest to samo co <a href="https://morfikov.github.io/post/zmiana-kodowania-znakow-w-plikach-na-utf-8/">zmiana kodowania zawartości tych
plików</a>. Na szczęście w
linux'ie mamy do dyspozycji narzędzie <code>convmv</code> , które jest w stanie, jak sama nazwa mówi, przepisać
nazwy plików ustawiając przy tym odpowiednie kodowanie.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-11-27T15:15:45Z">Opublikowano: 27/11/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/zmiana-hasla-konta-administratora-root/">Zmiana hasła konta administratora root</a></h1>
	<div class="entry__content"><p>W pewnych skrajnych przypadkach może się nam zdarzyć tak, że zapomnimy hasła do konta administratora
systemu. Jak wiadomo bez użytkownika root w naszych linux'ach nie da się zbytnio nic zrobić. Na
pewno nie da się przeprowadzić żądnych prac administracyjnych. Zwykle w takim przypadku moglibyśmy
przeinstalować system i ustawić nowe hasło ale to wydaje się lekką przesadą. Poza tym, co w
przypadku gdy nie możemy zwyczajnie zainstalować na nowo systemu lub nie mamy akurat pod ręką płytki
czy pendrive live? Czy w linux'ie jest w ogóle możliwość odzyskania hasła użytkownika root bez
rozkręcania komputera biorąc pod uwagę te wszystkie mechanizmy bezpieczeństwa, które czynią ten
system tak bezpiecznym? Oczywiście zmiana hasła do konta administratora jest możliwa i nawet nie
trzeba się przy tym zbytnio wysilać.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-11-25T13:55:44Z">Opublikowano: 25/11/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/">Programowe i sprzętowe zerowanie dysku</a></h1>
	<div class="entry__content"><p>Zerowanie dysku twardego ma na celu usunięcie wszystkich znajdujących się na nim danych. Generalnie
chodzi o zapisanie całej powierzchni danego nośnika samymi zerami. Ten proces różni się znacząco of
formatowania dysku, czyli utworzenia nowego systemu plików, gdzie praktycznie wszystkie dane można
bez większego problemu odzyskać. Zerowanie dysku (czy też pendrive) może w pewnych przypadkach
<a href="https://morfikov.github.io/post/uszkodzony-sektor-na-dysku-i-jego-realokacja/">naprawić logiczne błędy sektorów</a> na dysku. Niemniej jednak, nie usuniemy za jego pomocą
fizycznych bad'ów. Generalnie rzecz biorąc, mamy do wyboru dwie techniki zerowania. Jedna jest
dokonywana na poziomie programowym, np. przy pomocy <code>dd</code> , druga zaś na poziomie sprzętowym, np. w
<code>hdparm</code> . W tym wpisie postaramy się wyzerować przykładowy dysk.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-11-24T17:54:17Z">Opublikowano: 24/11/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/">Całkowite usuwanie plików przy pomocy shred</a></h1>
	<div class="entry__content"><p>W przypadku, gdy musimy pozbyć się jakiegoś pliku, który znajduje się na dysku, to nie jest zalecane
korzystanie z narzędzia <code>rm</code> . Usuwa ono jedynie odnośnik do pliku, który go identyfikuje w
strukturze systemu plików, tzw. <a href="https://pl.wikipedia.org/wiki/I-w%C4%99ze%C5%82">i-węzeł</a> (i-node).
To co uzyskujemy za pomocą takich narzędzi jak <code>rm</code> , to jedynie oznaczenie pewnych bloków (tych od
pliku) jako wolne, w których system operacyjny będzie w stanie dokonać zapisu danych późniejszym
czasie. Podczas tej operacji nie są usuwane żadne informacje z dysku, a mając na uwadze ten fakt,
możemy bez problemu tak &quot;usunięty&quot; plik odzyskać. By mieć pewność, że plik zostanie trwale
zniszczony, trzeba go ponownie napisać, np. przy pomocy
<a href="http://manpages.ubuntu.com/manpages/wily/en/man1/shred.1.html">shred</a>, który standardowo jest
dostępny w każdej dystrybucji linux'a i to jemu będzie poświęcony ten wpis.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-11-24T15:11:32Z">Opublikowano: 24/11/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
					<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/integralnosc-plikow-passwd-group-shadow-gshadow/">Integralność plików passwd, group, shadow, gshadow</a></h1>
	<div class="entry__content"><p>W pliku <code>/etc/passwd</code> jest przechowywana baza danych kont użytkowników w systemie linux. Z kolei w
<code>/etc/group</code> mamy wypisane wszystkie grupy oraz powiązanych z nimi użytkowników. Generalnie rzecz
biorąc, to te dwa pliki odpowiadają za konfigurację kont. Problem jednak zaczyna się w momencie gdy
w grę wchodzą hasła, zarówno do kont jak i do grup. Gdyby były one trzymane w tych plikach, nie
byłyby one w żaden sposób szyfrowane. Dlatego też powstał inny mechanizm, który ma na celu
przeniesienie zahashowanych haseł do plików <code>/etc/shadow</code> i <code>/etc/gshadow</code> . W debianie
użytkownikami i grupami możemy zarządzać przy pomocy odpowiednich narzędzi, które automatycznie
dostosują wszystkie powyższe pliki. Nic jednak nie stoi na przeszkodzie aby edytować każdy z nich
ręcznie. Problemy mogą się pojawić w momencie, gdy te pliki będą zawierać różne wpisy, np. w pliku
<code>passwd</code> będzie określony użytkownik, który jednocześnie nie będzie istniał w pliku <code>shadow</code> ,
podobnie z grupami. W tym wpisie postaramy się sprawdzić te pliki i upewnimy się czy aby na pewno
jest z nimi wszystko w porządku.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-11-24T12:30:34Z">Opublikowano: 24/11/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
					</div>
			</div>
	</main>
	
<div class="pagination block">
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/">1</a>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/page/2/">2</a>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/page/3/">3</a>
			<span class="pagination__item pagination__item--gap">&hellip;</span>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/page/39/">39</a>
				<span class="pagination__item pagination__item--active" data-total="59">40</span>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/page/41/">41</a>
			<span class="pagination__item pagination__item--gap">&hellip;</span>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/page/59/">59</a>
</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2023 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
const images = Array.from(document.querySelectorAll(".entry__content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null,  
    background: 'rgba(0, 0, 0, 0.8)'
  });
});
</script>
</body>
</html>
