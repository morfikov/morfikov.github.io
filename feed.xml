<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Morfitronik</title>
    <link>https://morfikov.github.io/</link>
    <description>Recent content on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sun, 16 Jun 2024 16:30:00 +0200</lastBuildDate><atom:link href="https://morfikov.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux</title>
      <link>https://morfikov.github.io/post/trim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux/</link>
      <pubDate>Sun, 16 Jun 2024 16:30:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/trim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux/</guid>
      <description>&lt;p&gt;Jakiś czas temu opisywałem &lt;a href=&#34;https://morfikov.github.io/post/trim-discard-przy-luks-lvm-na-dysku-ssd-pod-debian-linux/&#34;&gt;jak na Debianie włączyć obsługę mechanizmu TRIM&lt;/a&gt; (realizowanego
przez polecenie &lt;code&gt;fstrim&lt;/code&gt; ) na podpiętych do komputera dyskach SSD. Problem w tym, że dyski SSD, z
którymi będziemy wchodzić w interakcję, nie zawsze będą podłączane do dedykowanych portów
SATA/mSATA. Jak zachowa się zatem nasz linux, gdy będziemy chcieli podłączyć po portu USB
zewnętrzny dysk SSD? Przez zewnętrzny dysk USB nie mam na myśli dedykowanych zewnętrznych dysków
USB, bo te raczej nie powinny sprawiać kłopotów. Chodzi mi bardziej o wewnętrzne dyski SSD (np. ze
starego laptopa), które zamkniemy w dedykowanej obudowie USB, lub też będziemy taki dysk podłączać
na krótko za pomocą adaptera USB-SATA. W takich przypadkach zwykle kernel linux&#39;a nie odważy się
włączyć wsparcia dla TRIM dla nośników SSD i tak właśnie się stało w przypadku mojego nowo
zakupionego dysku od Goodram, a konkretnie jest to model &lt;code&gt;SSDPR-CX400-02T-G2&lt;/code&gt; , który to został
podłączony do portu USB3 mojego Raspberry PI (i Debiana) przy pomocy kabelka USB-SATA (Unitek
USB3.1 USB-A to 2.5&amp;quot; SATA6G). Przez kilka miesięcy dysk sprawował się bez zarzutu ale ostatnio przy
próbie wgrania na niego danych (przez sieć), transfer spadł do dosłownie pojedynczych MiB/s.
Poszukałem trochę informacji i okazało się, że dla tego typu nośników &lt;a href=&#34;https://www.jeffgeerling.com/blog/2020/enabling-trim-on-external-ssd-on-raspberry-pi&#34;&gt;trzeba ręcznie włączyć
TRIM&lt;/a&gt;, o ile będzie to w ogóle możliwe.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja CIFS/SMB/SAMBA pod Debian Linux (smbd/avahi/mdns/gvfs)</title>
      <link>https://morfikov.github.io/post/konfiguracja-cifs-smb-samba-pod-debian-linux-smbd-avahi-mdns-gvfs/</link>
      <pubDate>Mon, 03 Jun 2024 20:00:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-cifs-smb-samba-pod-debian-linux-smbd-avahi-mdns-gvfs/</guid>
      <description>&lt;p&gt;Z racji, że w mojej sieci domowej pojawia się coraz więcej maszyn, które mają na pokładzie różne
systemy operacyjne (począwszy od linux&#39;ów, przez androidy, a na windows&#39;ach skończywszy), to
postanowiłem w końcu wypracować jakiś w miarę uniwersalny sposób na dzielenie się plikami w tej
sieci LAN. Rozwiązania pokroju SSH/SSHFS są w porządku ale jedynie w przypadku linux&#39;ów. Serwery
HTTP/FTP są trochę mało poręczne i słabo się nadają do tego celu. Z kolei NFS miał u mnie jakieś
większe/mniejsze problemy z wydajnością, a i też nie wiem jak wygląda wsparcie dla NFS na windows.
W zasadzie to pozostała mi ostatnia opcja w postaci protokołu &lt;a href=&#34;https://www.samba.org/&#34;&gt;CIFS/SMB/SAMBA&lt;/a&gt;, który
przynajmniej na windows powinien działać bez zarzutu. Trzeba jednak będzie przystosować mojego
Debiana do pracy z tym protokołem. Chodzi generalnie o to, by bez większego problemu być w
stanie udostępnić z jednej maszyny kilka katalogów innym użytkownikom sieci domowej i to bez
znaczenia czy robimy to z windows&#39;a i docelowo siedzimy na linux&#39;ie, czy też w drugą stronę, tj.
udostępniamy katalogi z linux&#39;a, by być w stanie przeglądać ich zawartość na windows. Wdrożenie
obsługi protokołu CIFS/SMB/SAMBA na linux jest stosunkowo proste, bo wystarczy zainstalować pakiet
&lt;code&gt;samba&lt;/code&gt; , wydać w terminalu kilka poleceń i po sprawie. Problem jednak zaczyna się, gdy chcemy
sobie nieco ułatwić życie, tak by w menadżerze plików (np. &lt;code&gt;nemo&lt;/code&gt; , &lt;code&gt;caja&lt;/code&gt; , &lt;code&gt;pcmanfm&lt;/code&gt; ) te
wszystkie zasoby były z automatu widoczne po przejściu do zakładki sieć/network. Pozostają też do
rozważenia kwestie związane z bezpieczeństwem tego całego mechanizmu wymiany plików.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Przestrzeń wymiany SWAP tylko na potrzebny hibernacji w Debian linux</title>
      <link>https://morfikov.github.io/post/przestrzen-wymiany-swap-tylko-na-potrzebny-hibernacji-w-debian-linux/</link>
      <pubDate>Wed, 10 Jan 2024 20:05:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/przestrzen-wymiany-swap-tylko-na-potrzebny-hibernacji-w-debian-linux/</guid>
      <description>&lt;p&gt;W obecnych czasach, rola przestrzeni wymiany w zasadzie ograniczyła się z grubsza do umożliwienia
nam przeprowadzenia procesu hibernacji. Inne aspekty pracy systemu, w których SWAP brał udział
zostały albo zepchnięte na margines (bardzo stare maszyny z niewielką ilością RAM), albo zupełnie
wyeliminowane za sprawą nowszych technologi lub/i posiadania większej ilości pamięci operacyjnej w
takich systemach. Obecnie domowy komputer z 32 GiB pamięci RAM to nic niezwykłego i przestrzeń
wymiany na takich maszynach nie jest już nam w zasadzie do niczego potrzebna, bo raczej jest mało
prawdopodobne, że nam tej pamięci zabraknie przy codziennym użytkowaniu naszego linux&#39;a. Niemniej
jednak, hibernacja systemu jest czymś pozytywnym z perspektywy użytkownika, bo umożliwia mu
zapisanie stanu pracy przed wyłączeniem komputera i odtworzenie tego stanu po ponownym uruchomieniu
systemu. Jeśli chcielibyśmy się cieszyć urokami hibernacji, to bez konfiguracji SWAP&#39;a się nie
obejdzie. Problem jednak zaczyna się, gdy mamy dysk SSD i taka przestrzeń wymiany zostanie na nim
skonfigurowana. Chodzi generalnie o pewne aplikacje, które są w stanie generować bardzo dużo cache
w pamięci operacyjnej, czego efektem będzie przenoszenie danych z RAM do SWAP, a to może bardzo
szybko wykończyć taki nośnik flash. Dlatego też przydałoby się nieco zabezpieczyć przestrzeń
wymiany przed tego typu sytuacjami, tak by można było jej używać jedynie w przypadku hibernacji.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Trim/discard przy LUKS/LVM na dysku SSD pod Debian linux</title>
      <link>https://morfikov.github.io/post/trim-discard-przy-luks-lvm-na-dysku-ssd-pod-debian-linux/</link>
      <pubDate>Fri, 15 Dec 2023 17:00:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/trim-discard-przy-luks-lvm-na-dysku-ssd-pod-debian-linux/</guid>
      <description>&lt;p&gt;Z okazji zbliżającego się końca roku, postanowiłem nieco ogarnąć swojego Debiana, tj. postawić go
na nowo. Jakby nie patrzeć 4 lata korzystania z tego linux&#39;a z włączonymi gałęziami unstable i
experimental sprawiło, że trochę syfu się nazbierało. Nie chciałem też czyścić całego kontenera
LUKS czy samej struktury LVM z systemowymi voluminami logicznymi na starym dysku HDD, bo
zainstalowany tam system zawsze może się do czegoś przydać, np. do odratowania tego nowego linux&#39;a.
Dlatego też postanowiłem zakupić niedrogi dysk SSD (MLC, używany) i to na nim &lt;a href=&#34;https://morfikov.github.io/post/instalacja-debiana-z-wykorzystaniem-debootstrap/&#34;&gt;postawić świeżego
Debiana z wykorzystaniem narzędzia debootstrap&lt;/a&gt;. Sama instalacja linux&#39;a na dysku SSD nie różni
się zbytnio od instalacji na dysku HDD, za wyjątkiem skonfigurowania w takim systemie mechanizmu
trim/discard. Standardowi użytkownicy linux&#39;a nie muszą zbytnio nic robić, aby ten mechanizm został
poprawnie skonfigurowany. Sprawa się nieco komplikuje, gdy wykorzystywany jest &lt;a href=&#34;https://en.wikipedia.org/wiki/Device_mapper&#34;&gt;device-mapper&lt;/a&gt;,
który mapuje fizyczne bloki urządzenia na te wirtualne, np. przy szyfrowaniu dysku z wykorzystaniem
LUKS/dm-crypt, czy korzystaniu z voluminów logicznych LVM. Dlatego też postanowiłem przyjrzeć się
nieco bliżej zagadnieniu konfiguracji mechanizmu trim/discard na dysku SSD w przypadku
zaszyfrowanego systemu na bazie LUKS+LVM.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Martwy smartfon Xiaomi Redmi 9 i jego odzysk via SP Flash Tool</title>
      <link>https://morfikov.github.io/post/martwy-smartfon-xiaomi-redmi-9-i-jego-odzysk-via-sp-flash-tool/</link>
      <pubDate>Sun, 29 Jan 2023 19:33:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/martwy-smartfon-xiaomi-redmi-9-i-jego-odzysk-via-sp-flash-tool/</guid>
      <description>&lt;p&gt;Przeglądając ostatnio stronę &lt;code&gt;xiaomifirmwareupdater.com&lt;/code&gt; zauważyłem, że jest tam &lt;a href=&#34;https://xiaomifirmwareupdater.com/firmware/lancelot/&#34;&gt;dostępna nowsza
wersja firmware dla mojego telefonu Xiaomi Redmi 9&lt;/a&gt; (lancelot/galahad). Patrząc po numerkach
&lt;code&gt;V13.0.1.0.SJCEUXM&lt;/code&gt; (nowy dla Android 12) oraz &lt;code&gt;V12.5.4.0.RJCEUXM&lt;/code&gt; (stary dla Android 11), miałem
pewne wątpliwości czy wgrać sobie ten nowszy firmware. Niby na tym smartfonie mam wgrany &lt;a href=&#34;https://crdroid.net/lava/8&#34;&gt;ROM
crDrdoid v8.9&lt;/a&gt;, który dostarcza Androida 12.1, więc &lt;a href=&#34;https://morfikov.github.io/post/jak-zaktualizowac-firmware-custom-rom-w-smartfonach-xiaomi/&#34;&gt;aktualizacja firmware sposobem opisanym
tutaj&lt;/a&gt; powinna przebiec bez żadnych problemów. No i przebiegła, tylko po zrestartowaniu telefonu,
ten już się nie uruchomił. Działał mi jedynie tryb fastboot (normalny boot i tryb recovery były
martwe). Postanowiłem przywrócić poprzedni firmware wydobywając obrazy ze starej paczki firmware i
ręcznie przy pomocy narzędzia &lt;code&gt;fastboot&lt;/code&gt; wgrać te obrazy na odpowiadające im partycje w telefonie z
poziomu mojego Debiana. Tutaj jednak zostało poczynionych parę błędów (o tym później), które
doprowadziły do całkowitego uwalenia telefonu (hard brick), gdzie nawet tryb fastboot zdechł. W
efekcie telefon już nie reagował na żadne kombinacje przycisków, a ekran pozostawał czarny -- jednym
słowem nie działał żaden tryb pracy telefonu i wyglądało na to, że mam w łapkach już tylko sam złom
elektroniczny i tak by w istocie było, gdyby z pomocą nie przyszedł mi SP Flash Tool.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zablokowanie możliwości ładowania modułów kernela na Debian linux</title>
      <link>https://morfikov.github.io/post/zablokowanie-mozliwosci-ladowania-modulow-kernela-na-debian-linux/</link>
      <pubDate>Tue, 13 Dec 2022 13:03:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/zablokowanie-mozliwosci-ladowania-modulow-kernela-na-debian-linux/</guid>
      <description>&lt;p&gt;Kernele oferowane przez różne dystrybucje linux&#39;a, np. Debian czy Ubuntu, są tak budowane by
możliwie jak największa ilość sprzętu na takim jądrze operacyjnym nam zadziałała bez zbędnego
przerabiania systemu. Takie podejście sprawia, że nowo nabyty przez nas sprzęt możemy od razu
podłączyć do komputera, a stosowne moduły po rozpoznaniu urządzenia zostaną załadowane do pamięci
operacyjnej, przez co my będziemy mogli wejść w interakcję z takim kawałkiem elektroniki. Problem w
tym, że kernel ma bardzo dużo tych modłów. Dużo modułów, to więcej kodu, a więcej kodu to więcej
błędów, które na poziomie jądra mogą być bardzo opłakane w skutkach. Z zagrożeniem, jakie niosą
moduły zewnętrzne (te spoza drzewa kernela linux), można sobie poradzić &lt;a href=&#34;https://morfikov.github.io/post/jak-dodac-wlasne-klucze-dla-secure-boot-do-firmware-efi-uefi-pod-linux/#podpisywanie-kernela&#34;&gt;podpisując kernel kluczami
od firmware EFI/UEFI&lt;/a&gt;. W takim przypadku załadowanie niepodpisanego modułu już się nie powiedzie.
Niemniej jednak, dystrybucyjne kernele mają całą masę modułów do różnorakiego sprzętu, które na
etapie budowania kernela są podpisywane, co otwiera im drogę do bycia załadowanymi w naszym
systemie nawet jeśli nie posiadamy urządzeń, które by użytek z tych modułów robiły. Przydałoby się
zatem zabezpieczyć możliwość ładowania modułów kernela w taki sposób, by jedynie administrator
systemu miał możliwość określenia jakie moduły i na którym etapie pracy systemu mogą one zostać
załadowane.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Oblivious DoH (ODoH) z dnscrypt-proxy na Debian Linux</title>
      <link>https://morfikov.github.io/post/oblivious-doh-odoh-z-dnscrypt-proxy-na-debian-linux/</link>
      <pubDate>Mon, 21 Nov 2022 17:42:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/oblivious-doh-odoh-z-dnscrypt-proxy-na-debian-linux/</guid>
      <description>&lt;p&gt;Parę miesięcy temu natrafiłem na taki oto &lt;a href=&#34;https://blog.cloudflare.com/oblivious-dns/&#34;&gt;artykuł na blogu Cloudflare&lt;/a&gt;, który poświęcony jest
poprawie prywatności wykonywanych przez klientów zapytań DNS za sprawą wykorzystania mechanizmu
zwanego Oblivious DoH (ODoH). Oczywiście postanowiłem już wtedy zbadać czym ten ODoH jest ale
standardowe narzędzia dostępne w linux&#39;ie (Debian/Ubuntu) jeszcze (przynajmniej wtedy) nie dojrzały
do obsługi ODoH. Obecnie już jest trochę lepiej ale Oblivious DoH wciąż jest w fazie
eksperymentów (&lt;a href=&#34;https://datatracker.ietf.org/doc/html/rfc9230&#34;&gt;RFC9230&lt;/a&gt;). Póki co, jedynym znanym mi narzędziem, które posiada wsparcie dla
ODoH jest &lt;a href=&#34;https://dnscrypt.info/&#34;&gt;dnscrypt-proxy&lt;/a&gt;, którego instalację i konfigurację do współpracy z &lt;code&gt;dnsmasq&lt;/code&gt;
już &lt;a href=&#34;https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/&#34;&gt;jakiś czas temu opisywałem&lt;/a&gt;. Mając wsparcie dla ODoH w &lt;code&gt;dnscrypt-proxy&lt;/code&gt; możemy pokusić się
o wdrożenie Oblivious DoH w swoim systemie i sprawdzić czy faktycznie taki zabieg przyczyni się do
poprawy prywatności wykonywanych przez nas zapytań DNS i właśnie temu zagadnieniu będzie poświęcony
niniejszy wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zainstalować Magisk bez dostępu do TWRP/SHRP recovery</title>
      <link>https://morfikov.github.io/post/jak-zainstalowac-magisk-bez-dostepu-do-twrp-shrp-recovery/</link>
      <pubDate>Mon, 28 Feb 2022 19:46:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zainstalowac-magisk-bez-dostepu-do-twrp-shrp-recovery/</guid>
      <description>&lt;p&gt;Parę dni temu na mój telefon Xiaomi Redmi 9 (lancelot/galahad/shiva/lava) &lt;a href=&#34;https://crdroid.net/lava/8&#34;&gt;została wypuszczona
aktualizacja ROM&#39;u crDroid&lt;/a&gt;, który bazuje na AOSP/LineageOS. Ten update nie tylko miał
uwzględnione najnowsze poprawki bezpieczeństwa ale również podbijał wersję Androida z 11 na 12.
Problem w tym, że TWRP/SHRP recovery ma problemy z obsługą sposobu szyfrowania partycji &lt;code&gt;/data/&lt;/code&gt; ,
który najwyraźniej uległ przeobrażeniu w Androidzie 12. Efektem braku wsparcia dla szyfrowania w
TWRP/SHRP jest naturalnie brak możliwości wgrywania danych na partycję &lt;code&gt;/data/&lt;/code&gt; . Niestety niesie
to za sobą przykre konsekwencje w postaci uniemożliwienia użytkownikowi przeprowadzenia procesu
patch&#39;owania obrazu partycji &lt;code&gt;/boot/&lt;/code&gt; z poziomu trybu recovery, czego efektem jest brak możliwości
zainstalowania Magisk&#39;a w systemie smartfona. Bez Magisk&#39;a nie damy rady ukorzenić systemu, tj.
uzyskać w nim praw administratora root. Na szczęście nie wszystko stracone. Magisk&#39;a można
zainstalować w telefonie ręcznie przy pomocy ADB oraz trybu bootloader&#39;a (fastboot) eliminując tym
samym potrzebę przełączenia się w tryb recovery. Niniejszy artykuł ma na celu pokazanie jak
zainstalować Magisk&#39;a bez odwoływania się do trybu TWRP/SHRP recovery.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Tryb bezczynności baterii (IDLE mode) w smartfonach z Androidem</title>
      <link>https://morfikov.github.io/post/tryb-bezczynnosci-baterii-idle-mode-w-smartfonach-z-androidem/</link>
      <pubDate>Sun, 06 Feb 2022 17:52:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/tryb-bezczynnosci-baterii-idle-mode-w-smartfonach-z-androidem/</guid>
      <description>&lt;p&gt;Gdy zapytamy użytkowników smartfonów z Androidem o to, czy taki sprzęt jest w stanie pracować z
pominięciem układu baterii, zapewne wiele z tych osób odpowiedziałoby, że nie ma takiej opcji, bo
przecież w tych telefonach od lat baterii się już nie da wyciągnąć. Nawet w tych starszych
modelach, po wyjęciu baterii i podłączeniu ładowarki, system w takim urządzeniu nie chciał się
uruchomić. Okazuje się jednak, że nie trzeba wyjmować akumulatora ze smartfona, by to urządzenie
było w stanie działać z pominięciem układu baterii, tj. w tzw. trybie bezczynności baterii (battery
IDLE mode), coś na wzór rozwiązania stosowanego od dekad w laptopach. Niemniej jednak, takiej
funkcjonalności zwykle nie uświadczymy w stock&#39;owych Androidach. Możemy się jednak o nią postarać
ale do tego celu niezbędne będzie nam uzyskanie praw administratora systemu root, choć lepiej wgrać
sobie na smartfon ROM na bazie AOSP/LineageOS. Bez ukorzenionego Androida nie mamy nawet co
podchodzić do implementacji tego mechanizmu. Dodatkowo będzie nam potrzebny &lt;a href=&#34;https://github.com/VR-25/acc&#34;&gt;zaawansowany kontroler
ładowania baterii ACC&lt;/a&gt; (w postaci modułu do Magisk&#39;a) i opcjonalnie też &lt;a href=&#34;https://github.com/MatteCarra/AccA&#34;&gt;graficzna nakładka
ACCA&lt;/a&gt; (do pobrania z F-Droid). W poniższym artykule postaramy się odpowiedzieć na pytanie czy
takie rozwiązanie na bazie IDLE mode w przypadku baterii w smartfonach z Androidem ma w ogóle sens
i czy może nam się ewentualnie do czegoś przydać.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Rekalibracja baterii w laptopach Lenovo ThinkPad pod linux</title>
      <link>https://morfikov.github.io/post/rekalibracja-baterii-w-laptopach-lenovo-thinkpad-pod-linux/</link>
      <pubDate>Tue, 01 Feb 2022 18:09:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/rekalibracja-baterii-w-laptopach-lenovo-thinkpad-pod-linux/</guid>
      <description>&lt;p&gt;Jakiś już czas temu opisywałem temat &lt;a href=&#34;https://morfikov.github.io/post/jak-ograniczyc-ladowanie-baterii-w-laptopie-thinkpad-t430/&#34;&gt;konfiguracji progów ładowania baterii w laptopie Lenovo
ThinkPad T430&lt;/a&gt;, tak by przedłużyć parokrotnie jej żywotność. Niemniej jednak, ustawienie na
dłuższy czas progów 30-40% nie pozostaje bez wpływu na pracę maszyny. Może i same baterie
litowo-jonowe nie posiadają efektu pamięci ale elektronika, która tymi bateriami zarządza, już tę
pamięć może posiadać. Chodzi generalnie o to, że brak pełnych cyklów baterii (rozładowanie do 0% i
ładowanie do 100%) może powodować różne błędy w ocenie ile faktycznie tego ładunku w takim
akumulatorze pozostało. Efektem tych błędów są wskazania sugerujące, że nasz laptop może jeszcze
popracować, np. 20-30 minut dłużej, gdy stan faktyczny na to nie pozwala, co skończyć może się
utratą niezapisanych danych w skutek nagłego odcięcia zasilania. Dlatego też jeśli wykorzystujemy
jedynie pewien zakres pojemności baterii w laptopie, to co pewien czas (co 30-50 takich niepełnych
cykli albo raz na 2 miesiące) przydałoby się przeprowadzić w laptopie proces rekalibracji baterii
(a raczej rekalibrację jej kontrolera/elektroniki), tak by ewentualne straty pojemności zostały
uwzględnione w szacunkach systemu. Zabieg rekalibracji baterii można bez większego problemu
przeprowadzić z poziomu dowolnej dystrybucji linux&#39;a, np. Debian/Ubuntu, i tym zagadnieniem się
zajmiemy w niniejszym artykule.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana adresu MAC (BSSID) routera WiFi w OpenWRT</title>
      <link>https://morfikov.github.io/post/zmiana-adresu-mac-bssid-routera-wifi-w-openwrt/</link>
      <pubDate>Sun, 30 Jan 2022 20:23:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-adresu-mac-bssid-routera-wifi-w-openwrt/</guid>
      <description>&lt;p&gt;Pisząc ostatnio artykuł o tym &lt;a href=&#34;https://morfikov.github.io/post/jak-ukryc-nazwe-sieci-wifi-essid-przed-wigle-net-google-mozilla/&#34;&gt;jak uchronić nasz prywatny punkt dostępu do sieci WiFi przed
zmapowaniem&lt;/a&gt; i umieszczeniem jego fizycznej lokalizacji w serwisach pokroju Wigle.net czy też w
usługach Google/Mozilla, poruszony został temat ewentualnego usuwania wpisów z takich baz danych AP
za sprawą dopisywania do nazwy sieci (ESSID) sufiksu &lt;code&gt;_nomap&lt;/code&gt; . Nie wszystkie organizacje/firmy
respektują naszą prywatność i raczej też nie będą tej końcówki w nazwie sieci honorować. Jako, że
jednym z dwóch parametrów, na podstawie których takie mapowanie punktów dostępowych się odbywa,
jest adres MAC interfejsu bezprzewodowego danego AP (BSSID), to możemy od czasu do czasu pokusić
się o zmianę tego adresu. Jest to mniej więcej to samo rozwiązanie, co zastosowane przy &lt;a href=&#34;https://morfikov.github.io/post/jak-sklonowac-adres-mac-w-openwrt/&#34;&gt;klonowaniu
adresu MAC dla portu WAN routera&lt;/a&gt;, które z reguły użytkownicy wykorzystują do obchodzenia
zabezpieczeń tych bardziej wrednych ISP. Jako, że temat zmiany BSSID trochę się różni od zmiany
adresu MAC dla portu WAN, to w niniejszym artykule postanowiłem opisać jak w routerze z wgranym
firmware OpenWRT podejść do tego zadania.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ukryć nazwę sieci WiFi (ESSID) przed Wigle.net/Google/Mozilla</title>
      <link>https://morfikov.github.io/post/jak-ukryc-nazwe-sieci-wifi-essid-przed-wigle-net-google-mozilla/</link>
      <pubDate>Sat, 29 Jan 2022 17:12:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-nazwe-sieci-wifi-essid-przed-wigle-net-google-mozilla/</guid>
      <description>&lt;p&gt;Parę dni temu napisał do mnie megabajt z forum DUG z wiadomością, że nazwa mojego WiFi figuruje w
bazie danych serwisu &lt;a href=&#34;https://wigle.net/&#34;&gt;Wigle.net&lt;/a&gt; oraz, że lepiej nie zdradzać nazw swoich WiFi osobom trzecim,
bo ktoś w oparciu o te dane może poznać nasze fizyczne położenie. Jak najbardziej istnieje taka
możliwość, a sam serwis Wigle.net nie jest jedynym, który zbiera informacje o położeniach
geograficznych punktów dostępowych WiFi, bo od lat robi to też Google i Mozilla. Niemniej jednak,
podchodziłbym z pewną dozą ostrożności do danych zgromadzonych w serwisie Wigle.net (i tych
pozostałych dwóch też), bo nie zawsze muszą one być akuratne. W zasadzie to nie zdziwiłem się
zbytnio, że nazwa mojej sieci WiFi figuruje w bazie danych Wigle.net, bo sam ją tam umieściłem
świadomie jakiś czas temu w ramach testów wykorzystując do tego celu aplikację &lt;a href=&#34;https://f-droid.org/en/packages/net.wigle.wigleandroid/&#34;&gt;WiGLE WiFi
Wardriving&lt;/a&gt;, którą można wgrać przez F-Droid na każdy telefon z Androidem. Jako, że nadarzyła się
okazja, to postanowiłem napisać parę słów na temat unikania bycia zmapowanym, tak by jakiś nieznany
nam bliżej osobnik przez przypadek nie wrzucił lokalizacji naszych domowych/firmowych AP do bazy
danych Google/Mozilla czy też wspomnianego wyżej serwisu Wigle.net, o ile oczywiście sobie tego nie
życzymy.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Nagrywanie rozmów telefonicznych w smartfonie z Androidem</title>
      <link>https://morfikov.github.io/post/nagrywanie-rozmow-telefonicznych-w-smartfonie-z-androidem/</link>
      <pubDate>Sun, 23 Jan 2022 18:11:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/nagrywanie-rozmow-telefonicznych-w-smartfonie-z-androidem/</guid>
      <description>&lt;p&gt;Właściciele smartfonów mają zwykle podpisane umowy ze swoimi operatorami GSM na świadczenie usług
telefonicznych. Pakiety rozmów oferowane przez tych operatorów już od dłuższego czasu są
nielimitowane, co z kolei zachęca abonentów do głosowego komunikowania się przy pomocy tych małych
lecz przy tym bardzo zaawansowanych technologicznie komputerów. Nie ma obecnie chyba sprawy, której
nie można załatwić telefonicznie, a że coraz dłużej wisimy na słuchawce, to też sporo informacji z
takich rozmów nam bezpowrotnie ucieka, np. imię i nazwisko osoby, z którą rozmawialiśmy, nie
wspominając o całej masie innych rzeczy, które mogą paść podczas choćby negocjowania/przedłużania
jakiegoś kontraktu. Gdy w późniejszym czasie zorientujemy się, że coś jest nie tak, to możemy mieć
poważny problem z udowodnieniem swoich racji, np. że zostaliśmy celowo wprowadzeni w błąd. Gdybyśmy
dysponowali nagraniem z takiej rozmowy, to bez problemu można by się do niego odnieść i nikt by nie
miał wątpliwości po czyjej stronie byłaby racja. Niemniej jednak, smartfony z Androidem mają
ogromny problem z nagrywaniem dźwięku audio podczas tego typu konwersacji, czego efektem jest brak
możliwości niezależnego rejestrowania rozmów telefonicznych. Jeśli jednak posiadamy ukorzenionego
Androida (dostęp do praw administratora root), to możemy te obostrzenia obejść zaprzęgając do pracy
aplikację Call Recorder.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Automatyczny restart połączenia LTE na routerze WiFi z OpenWRT</title>
      <link>https://morfikov.github.io/post/automatyczny-restart-polaczenia-lte-na-routerze-wifi-z-openwrt/</link>
      <pubDate>Tue, 30 Nov 2021 20:25:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/automatyczny-restart-polaczenia-lte-na-routerze-wifi-z-openwrt/</guid>
      <description>&lt;p&gt;Od już dłuższego czasu (będzie parę lat) korzystam z internetu LTE zamiast tradycyjnego połączenia
przewodowego. Głównie ze względu na fakt, że w mojej okolicy nie ma praktycznie żadnych szanujących
się ISP, z którymi warto by wejść w interakcję i podpisać z nimi jakąś sensową umowę. Poza tym, dla
osób mojego pokroju, które cenią sobie mobilność, internet stacjonarny i tak jest mało praktyczny.
Dlatego w moim domowym routerze mam wgrany firmware OpenWRT umożliwiający zainstalowanie na tym
urządzeniu odpowiedniego oprogramowania obsługującego modemy LTE podłączane przez port USB.
Połączenie sieciowe ze światem zwykle działa prawidłowo ale z jakiegoś powodu jest ono zrywane.
Zwykle taka sytuacja ma miejsce w środku nocy (czasami parokrotnie), zwłaszcza gdy przekroczę limit
danych i do końca okresu rozliczeniowego muszę przemęczyć się z lejkiem 1 mbit/s. Gdy ten lejek
jest aplikowany, to zwykle odpalam sobie torrent&#39;a, tak by pobrać najnowsze obrazy ISO tej czy
innej dystrybucji linux&#39;a. Niemniej jednak, jak mi net rozłączą, to nie załączy się on ponownie sam
z siebie. Modem Huawei E3372s-153 w wersji NON-HiLink zdaje się pracować poprawnie, bo świeci się
na nim dioda sugerująca, że połączenie z internetem jest nawiązane. Dlatego też postanowiłem w
końcu ten problem rozwiązać raz na zawsze i mieć przy tym nieco spokojniejszy sen.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wsparcie dla WiFi w initramfs/initrd by odszyfrować LUKS przez SSH bezprzewodowo</title>
      <link>https://morfikov.github.io/post/wsparcie-dla-wifi-w-initramfs-initrd-by-odszyfrowac-luks-przez-ssh-bezprzewodowo/</link>
      <pubDate>Sat, 13 Nov 2021 13:26:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/wsparcie-dla-wifi-w-initramfs-initrd-by-odszyfrowac-luks-przez-ssh-bezprzewodowo/</guid>
      <description>&lt;p&gt;W poprzednim artykule, który traktował o &lt;a href=&#34;https://morfikov.github.io/post/odszyfrowanie-luks-przez-ssh-z-poziomu-initramfs-initrd-na-raspberry-pi/&#34;&gt;odszyfrowaniu kontenera LUKS przez SSH z poziomu
initramfs/initrd na Raspberry Pi&lt;/a&gt;, została poruszona kwestia adresacji IP, która w opisanym tam
rozwiązaniu miała pewne ograniczenia. Chodziło o to, że połączenie SSH do RPI mogło być realizowane
jedynie przez przewodowy interfejs sieciowy &lt;code&gt;eth0&lt;/code&gt; . Trzeba było zatem się zastanowić nad
rozwiązaniem, które umożliwiłoby korzystanie również z bezprzewodowego interfejsu WiFi, tj.
&lt;code&gt;wlan0&lt;/code&gt; . Celem niniejszego wpisu jest pokazanie w jaki sposób można dorobić wsparcie dla
połączeń WiFi w naszej malinie, tak by szło odszyfrować kontener LUKS przez SSH, w sytuacji gdy z
jakiegoś powodu nie chcemy lub też nie możemy korzystać z przewodowego interfejsu sieciowego tego
minikomputera z zainstalowanym system RasPiOS/Raspbian.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Odszyfrowanie LUKS przez SSH z poziomu initramfs/initrd na Raspberry Pi</title>
      <link>https://morfikov.github.io/post/odszyfrowanie-luks-przez-ssh-z-poziomu-initramfs-initrd-na-raspberry-pi/</link>
      <pubDate>Fri, 12 Nov 2021 23:13:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/odszyfrowanie-luks-przez-ssh-z-poziomu-initramfs-initrd-na-raspberry-pi/</guid>
      <description>&lt;p&gt;Od paru dni bawię się swoim Raspberry Pi w kontekście zaszyfrowania jego systemu RasPiOS/Raspbian.
O ile samo &lt;a href=&#34;https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/&#34;&gt;zaszyfrowanie tego minikomputera przy pomocy mechanizmu LUKS&lt;/a&gt; nie było jakoś
specjalnie trudne, to trzeba było pomyśleć nad rozwiązaniami mającymi ułatwić otworzenie takiego
zaszyfrowanego kontenera przy starcie systemu. Póki co udało się wypracować w miarę zadowalające
&lt;a href=&#34;https://morfikov.github.io/post/wykorzystanie-nosnika-usb-jako-klucz-do-odszyfrowania-raspberry-pi/&#34;&gt;rozwiązanie wykorzystujące dedykowane urządzenia USB w roli klucza&lt;/a&gt;, bez którego system się nie
uruchomi. Są jednak i inne rozwiązania, które mogą nam pomóc odszyfrować system RPI bez potrzeby
fatygowania się do pomieszczenia i wtykania w jej port USB jakiegoś pendrive. Mowa o zaprzęgnięciu
usługi SSH, która by została uruchomiona w fazie initramfs/initrd, chwilę przed wpisaniem hasła do
kontenera LUKS. Takie rozwiązanie wymaga jednak zainstalowania innego serwera SSH, tj. Dropbear,
pogodzenia go z serwerem OpenSSH oraz też trzeba odpowiednio przygotować sam obraz initramfs/initrd.
Po pomyślnym skonfigurowaniu systemu, będziemy się logować do Raspberry Pi przez SSH i wpisywać
hasło do kontenera LUKS, a jeśli to hasło będzie prawidłowe, to system zostanie odszyfrowany i
uruchomiony.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wykorzystanie nośnika USB jako klucz do odszyfrowania Raspberry Pi (LUKS)</title>
      <link>https://morfikov.github.io/post/wykorzystanie-nosnika-usb-jako-klucz-do-odszyfrowania-raspberry-pi/</link>
      <pubDate>Thu, 11 Nov 2021 05:32:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/wykorzystanie-nosnika-usb-jako-klucz-do-odszyfrowania-raspberry-pi/</guid>
      <description>&lt;p&gt;Ostatnio udało mi się &lt;a href=&#34;https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/&#34;&gt;zaszyfrować swojego Raspberry Pi 4B przez wdrożenie kontenera LUKS&lt;/a&gt; i
upchnięcie w nim wszystkich danych z partycji &lt;code&gt;/&lt;/code&gt; zainstalowanego w tym urządzeniu systemu
RasPiOS/Raspbian. To jednak nie był koniec pracy, bo taki zaszyfrowany system na RPI ma szereg wad.
Tym główniejszym uniedogodnieniem jest wpisywanie hasła na początku fazy boot, by pełny start
systemu był w ogóle możliwy. Sytuacja się komplikuje, gdy do naszego minikomputera nie mamy
podłączonego monitora i/lub klawiatury. Ten zaistniały problem można rozwiązać na kilka sposobów,
np. przez zaprzęgnięcie do pracy dodatkowego nośnika USB w celu umieszczenia na nim pliku klucza
(keyfile). Niemniej jednak, można pójść o krok dalej i wykorzystać samo urządzenie jako klucz i gdy
takiego pendrive nie podłączymy do portu USB naszej maliny, to system nam się nie uruchomi. Te dwa
rozwiązania są bardzo podobne do siebie ale to drugie jest nieco bardziej odporne na ewentualne
problemy ze skasowaniem pliku klucza, co może nam się przytrafić, gdy taki pendrive jest
wykorzystywany w roli regularnego nośnika danych przechowującego dla niepoznaki jakieś pliki. Tak
czy inaczej oba te sposoby zostaną opisane w niniejszym artykule.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zaszyfrować Raspberry Pi (RasPiOS/Raspbian, LUKS)</title>
      <link>https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/</link>
      <pubDate>Sun, 07 Nov 2021 22:17:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/</guid>
      <description>&lt;p&gt;Ostatnio napisał do mnie pewien osobnik, który miał dość spory problem z zaszyfrowaniem swojego
Raspberry Pi. Po wymianie kilku maili zacząłem tracić rozeznanie w całej tej sytuacji i doszedłem
do wniosku, że najwyraźniej zaszyfrowanie systemu maliny nie jest rzeczą trywialną. Postanowiłem
zatem rzucić okiem na swojego RPI i sprawdzić czy są tutaj faktycznie jakieś odstępstwa od
tradycyjnego szyfrowania na bazie LUKS w stosunku do szyfrowania spotykanego w pierwszej lepszej
dystrybucji linux&#39;a, takiej jak Debian czy Ubuntu. Pobrałem więc ze strony Raspberry Pi najnowszy
obraz systemu RasPiOS/Raspbian, wrzuciłem go na kartę SD przy pomocy &lt;code&gt;dd&lt;/code&gt; i okazało się, że w
zasadzie większych problemów z zaszyfrowaniem mojej maliny nie było. Przyznać trzeba, że informacje
na temat szyfrowania RPI, które można spotkać na internetach, są w przeważającej większości bardzo
słabej jakości i mam wrażenie, że pisane przez osoby, które nie do końca się zainteresowały
poruszanym przez siebie zagadnieniem. Postanowiłem zatem na przykładzie mojego Raspberry Pi 4B
opisać w miarę dokładny sposób od początku do końca jak przeprowadzić cały ten proces szyfrowania
danych na karcie SD, którą podpinamy do naszego minikomputera.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Chroot do 32-bit systemu ARM z poziomu 64-bit linux&#39;owego hosta</title>
      <link>https://morfikov.github.io/post/chroot-do-32-bit-systemu-arm-z-poziomu-64-bit-linuxowego-hosta/</link>
      <pubDate>Sun, 07 Nov 2021 10:20:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/chroot-do-32-bit-systemu-arm-z-poziomu-64-bit-linuxowego-hosta/</guid>
      <description>&lt;p&gt;Eksperymentując ostatnio z moją maszynką Raspberry Pi 4B, zaszła potrzeba, by zejść do systemu
RasPiOS/Raspbian przy pomocy mechanizmu chroot. Problem w tym, że system wyrzuca  komunikat:
&lt;code&gt;chroot: failed to run command ‘/bin/bash’: Exec format error&lt;/code&gt; . Niby wszystko jest na swoim
miejscu ale ta widoczna wyżej wiadomość nie chce zniknąć uniemożliwiając tym samym dalszą zabawę z
RPI. Okazało się, że winna jest tutaj architektura CPU. Mój laptop działa pod kontrolą 64-bitowego
Intel&#39;owskiego procesora (x64, x86-64, AMD64), na którym uruchomiony jest również 64-bitowy Debian
linux. Z kolei Raspberry Pi ma 64-bitowy procesor ARM (ARMv8-A) działający pod kontrolą 32-bitowego
systemu operacyjnego. Te dość spore rozbieżności sprawiają, że nie damy rady skorzystać z chroot,
przynajmniej nie bez zaprzęgnięcia do tego celu emulatora QEMU.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Drukowanie zeskanowanych dokumentów tekstowych na drukarce laserowej</title>
      <link>https://morfikov.github.io/post/drukowanie-zeskanowanych-dokumentow-tekstowych-na-drukarce-laserowej/</link>
      <pubDate>Tue, 26 Oct 2021 19:57:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/drukowanie-zeskanowanych-dokumentow-tekstowych-na-drukarce-laserowej/</guid>
      <description>&lt;p&gt;Posiadacze monochromatycznych (czarnobiałych) drukarek laserowych zapewne spotkali się z problemem
drukowania kolorowych dokumentów na tego typu urządzeniach. Nie chodzi tutaj o drukowanie obrazków
czy innych elementów graficznych ale o wydrukowanie, np. zeskanowanej książki. Ostatnio przyszło mi
wydrukować dokumentację techniczną dość starego urządzenia. Problem w tym, że nie był to zwykły
kawałek książki, a jedynie jej skany, z których ktoś postanowił zrobić plik PDF . Takiego
dokumentu &amp;quot;tekstowego&amp;quot; za bardzo nie da się wydrukować na drukarce laserowej, przynajmniej nie bez
pchania się w ogromne koszty. Dla przykładu, w miejsce pożółkniętej kartki ze skanu, taka drukarka
wstawi jakiś odcień szarości i w ten sposób zadrukuje tą szarością całą stronę marnując przy tym
niesamowite ilości toneru, za który my będziemy musieli później zapłacić, co czyni cały proces
drukowania zeskanowanych dokumentów bardzo kosztownym. Postanowiłem jednak znaleźć jakiś sposób, by
tę dokumentację wydrukować, choć trzeba było pierw zająć się samymi skanami, tj. doprowadzić je do
stanu, w którym można by mówić o ewentualnym ich wydrukowaniu. Okazało się, że nie jest to jakoś
specjalnie trudne zadanie, zwłaszcza, gdy na linux zaprzęgnie się do tego celu ImageMagick.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
