<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bezpieczeństwo on Morfitronik</title>
    <link>https://morfikov.github.io/tags/bezpiecze%C5%84stwo/</link>
    <description>Recent content in bezpieczeństwo on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Fri, 13 Dec 2019 19:26:14 +0000</lastBuildDate>
    
	<atom:link href="https://morfikov.github.io/tags/bezpiecze%C5%84stwo/feed.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>Jak zweryfikować plik APK aplikacji na Androida</title>
      <link>https://morfikov.github.io/post/jak-zweryfikowac-plik-apk-aplikacji-na-androida/</link>
      <pubDate>Fri, 13 Dec 2019 19:26:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zweryfikowac-plik-apk-aplikacji-na-androida/</guid>
      <description>&lt;p&gt;Część użytkowników smartfonów z Androidem na pokładzie żyje w głębokim przekonaniu, że instalowanie
aplikacji spoza sklepu Google Play nie jest zbyt rozważnym posunięciem. Nie chodzi tutaj tylko o
szeroko rozumiane alternatywne źródła aplikacji, np. serwis apkmirror ale również o Yalp/Aurora
Store czy też repozytoria F-Droid. Zdaniem tych osób pobieranie aplikacji z zewnętrznych źródeł
może skompromitować bezpieczeństwo systemu oraz zagrozić naszej prywatności. No jakby nie patrzeć
wgrywanie czegokolwiek bez zastanowienia się co tak naprawdę instalujemy w systemie nie jest zbyt
mądre. Dlaczego zatem nie weryfikujemy aplikacji obecnych w oficjalnym sklepie Google? Co chwila
przecież można usłyszeć w mediach o syfie, który udało się co prawda z tego sklepu usunąć ale też
jakaś większa liczba użytkowników taką aplikację zdążyła już zainstalować i używała jej przez
dłuższy lub krótszy okres czasu. Rozumowanie na zasadzie, że aplikacje ze sklepu Google Play są
bezpieczne, bo są obecne w sklepie Google Play, daje nam jedynie fałszywe poczucie bezpieczeństwa,
które jest gorsze od całkowitego braku bezpieczeństwa, bo w tym drugim przypadku człowiek
przynajmniej jest świadom czyhających na niego niebezpieczeństw i włącza myślenie. Jak zatem
odróżnić aplikacje, które są w stanie nam wyrządzić krzywdę od tych, które tego nie mają na celu i
czy faktycznie pobieranie aplikacji na Androida z innego źródła niż oficjalny sklep Google Play
jest takie niebezpieczne?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ograniczenie su do jednego użytkownika w Debianie</title>
      <link>https://morfikov.github.io/post/ograniczanie-su-do-jednego-uzytkownika-w-debianie/</link>
      <pubDate>Fri, 12 Apr 2019 19:40:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ograniczanie-su-do-jednego-uzytkownika-w-debianie/</guid>
      <description>&lt;p&gt;W dzisiejszych czasach dystrybucje linux&#39;a wykorzystują mechanizm &lt;code&gt;sudo&lt;/code&gt; do wykonywania operacji
jako administrator systemu. Zanika więc potrzeba stosowania polecenia &lt;code&gt;su&lt;/code&gt; , by zalogować się na
konto root i to z jego poziomu wykonywać wszystkie niezbędne rzeczy. Jednym z argumentów
zwolenników &lt;code&gt;sudo&lt;/code&gt; za takim sanem rzeczy jest możliwość nadania jedynie konkretnym użytkownikom w
systemie uprawnień do wykonywania poleceń jako administrator, podczas gdy inni użytkownicy
(niebędący w grupie &lt;code&gt;sudo&lt;/code&gt; ) nie mogą w ogóle korzystać z tego mechanizmu . No faktycznie, dostęp
do &lt;code&gt;su&lt;/code&gt; jest w zasadzie dla każdego użytkownika w systemie i tylko hasło konta admina dzieli ich od
uzyskania dość szerokich uprawnień. Niewiele jednak osób wie, że można skonfigurować &lt;code&gt;su&lt;/code&gt; w taki
sposób, by dostęp do niego mieli tylko ci
użytkownicy, &lt;a href=&#34;https://wiki.debian.org/WHEEL/PAM&#34;&gt;którzy powinni&lt;/a&gt;, np. ci obecni w grupie &lt;code&gt;wheel&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Factory Reset Protection (FRP) w smartfonach z Androidem</title>
      <link>https://morfikov.github.io/post/factory-reset-protection-frp-w-smartfonach-z-androidem/</link>
      <pubDate>Fri, 20 Jan 2017 18:37:11 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/factory-reset-protection-frp-w-smartfonach-z-androidem/</guid>
      <description>&lt;p&gt;Kupowanie telefonów czy smartfonów z Androidem z innych źródeł niż oficjalne punkty sprzedaży nie
zawsze jest bezpieczną opcją. Gdy nabywamy takie urządzenie od znajomego, to raczej nie powinniśmy
się martwić o to, że ten telefon może być kradziony. Niemniej jednak, po zakupie takiego urządzenia,
poprzedni użytkownik zwykle resetuje jego ustawienia do fabrycznych, by klient miał świeży system i
nie był w stanie uzyskać dostępu do prywatnych danych poprzedniego właściciela smartfona. Nie byłoby
w tym nic nadzwyczajnego, gdyby nie fakt, że nabywca tak odsprzedanego telefonu może mieć pewne
problemy ze skonfigurowaniem Androida, bo ten system zwróci mu komunikat: &amp;quot;Urządzenie zostało
zresetowane. Aby kontynuować, zaloguj się na konto Google, które było wcześniej synchronizowane na
tym urządzeniu&amp;quot;, czyli telefon został zablokowany przez mechanizm Factory Reset Protection Lock (FRP
Lock). Jeśli znajomy mieszka blisko nas, to naturalnie możemy się przejść do niego w celu zdjęcia
tej blokady. A co w przypadku, gdy nabyliśmy urządzenie na odległość? Czy jest jakiś sposób na
obejście tej blokady w przypadku smartfonów Neffos od TP-LINK?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Apache2: Konfiguracja OCSP Stapling</title>
      <link>https://morfikov.github.io/post/apache2-konfiguracja-ocsp-stapling/</link>
      <pubDate>Sat, 06 Aug 2016 19:16:09 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-konfiguracja-ocsp-stapling/</guid>
      <description>&lt;p&gt;Serwery udostępniające nam różnego rodzaju strony www na protokole SSL/TLS posiadają certyfikaty,
które są ważne przez pewien okres czasu. Z reguły jest to rok albo, jak w przypadku
&lt;a href=&#34;https://morfikov.github.io
/post/certyfikat-letsencrypt-dla-bloga-certbot/&#34;&gt;letsencrypt&lt;/a&gt;, są to 3 miesiące.
Taki certyfikat może zostać unieważniony z różnych przyczyn ale informacja o tym fakcie musi trafić
do wszystkich klientów odwiedzających taki serwis www. Do tego celu mogą posłużyć dwa mechanizmy.
Pierwszym z nich są listy &lt;a href=&#34;https://pl.wikipedia.org/wiki/Lista_uniewa%C5%BCnionych_certyfikat%C3%B3w&#34;&gt;Certificate Revocation
Lists&lt;/a&gt; (CRL). Drugim zaś
jest &lt;a href=&#34;https://pl.wikipedia.org/wiki/Online_Certificate_Status_Protocol&#34;&gt;Online Certificate Status
Protocol&lt;/a&gt; (OCSP). W tym wpisie
postaramy się zaimplementować to drugie rozwiązanie na serwerze Apache2.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>HTTP Strict Transport Security (HSTS) w Apache2</title>
      <link>https://morfikov.github.io/post/http-strict-transport-security-hsts-apache2/</link>
      <pubDate>Tue, 19 Jul 2016 19:08:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/http-strict-transport-security-hsts-apache2/</guid>
      <description>&lt;p&gt;Ostatnio na niebezpieczniku czytałem &lt;a href=&#34;https://niebezpiecznik.pl/post/podroze-kosztuja/&#34;&gt;taki oto
post&lt;/a&gt;. Historia jak historia, nieco długa ale
mniej więcej w połowie pojawiła się informacja na temat nagłówków HSTS (&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security&#34;&gt;HTTP Strict Transport
Security&lt;/a&gt;), który jest przesyłany w
zapytaniach HTTP/HTTPS. Postanowiłem nieco się zainteresować tym tematem i zbadać czym są te
nagłówki HSTS i w jaki sposób są one w stanie poprawić bezpieczeństwo protokołów SSL/TLS
wykorzystywanych podczas szyfrowania zawartości stron internetowych.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>nf_conntrack: automatic helper assignment is deprecated</title>
      <link>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</link>
      <pubDate>Sat, 16 Jul 2016 18:59:19 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</guid>
      <description>&lt;p&gt;Jeśli ktoś uważnie śledzi logi systemowe, to od czasu do czasu można w nich znaleźć komunikat,
którzy brzmi mniej więcej tak: &lt;code&gt;nf_conntrack: automatic helper assignment is deprecated and it will be removed soon. Use the iptables CT target to attach helpers instead&lt;/code&gt; . Ta wiadomość odnosi się do
jednego z modułów linux&#39;owego filtra pakietów &lt;code&gt;iptables&lt;/code&gt; . Moduł, o którym mowa to &lt;code&gt;nf_conntrack&lt;/code&gt; ,
który odpowiada za śledzenie połączeń nawiązywanych przez system. Sam komunikat zaś dotyczy
mechanizmów pomocniczych, których sposób aktywacji jest już nieco przestarzały i zostanie wkrótce
usunięty. Co to oznacza dla przeciętnego użytkownika linux&#39;a i czym są w istocie te mechanizmy
pomocnicze, które znajdują zastosowane na zaporze sieciowej?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Konfiguracja DMZ w OpenWRT</title>
      <link>https://morfikov.github.io/post/konfiguracja-dmz-openwrt/</link>
      <pubDate>Tue, 05 Jul 2016 18:05:31 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-dmz-openwrt/</guid>
      <description>&lt;p&gt;Strefa zdemilitaryzowana (&lt;a href=&#34;https://pl.wikipedia.org/wiki/Strefa_zdemilitaryzowana_(informatyka)&#34;&gt;DMZ, demilitarized
zone&lt;/a&gt;) to taki mechanizm,
który ma na celu poprawę bezpieczeństwa usług w sieci lokalnej. Generalnie chodzi o podział sieci
na kilka mniejszych podsieci i oddzielenie ich od siebie fizycznie lub logicznie. &lt;a href=&#34;https://wiki.openwrt.org/doc/howto/dmz&#34;&gt;W OpenWRT możemy
wydzielić taką strefę DMZ przy pomocy VLAN&#39;ów&lt;/a&gt;. Z kolei
odpowiednio skonfigurowany firewall odseparuje nam tę strefę od pozostałych maszyn pracujących w
sieci LAN. W taki sposób nawet w przypadku włamania mającego miejsce w strefie DMZ, maszyny w
pozostałych segmentach sieci będą bezpieczne. W tym wpisie postaramy się skonfigurować strefę
zdemilitaryzowaną na routerze wyposażonym w firmware OpenWRT.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jak wyczyścić tablicę conntrack&#39;a w debianie</title>
      <link>https://morfikov.github.io/post/jak-wyczyscic-tablice-conntrack-w-debianie/</link>
      <pubDate>Sun, 05 Jun 2016 12:34:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wyczyscic-tablice-conntrack-w-debianie/</guid>
      <description>&lt;p&gt;Sporo użytkowników lunux&#39;a, zwłaszcza dystrybucji debian, korzysta z własnych skryptów firewall&#39;a
aplikujących reguły &lt;code&gt;iptables&lt;/code&gt; . Tego typu rozwiązanie ma jednak swoje wady i zalety. Niewątpliwie
do zalet można zaliczyć brak dodatkowego oprogramowania obsługującego zaporę sieciową. Jeśli chodzi
zaś o wady, to niestety cały skrypt trzeba sobie dobrze przemyśleć przed zaaplikowaniem. Ludzie
często zapominają tutaj o śledzeniu połączeń przez kernel. To właśnie na podstawie wpisów w
&lt;code&gt;/proc/net/ip_conntrack&lt;/code&gt; lub &lt;code&gt;/proc/net/nf_conntrack&lt;/code&gt; system wie, które pakiety należy na zaporze
przepuścić, a które zablokować. Jeśli teraz dodajemy reguły do filtra &lt;code&gt;iptables&lt;/code&gt; , to nowa polityka
zapory nie będzie odnosić się do tych nawiązanych już połączeń, które są określone w tablicy
conntrack&#39;a. By się upewnić, że tego typu scenariusz nigdy nas nie spotka, musimy tę tablicę
opróżnić.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Rkhunter jako ochrona przed rootkit&#39;ami</title>
      <link>https://morfikov.github.io/post/rkhunter-jako-ochrona-przed-rootkitami/</link>
      <pubDate>Tue, 08 Mar 2016 15:42:59 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/rkhunter-jako-ochrona-przed-rootkitami/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Rootkit&#34;&gt;Rootkit&lt;/a&gt; to takie ustrojstwo, które jest w stanie przebywać
niepostrzeżenie w naszym systemie przez bardzo długi czas. Dzieje się tak ze względu na uśpioną
czujność administratora. Teoretycznie wszystko jest w należytym porządku, nie widać żadnych
złowrogich procesów, a szereg narzędzi, które mają przeciwdziałać rootkit&#39;om, nie zwraca żadnych
ostrzeżeń o ewentualnych próbach naruszenia bezpieczeństwa systemu operacyjnego. Taki rootkit jest w
stanie całkowicie przejąc kontrolę nad linux&#39;em i np. może decydować o tym jakie procesy zostaną nam
pokazane, a jakie ukryte. W świetle takiego zagrożenia, linux&#39;y wypracowały sobie pewne mechanizmy
obronne. W tym wpisie przebadamy sobie jeden z projektów, tj.
&lt;a href=&#34;http://rkhunter.sourceforge.net/&#34;&gt;rkhunter&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Ukrywanie informacji w plikach (steganografia)</title>
      <link>https://morfikov.github.io/post/ukrywanie-informacji-w-plikach-steganografia/</link>
      <pubDate>Thu, 21 Jan 2016 21:49:23 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ukrywanie-informacji-w-plikach-steganografia/</guid>
      <description>&lt;p&gt;Jak możemy wyczytać na wikipedii, &lt;a href=&#34;https://pl.wikipedia.org/wiki/Steganografia&#34;&gt;steganografia&lt;/a&gt; to
nauka, która ma na celu ukrycie faktu prowadzenia komunikacji. Odróżnia ją to nieco od kryptografii,
gdzie wiadomość jest wprawdzie nieczytelna ale wiadome jest, że dokonywana jest wymiana informacji
między dwoma punktami. W przypadku steganografii możemy ukryć pewną informację, np. w pliku
graficznym maskując tym samym cały proces przekazywania danych. W taki sposób osoba, która nie ma
pojęcia o fakcie ukrycia informacji, zobaczymy jedynie zwykły obrazek. Poniższy wpis ma na celu
sprawdzenie jak skuteczna jest ta metoda i czy nadaje się do zastosowania dla przeciętnego zjadacza
chleba.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nagłówek kontenera LUKS trzymany na pendrive</title>
      <link>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</link>
      <pubDate>Fri, 15 Jan 2016 20:28:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</guid>
      <description>&lt;p&gt;Jeśli kiedyś rozważaliśmy &lt;a href=&#34;https://morfikov.github.io
/post/keyfile-trzymany-w-glebokim-ukryciu/&#34;&gt;umieszczenie pliku klucza (keyfile) do zaszyfrowanego kontenera LUKS na
pendrive&lt;/a&gt;, to ciekawszą alternatywą
może okazać się umieszczenie całego nagłówka takiego kontenera na zewnętrznym nośniku. Ma to tę
przewagę nad keyfile, że wszystkie informacje zapewniające dostęp do kontenera, wliczając w to klucz
główny, są oddzielone od zaszyfrowanych danych. W ten sposób nawet jeśli kontener wpadnie w
niepowołane ręce, to nie ma żadnego sposobu na to, by ten ktoś te dane odzyskał, no bo przecie nie
ma klucza szyfrującego. Przechwycenie hasła również nic to nie zmieni, no chyba, że ten ktoś
zdobędzie również pendrive z nagłówkiem kontenera. Z ludzkiego punktu widzenia, to na takim dysku
będą znajdować się jedynie losowymi dane i do tego w formie kompletnie nieczytelnej dla człowieka
(brak systemu plików). Niemniej jednak, jest kilka rzeczy, o których warto pamiętać, gdy w grę
wchodzi nagłówek LUKS i to o nich porozmawiamy sobie w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Backup systemu przy pomocy LVM snapshot</title>
      <link>https://morfikov.github.io/post/backup-przy-pomocy-lvm-snapshot/</link>
      <pubDate>Fri, 15 Jan 2016 14:09:15 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/backup-przy-pomocy-lvm-snapshot/</guid>
      <description>&lt;p&gt;W dzisiejszych czasach systemy operacyjne są bardziej odporne na błędy niż to miało miejsce kilka
czy kilkanaście lat temu. Bardzo ciężko jest się zatem odnaleźć w sytuacji, gdzie nasz linux odmawia
współpracy i nie chce się w ogóle uruchomić. Niemniej jednak, jeśli chodzi o samą kwestię
naprawiania szkód po ewentualnej awarii systemu, to, jakby nie patrzeć, zajmuje ona nasz cenny czas.
Oczywiście takie błędy sprawiają, że mamy szansę nieco zgłębić strukturę używanego systemu
operacyjnego ale też pojawiają się w najmniej oczekiwanym momencie. W takiej sytuacji nie ma mowy
byśmy siedzieli paręnaście minut i zastanawiali się nad tym dlaczego coś nie działa jak należy.
Jest kilka mechanizmów bezpieczeństwa, które mogą nam nieco czasu zaoszczędzić. W tym wpisie omówimy
sobie zagadnienia związane z &lt;a href=&#34;http://www.tldp.org/HOWTO/html_single/LVM-HOWTO/#snapshotintro&#34;&gt;LVM
snapshot&lt;/a&gt;, czyli migawką systemu,
którą możemy wykonać praktycznie natychmiast i w razie problemów przywrócić.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Odszyfrowanie kontenerów LUKS w systemd</title>
      <link>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</link>
      <pubDate>Fri, 01 Jan 2016 17:18:03 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</guid>
      <description>&lt;p&gt;Osoby, które wykorzystują pełne szyfrowanie dysku, wiedzą, że nie zawsze da radę tak skonfigurować
swój system, by upchnąć go na jednej partycji. Nawet jeśli korzystamy z LVM wewnątrz kontenera LUKS,
to i tak zwykle możemy posiadać inne zaszyfrowane partycje, które są odrębną całością i montowane
osobno przy starcie systemu. W takim przypadku zwykle jesteśmy zmuszeni do podawania hasła do
każdego z tych dysków z osobna, co zajmuje czas. Ten problem opisałem po części przy okazji
&lt;a href=&#34;https://morfikov.github.io
/post/dropbox-i-kontener-luks/&#34;&gt;implementacji kontenera LUKS na potrzeby
Dropbox&#39;a&lt;/a&gt;, jak i we wpisie poświęconym &lt;a href=&#34;https://morfikov.github.io
/post/przejscie-z-truecrypt-na-luks/&#34;&gt;przejściu
z kontenerów TrueCrypt&#39;a na te linux&#39;owe, które są wspierane natywnie przez sam
kernel&lt;/a&gt;. Niemniej jednak, tamto rozwiązanie
było oparte głównie o starszy init (sysvinit), co wymagało dodatkowej konfiguracji, tak by system
otworzył się po podaniu tylko jednego hasła. W tym wpisie postaramy się wdrożyć mechanizm, który
jest oferowany przez systemd.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Profil AppArmor&#39;a i jego dokładna budowa</title>
      <link>https://morfikov.github.io/post/profil-apparmora-i-jego-dokladna-budowa/</link>
      <pubDate>Tue, 01 Dec 2015 17:57:39 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/profil-apparmora-i-jego-dokladna-budowa/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io
/post/apparmor-profilowanie-aplikacji/&#34;&gt;Budowanie samych profili dla AppArmor&#39;a&lt;/a&gt;
nie jest jakoś szczególnie trudne, zwłaszcza, gdy do tego celu wykorzystujemy narzędzia dostępne w
pakiecie &lt;code&gt;apparmor-utils&lt;/code&gt; . Dobrze jest jednak prześledzić sobie
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/xenial/en/man5/apparmor.d.5.html&#34;&gt;manual&lt;/a&gt;
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/xenial/en/man7/apparmor.7.html&#34;&gt;AppArmor&#39;a&lt;/a&gt; oraz to, co twórcy
piszą na swojej stronie w &lt;a href=&#34;http://wiki.apparmor.net/index.php/Documentation&#34;&gt;oficjalnej
dokumentacji&lt;/a&gt; projektu. Poniższy wpis powstał w
celu zrozumienia składni profili AppArmor&#39;a, tak by jeszcze bardziej uprościć proces ich budowania.&lt;/p&gt;
&lt;p&gt;Opis składni znajdujący się poniżej został zaczerpnięty z
&lt;a href=&#34;http://wiki.apparmor.net/index.php/QuickProfileLanguage&#34;&gt;wiki&lt;/a&gt;
&lt;a href=&#34;http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference&#34;&gt;AppArmor&#39;a&lt;/a&gt;. Część z poniższych
informacji może nie mieć zastosowania w przypadku starszych wersji samego AppArmor&#39;a.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Programowe i sprzętowe zerowanie dysku</title>
      <link>https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/</link>
      <pubDate>Tue, 24 Nov 2015 17:54:17 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/</guid>
      <description>&lt;p&gt;Zerowanie dysku twardego ma na celu usunięcie wszystkich znajdujących się na nim danych. Generalnie
chodzi o zapisanie całej powierzchni danego nośnika samymi zerami. Ten proces różni się znacząco of
formatowania dysku, czyli utworzenia nowego systemu plików, gdzie praktycznie wszystkie dane można
bez większego problemu odzyskać. Zerowanie dysku (czy też pendrive) może w pewnych przypadkach
&lt;a href=&#34;https://morfikov.github.io
/post/uszkodzony-sektor-na-dysku-i-jego-realokoacja/&#34;&gt;naprawić logiczne błędy
sektorów&lt;/a&gt; na dysku. Niemniej
jednak, nie usuniemy za jego pomocą fizycznych bad&#39;ów. Generalnie rzecz biorąc, mamy do wyboru dwie
techniki zerowania. Jedna jest dokonywana na poziomie programowym, np. przy pomocy &lt;code&gt;dd&lt;/code&gt; , druga zaś
na poziomie sprzętowym, np. w &lt;code&gt;hdparm&lt;/code&gt; . W tym wpisie postaramy się wyzerować przykładowy dysk.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Integralność plików passwd, group, shadow, gshadow</title>
      <link>https://morfikov.github.io/post/integralnosc-plikow-passwd-group-shadow-gshadow/</link>
      <pubDate>Tue, 24 Nov 2015 12:30:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/integralnosc-plikow-passwd-group-shadow-gshadow/</guid>
      <description>&lt;p&gt;W pliku &lt;code&gt;/etc/passwd&lt;/code&gt; jest przechowywana baza danych kont użytkowników w systemie linux. Z kolei w
&lt;code&gt;/etc/group&lt;/code&gt; mamy wypisane wszystkie grupy oraz powiązanych z nimi użytkowników. Generalnie rzecz
biorąc, to te dwa pliki odpowiadają za konfigurację kont. Problem jednak zaczyna się w momencie gdy
w grę wchodzą hasła, zarówno do kont jak i do grup. Gdyby były one trzymane w tych plikach, nie
byłyby one w żaden sposób szyfrowane. Dlatego też powstał inny mechanizm, który ma na celu
przeniesienie zahashowanych haseł do plików &lt;code&gt;/etc/shadow&lt;/code&gt; i &lt;code&gt;/etc/gshadow&lt;/code&gt; . W debianie
użytkownikami i grupami możemy zarządzać przy pomocy odpowiednich narzędzi, które automatycznie
dostosują wszystkie powyższe pliki. Nic jednak nie stoi na przeszkodzie aby edytować każdy z nich
ręcznie. Problemy mogą się pojawić w momencie, gdy te pliki będą zawierać różne wpisy, np. w pliku
&lt;code&gt;passwd&lt;/code&gt; będzie określony użytkownik, który jednocześnie nie będzie istniał w pliku &lt;code&gt;shadow&lt;/code&gt; ,
podobnie z grupami. W tym wpisie postaramy się sprawdzić te pliki i upewnimy się czy aby na pewno
jest z nimi wszystko w porządku.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Czy zmiana nazwy użytkownika root ma sens?</title>
      <link>https://morfikov.github.io/post/czy-zmiana-nazwy-uzytkownika-root-ma-sens/</link>
      <pubDate>Sat, 21 Nov 2015 19:52:58 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-zmiana-nazwy-uzytkownika-root-ma-sens/</guid>
      <description>&lt;p&gt;Wielu ludzi potrafi się rozpisywać na temat bezpieczeństwa systemu linux jednocześnie nie zauważając
jednego bardzo poważnego problemu. Wszyscy wiemy, że linux&#39;y są bezpieczne min. przez fakt
rozgraniczenia konta administratora od konta zwykłego użytkownika i nadaniu im różnych praw dostępu
do poszczególnych części systemu operacyjnego. O ile konta użytkowników mają różne nazwy, o tyle
administrator w praktycznie każdym linux&#39;ie kryje się pod nazwą &lt;code&gt;root&lt;/code&gt; . Znając nazwę konta, można
próbować złamać hasło. To trochę dziwne, że nie można sobie arbitralnie ustalić nazwy dla tego konta
tak by uniknąć wszelkich ataków, które związane są z logowaniem się na określonego użytkownika w
systemie. W tym wpisie postaramy się prześledzić całą procedurę zmiany nazwy konta &lt;code&gt;root&lt;/code&gt; na jakąś
dowolną i zobaczymy czy wpłynie to w jakimś stopniu na pracę naszego systemu.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Uprawnienia do plików systemowych w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/uprawnienia-do-plikow-systemowych-w-linuxie/</link>
      <pubDate>Mon, 16 Nov 2015 12:34:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/uprawnienia-do-plikow-systemowych-w-linuxie/</guid>
      <description>&lt;p&gt;Każdy z nas popełnia błędy. Niektóre z nich są błahe i w sporej części łatwe do poprawienia. Zwykle
też nie niosą one ze sobą większych konsekwencji. Natomiast błędy, które popełniamy podczas pracy w
systemie operacyjnym wykonując różne prace administracyjne mogą nas czasem słono kosztować. W
linux&#39;ach ogromną rolę odgrywają prawa do plików. O ile root ma dostęp do wszystkich plików, to w
przypadku zwykłych użytkowników (czy tez usług systemowych) już tak nie jest. Przypadkowa zmiana
tych uprawnień może zaowocować problemami związanymi z bezpieczeństwem takiego systemu, a w
niektórych przypadkach może nawet uniemożliwić jego start. Na necie kilka razy obił mi się o oczy
temat, gdzie ludzie przez przypadek (lub też &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=27876&#34;&gt;całkiem
świadomie&lt;/a&gt;) zmienili masowo uprawnienia w takich
katalogach jak &lt;code&gt;/usr/&lt;/code&gt; czy &lt;code&gt;/etc/&lt;/code&gt; . Powiem nawet więcej, mi się raz taka sytuacja kiedyś
przytrafiła. Co w takim przypadku można zrobić? Czy jedyną opcją, jaka nam pozostaje, to ponowna
instalacja sytemu? Na szczęście nie, bo uprawnienia do plików możemy sobie zwyczajnie spisać i
odtworzyć je w późniejszym czasie.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kiedy uruchomiony proces wymaga restartu</title>
      <link>https://morfikov.github.io/post/kiedy-uruchomiony-proces-wymaga-restartu/</link>
      <pubDate>Fri, 13 Nov 2015 14:22:21 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kiedy-uruchomiony-proces-wymaga-restartu/</guid>
      <description>&lt;p&gt;Linux słynie z tego, że nie są wymagane w nim częste restarty całego systemu operacyjnego. Nie ma
przy tym znaczenia czy aktualizujemy jakieś oprogramowanie, czy też wgrywamy nową wersję kernela.
Jeśli by to przenieść na środowisko windowsa, to tam system jest w stanie się automatycznie
zresetować kilka razy tylko podczas samego procesu aktualizacji. Można zatem kwestionować zasadność
twierdzenia, że linux nie wymaga restartu. Może nie koniecznie jesteśmy zmuszeni do dokonania
restartu w danej chwili, tak jak to ma miejsce w przypadku windowsa, ale czy aby na pewno po
instalacji jakichś pakietów w systemie, każdy proces powinien w dalszym ciągu działać bez restartu?
Na to pytanie postaramy się odpowiedzieć w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Fwknop z obsługą kuczy GPG</title>
      <link>https://morfikov.github.io/post/fwknop-z-obsluga-kuczy-gpg/</link>
      <pubDate>Thu, 05 Nov 2015 20:52:20 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/fwknop-z-obsluga-kuczy-gpg/</guid>
      <description>&lt;p&gt;Ostatnio opisywałem jak zaimplementować na swoim serwerze &lt;a href=&#34;https://morfikov.github.io
/post/port-knocking-i-single-packet-authorization/&#34;&gt;mechanizm port
knocking&#39;u&lt;/a&gt; , który oparty był
o &lt;a href=&#34;http://www.cipherdyne.org/fwknop/docs/fwknop-tutorial.html&#34;&gt;Single Packet Authorization&lt;/a&gt;. Tamten
wpis dotyczył głównie wykorzystania szyfrów symetrycznych ale istnieje też możliwość skorzystania z
kluczy GPG. W ten sposób uwierzytelnianie oraz szyfrowanie pakietów odbywałoby się przy ich pomocy.
W tym wpisie postaramy się tak skonfigurować narzędzie &lt;code&gt;fwknop&lt;/code&gt; , tak by było ono w stanie
przepuszczać jedynie tych klientów, którzy posługują się kluczami GPG.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Moduł xt_recent i limitowanie połączeń w iptables</title>
      <link>https://morfikov.github.io/post/modul-xt_recent-i-limitowanie-polaczen-w-iptables/</link>
      <pubDate>Thu, 05 Nov 2015 17:17:16 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/modul-xt_recent-i-limitowanie-polaczen-w-iptables/</guid>
      <description>&lt;p&gt;Kluczową rolę w filtrze iptables pełnią stany połączeń. Zwykle mamy do czynienia z trzema z nich:
NEW, RELATED i ESTABLISHED. Wszystko co nie pasuje do tych stanów, jest traktowane jako INVALID i
tak dla przykładu trafiają tam pakiety mające niemożliwe kombinacje flag, przynajmniej jeśli chodzi
o punkt widzenia poprawnej komunikacji sieciowej (ustawione flagi &lt;code&gt;SYN&lt;/code&gt; i &lt;code&gt;FIN&lt;/code&gt; jednocześnie).
Jednak istnieje szereg pakietów, które mogą potencjalnie zagrażać bezpieczeństwu maszyny i nie są
one uwzględnione w stanie INVALID. Takie pakiety są używane do skanowania portów w celu wykrycia
usług znajdujących się na serwerze. Krótko mówiąc, stan INVALID nie złapie skanów &lt;code&gt;UDP&lt;/code&gt;, &lt;code&gt;ACK&lt;/code&gt; oraz
&lt;code&gt;SYN&lt;/code&gt; . Czy jesteśmy faktycznie bezbronni i nic nie możemy zrobić? Na szczęście iptables ma do
dyspozycji &lt;a href=&#34;http://ipset.netfilter.org/iptables-extensions.man.html&#34;&gt;moduł xt_recent&lt;/a&gt;, który jest w
stanie zablokować wszystkie te powyżej wymienione formy ataków.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Port knocking na przykładzie knockd i iptables</title>
      <link>https://morfikov.github.io/post/port-knocking-na-przykladzie-knockd-i-iptables/</link>
      <pubDate>Thu, 05 Nov 2015 00:26:27 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/port-knocking-na-przykladzie-knockd-i-iptables/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Port_knocking&#34;&gt;Port knocking&lt;/a&gt; zezwala na zdalny dostęp do usług,
które są chronione za pomocą zapory sieciowej. Generalnie rzecz biorąc, iptables ma blokować
jakikolwiek ruch na porcie, na którym nasłuchuje jakaś demon. Oczywiście tym sposobem żaden klient
nie mógłby nawiązać połączenia z serwerem i tutaj właśnie znajduje zastosowanie &lt;code&gt;knockd&lt;/code&gt; , który
jest w stanie dodawać dynamicznie odpowiednie reguły do filtra iptables. Nawiązywanie połączenia
trwa z reguły bardzo szybko. Po tym jak klient uzyskał dostęp do serwera, te dodane wcześniej reguły
są usuwane blokując tym samym wszelkie nowe próby połączenia ale nie odcinając jednocześnie
ustanowionych już połączeń. Ten wpis ma jedynie na celu zaprezentowanie narzędzia &lt;code&gt;knockd&lt;/code&gt; .
Niemniej jednak, jest ono już przestarzałe i powinno się od niego odchodzić na rzecz &lt;a href=&#34;https://morfikov.github.io
/post/port-knocking-i-single-packet-authorization/&#34;&gt;Single Packet
Authorization, czyli alternatywnego port
knocking&#39;u&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pliki hosts.allow i hosts.deny</title>
      <link>https://morfikov.github.io/post/pliki-hosts-allow-i-hosts-deny/</link>
      <pubDate>Wed, 04 Nov 2015 22:36:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/pliki-hosts-allow-i-hosts-deny/</guid>
      <description>&lt;p&gt;Obecnie najpopularniejszym rozwiązaniem pod kątem ograniczania dostępu do usług systemowych jest
zapora sieciowa. Reguły iptables są w tym przypadku wręcz niezastąpione. Jednak poleganie na samych
regułach iptables nie jest zbyt dobrym pomysłem. A to z tego względu, że jeśli &lt;a href=&#34;https://morfikov.github.io
/post/firewall-na-linuxowe-maszyny-klienckie/&#34;&gt;skrypt
firewall&#39;a&lt;/a&gt; z jakiegoś powodu nie
zostanie wywołany przy starcie systemu, to nasza maszyna pozostaje praktycznie bezbronna i będzie
akceptować wszelkie próby połączeń do wszystkich nasłuchujących w takim systemie usług. Na szczęście
nie jest znowu aż tak źle jak mogłoby się wydawać. Albowiem linux posiada dwa pliki
&lt;code&gt;/etc/hosts.allow&lt;/code&gt; i &lt;code&gt;/etc/hosts.deny&lt;/code&gt; , które są w stanie zarządzać dostępem do usług systemowych.
Poniższy wpis będzie poświęcony właśnie tym dwóm plikom.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Port knocking i Single Packet Authorization</title>
      <link>https://morfikov.github.io/post/port-knocking-i-single-packet-authorization/</link>
      <pubDate>Wed, 04 Nov 2015 21:36:58 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/port-knocking-i-single-packet-authorization/</guid>
      <description>&lt;p&gt;Poniższy wpis ma na celu zaprezentować jak w prosty sposób dozbroić nieco serwer, tak by znajdujące
się na nim usługi były należycie chronione. Zostanie to pokazane na przykładzie SSH, bo chyba każdy
serwer posiada zdalny dostęp przez shell&#39;a i za bardzo nie godzi się by zostawić tę usługę otwartą
na zewnętrzny świat wirtualny bez jakiegokolwiek nadzoru. Postaramy się tutaj wdrożyć &lt;a href=&#34;https://pl.wikipedia.org/wiki/Port_knocking&#34;&gt;port
knocking&lt;/a&gt;, z tym, że nie będziemy wykorzystywać do tego
celu narzędzia &lt;code&gt;knockd&lt;/code&gt; . Skorzystamy za to z
&lt;a href=&#34;http://www.cipherdyne.org/fwknop/docs/fwknop-tutorial.html&#34;&gt;fwknop&lt;/a&gt; , który eliminuje szereg wad
występujących w leciwym już &lt;code&gt;knockd&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Xauth i xhost na straży bezpieczeństwa Xserver&#39;a</title>
      <link>https://morfikov.github.io/post/xauth-i-xhost-na-strazy-bezpieczenstwa-xservera/</link>
      <pubDate>Fri, 30 Oct 2015 23:45:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/xauth-i-xhost-na-strazy-bezpieczenstwa-xservera/</guid>
      <description>&lt;p&gt;Na debianie Xserver domyślnie ma wyłączoną możliwość nasłuchiwania połączeń zdalnych. Chodzi
oczywiście o kwestie bezpieczeństwa, bo przecie nie od dziś wiadomo, że akurat to oprogramowanie
jest dziurawe jak sito i nikt rozsądny nie chciałby instalować go na swoim serwerze. Należałoby
jednak rozgraniczyć wykorzystywanie podatności jakiegoś oprogramowania od możliwości wejścia z nim w
interakcję. Jakby nie patrzeć, sam Xserver posiada co najmniej trzy mechanizmy ochrony, a do tego
dochodzą jeszcze reguły &lt;code&gt;iptables&lt;/code&gt; , czy też pliki &lt;code&gt;/etc/hosts.allow&lt;/code&gt; i &lt;code&gt;/etc/hosts.deny&lt;/code&gt; .
Prawdopodobnie jest ich jeszcze kilka ale te najczęściej wykorzystywane mechanizmy gdy pojawia się
słowo Xserver, to &lt;code&gt;-nolisten tcp&lt;/code&gt; (domyślnie aktywowany), &lt;code&gt;xhost&lt;/code&gt; oraz &lt;code&gt;xauth&lt;/code&gt; . Pierwszy z nich
wyklucza się z pozostałymi i to tym dwóm ostatnim przyjrzymy bliżej w tym wpisie.&lt;/p&gt;
&lt;p&gt;Mechanizmy &lt;code&gt;xhost&lt;/code&gt; oraz &lt;code&gt;xauth&lt;/code&gt; w żaden sposób nie zabezpieczają informacji przesyłanych do
Xserver&#39;a. Wobec czego, całą komunikację można bez problemu podsłuchać. Stwarza to zagrożenie
przechwycenia nie tylko obrazu wyświetlanego na monitorze ale także danych dotyczących myszy i
przyciskanych klawiszy na klawiaturze.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Konfiguracja kontenerów LXC</title>
      <link>https://morfikov.github.io/post/konfiguracja-kontenerow-lxc/</link>
      <pubDate>Thu, 29 Oct 2015 23:27:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-kontenerow-lxc/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://wiki.debian.org/LXC&#34;&gt;Kontenery LXC&lt;/a&gt; mają za zadanie odizolować poszczególne usługi od
pozostałej części systemu. LXC jest podobny nieco do maszyn wirtualnych, np. tych tworzonych przez
VirtualBox. Niemniej jednak, oba mechanizmy różnią się trochę. Zasadnicza różnica między nimi polega
na tym, że LXC wykorzystuje &lt;a href=&#34;https://morfikov.github.io
/post/przygotowanie-srodowiska-chroot-do-pracy/&#34;&gt;środowisko
chroot&lt;/a&gt; , w którym współdzielone
jest jądro operacyjne. Nie trzeba także z góry określać zasobów pod działanie takiego kontenera, tak
jak to ma w przypadku maszyn wirtualnych. Rzućmy zatem okiem jak wygląda konfiguracja takich
kontenerów na linux&#39;ie.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Więcej niż jeden profil w Firefox&#39;ie</title>
      <link>https://morfikov.github.io/post/wiecej-niz-jeden-profil-w-firefoxie/</link>
      <pubDate>Thu, 29 Oct 2015 16:50:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wiecej-niz-jeden-profil-w-firefoxie/</guid>
      <description>&lt;p&gt;Ogromna większość ludzi korzysta z jednego profilu swojej przeglądarki internetowej. Niesie to ze
sobą spore zagrożenie bezpieczeństwa jak i może godzić w naszą prywatność. Jeśli dzielimy z kimś
komputer, to raczej wszyscy domownicy posiadają osobne konta w systemie, a co z tym się wiąże, inny
profil przeglądarki. I na tym zwykle podział się kończy ale przecie to nie wszystko. Profil, jak
sama nazwa wskazuje, jest w stanie dostosować opcje przeglądarki, np. pod kątem pewnych aktywności.
W tym wpisie postaramy się utworzyć kilka profili w Firefox&#39;ie i sprawdzimy korzystanie z nich
będzie odczuwalne w jakiś sposób dla przeciętnego użytkownika internetu.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Konfiguracja wtyczki flash na linux&#39;ie (mms.cfg)</title>
      <link>https://morfikov.github.io/post/konfiguracja-wtyczki-flash-na-linuxie-mms-cfg/</link>
      <pubDate>Wed, 28 Oct 2015 21:21:51 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-wtyczki-flash-na-linuxie-mms-cfg/</guid>
      <description>&lt;p&gt;W obecnych czasach powoli się odchodzi od stosowania technologi flash w przeglądarkach. Na dobra
sprawę, po tym jak google w youtube przesiadł się na html5, to korzystanie z flash player&#39;a nie ma
już większego sensu. Są jednak serwisy, które nie nadążają za zmieniającą się rzeczywistością i w
ich przypadku przejście z flash&#39;a na html5 może jeszcze zająć kilka lat. Zatem nawet jeśli nie
korzystamy z flash&#39;a na co dzień, to i tak większość z nas będzie chciała go mieć w systemie, tak na
wszelki wypadek, by nie być pozbawionym możliwości oglądania materiałów video na tych drugorzędnych
serwisach. Jako, że wtyczka flash jest bardzo dziurawa, przydałoby się ją nieco skonfigurować i w
tym wpisie zostanie przedstawionych szereg opcji, które można umieścić w pliku &lt;code&gt;mms.cfg&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Montowanie katalogu /tmp/ jako tmpfs</title>
      <link>https://morfikov.github.io/post/montowanie-katalogu-tmp-jako-tmpfs/</link>
      <pubDate>Wed, 21 Oct 2015 22:19:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/montowanie-katalogu-tmp-jako-tmpfs/</guid>
      <description>&lt;p&gt;Linux jest w stanie operować na wielu systemach plików, np. ext4, ntfs, fat. Większość z nich odnosi
się do dysków twardych, czy też innych urządzeń przechowujących spore ilości danych. Problem z tego
typu systemami plików jest taki, że operacje na plikach w ich obrębie, jak i same pliki, zostawiają
ślady. Dlatego też jeśli musimy tymczasowo skopiować plik zawierający tajne dane, lub też taki plik
poddać obróbce, nie powinniśmy go umieszczać bezpośrednio na dysku. No chyba, że wykorzystujemy
pełne szyfrowanie. Inną opcją (i o wiele prostszą w implementacji) jest przeznaczenie części
pamięci operacyjnej RAM pod &lt;a href=&#34;https://wiki.archlinux.org/index.php/Tmpfs&#34;&gt;system plików tmpfs&lt;/a&gt; i o
tym będzie ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dropbox i kontener LUKS</title>
      <link>https://morfikov.github.io/post/dropbox-i-kontener-luks/</link>
      <pubDate>Wed, 21 Oct 2015 20:34:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dropbox-i-kontener-luks/</guid>
      <description>&lt;p&gt;Ogarnęliśmy już szyfrowanie plików na dropbox&#39;ie przy pomocy
&lt;a href=&#34;https://morfikov.github.io
/post/implementacja-encfs-na-dropboxie/&#34;&gt;encfs&lt;/a&gt; oraz &lt;a href=&#34;https://morfikov.github.io
/post/kontener-truecrypt-trzymany-na-dropboxie/&#34;&gt;kontenerów
TrueCrypt&lt;/a&gt;. Każda z w/w operacji
drastycznie poprawiła prywatność naszych plików, które przechowujemy w chmurze. Poniższy wpis będzie
w podobnym klimacie, tj. spróbujemy umieścić na dropbox&#39;ie &lt;a href=&#34;https://pl.wikipedia.org/wiki/Linux_Unified_Key_Setup&#34;&gt;kontener
LUKS&lt;/a&gt;, co niesie ze sobą sporo udogodnień i
czyni korzystanie z zaszyfrowanego dropbox&#39;a praktycznie transparentnym.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kontener TrueCrypt trzymany na dropbox&#39;ie</title>
      <link>https://morfikov.github.io/post/kontener-truecrypt-trzymany-na-dropboxie/</link>
      <pubDate>Tue, 20 Oct 2015 18:27:46 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kontener-truecrypt-trzymany-na-dropboxie/</guid>
      <description>&lt;p&gt;Żyjemy w czasach, w których mobilność jest tak samo ważna albo może i ważniejsza (dla niektórych
ludzi na pewno) jak i bezpieczeństwo i poufność danych. Użyteczność zwykle nie idzie w patrze z
bezpieczeństwem, bo im prostszy jest dla nas dostęp do danych, tym bardziej zagraża ich
bezpieczeństwu. W tym przypadku chcielibyśmy mieć możliwość dostępu do plików, np. naszego domowego
PC, z dowolnego miejsca na ziemi. Czy można w prosty i w miarę bezpieczny sposób coś takiego
osiągnąć? &lt;a href=&#34;https://morfikov.github.io
/post/implementacja-encfs-na-dropboxie/&#34;&gt;Jakiś czas temu opisywałem implementację encfs na
dropbox&#39;ie&lt;/a&gt;, w tym artykule zostanie zaś
opisane sprzęgnięcie dropbox&#39;a z kontenerem TrueCrypt.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Przejście z Truecrypt na LUKS</title>
      <link>https://morfikov.github.io/post/przejscie-z-truecrypt-na-luks/</link>
      <pubDate>Tue, 20 Oct 2015 09:58:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/przejscie-z-truecrypt-na-luks/</guid>
      <description>&lt;p&gt;Jakiś czas temu, można było usłyszeć, że TrueCrypt nie dba wcale o bezpieczeństwo danych
zaszyfrowanych za jego pomocą. &lt;a href=&#34;http://istruecryptauditedyet.com/&#34;&gt;Audyt bezpieczeństwa&lt;/a&gt; jednak nie
wykazał większych podatności w tym oprogramowaniu. &lt;a href=&#34;https://madiba.encs.concordia.ca/~x_decarn/truecrypt-binaries-analysis/&#34;&gt;Analiza
binarek&lt;/a&gt; dostępnych na
stronie TrueCrypt&#39;a pod kątem &lt;a href=&#34;https://wiki.debian.org/ReproducibleBuilds&#34;&gt;Reproducible Builds&lt;/a&gt;
również nie wykazała większych odchyłów w stosunku do binarek generowanych prosto z kodu
źródłowego. Problematyczne może być jednak to, że tak naprawdę nie wiadomo kto stoi za tym całym
projektem, przynajmniej gdy był jeszcze rozwijany. Cała sytuacja zamknięcia TrueCrypt&#39;a z sieci była
też co najmniej dziwna. W obliczu takich niewiadomych, powinniśmy rozważyć przejście na natywne
rozwiązania linux&#39;owe, które są jawnie rozwijane, wiadomo kto za nimi stoi i, co najważniejsze, mają
wsparcie w samym kernelu.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementacja encfs na dropbox&#39;ie</title>
      <link>https://morfikov.github.io/post/implementacja-encfs-na-dropboxie/</link>
      <pubDate>Mon, 19 Oct 2015 23:11:22 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/implementacja-encfs-na-dropboxie/</guid>
      <description>&lt;p&gt;Jako, że ostatnio &lt;a href=&#34;https://morfikov.github.io
/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/&#34;&gt;zaszyfrowaliśmy katalog domowy przy pomocy
encfs&lt;/a&gt; , to nie sposób sobie
nie zadać pytania czy tego typu mechanizm może działać w oparciu o serwisy online takie jak, np.
&lt;a href=&#34;https://www.dropbox.com/&#34;&gt;dropbox&lt;/a&gt;. Chodzi o to, że dropbox umożliwia synchronizację plików w
czasie rzeczywistym, co może być problematyczne, gdy w grę wchodzi szyfrowanie danych. Wszelkie inne
rozwiązania na bazie &lt;a href=&#34;https://pl.wikipedia.org/wiki/Linux_Unified_Key_Setup&#34;&gt;LUKS&lt;/a&gt; są mało
praktyczne w tym przypadku. Natomiast synchronizowanie pojedynczych plików zaszyfrowanych przy
pomocy &lt;code&gt;encfs&lt;/code&gt; zapowiada się obiecująco.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zaszyfrowana przestrzeń wymiany SWAP</title>
      <link>https://morfikov.github.io/post/zaszyfrowana-przestrzen-wymiany-swap/</link>
      <pubDate>Mon, 19 Oct 2015 22:32:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zaszyfrowana-przestrzen-wymiany-swap/</guid>
      <description>&lt;p&gt;Opisując mechanizm szyfrowania katalogu domowego przy pomocy &lt;a href=&#34;https://morfikov.github.io
/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/&#34;&gt;narzędzia
encfs&lt;/a&gt; , wspomniałem o
problemie jaki powstaje przy jednoczesnym braku szyfrowania przestrzeni wymiany SWAP. Oczywiście,
jeśli posiadamy w systemie dużą ilość pamięci RAM, to raczej nie potrzebna nam jest przestrzeń
wymiany. Podobnie sprawa ma się w przypadku, gdy nie korzystamy z hibernacji. Natomiast, jeśli jedna
z naszych partycji jest sformatowana jako SWAP i aktywnie z niej korzystamy, to niepełne szyfrowanie
dysku, jakie zapewnia &lt;code&gt;encfs&lt;/code&gt; może doprowadzić do skompromitowania zaszyfrowanych danych.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie katalogu /home/ przy pomocy encfs</title>
      <link>https://morfikov.github.io/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/</link>
      <pubDate>Mon, 19 Oct 2015 21:54:02 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/</guid>
      <description>&lt;p&gt;Wielu ludzi uważa, że szyfrowanie całego dysku jest zbędne i pozbawione większego sensu, no bo
przecie &amp;quot;system nie zawiera żadnych wrażliwych danych, które by wymagały szyfrowania&amp;quot;. Nie będę się
tutaj spierał co do tego punktu widzenia, bo raczej wszyscy znają moje zdanie na temat &amp;quot;danych
wymagających szyfrowania&amp;quot; i skupię się tu raczej na tym jak troszeczkę podratować niepełne
szyfrowanie, które ludzie, nie wiedząc czemu, są bardziej skłonni stosować, niż cały ten full disk
encryption.&lt;/p&gt;
&lt;p&gt;Narzędzie &lt;code&gt;encfs&lt;/code&gt; nie przeszło pomyślnie &lt;a href=&#34;https://defuse.ca/audits/encfs.htm&#34;&gt;audytu bezpieczeństwa&lt;/a&gt;
, a to z takiego powodu, że projekt nie był rozwijany przez szereg lat. &lt;a href=&#34;https://github.com/vgough/encfs&#34;&gt;Obecnie jest on w rekach
społeczności&lt;/a&gt; i to od niej będzie zależeć czy te wykryte błędy
zostaną poprawione.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zabezpieczenie konta root przy pomocy pam-usb</title>
      <link>https://morfikov.github.io/post/zabezpieczenie-konta-root-przy-pomocy-pam-usb/</link>
      <pubDate>Mon, 19 Oct 2015 21:01:03 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zabezpieczenie-konta-root-przy-pomocy-pam-usb/</guid>
      <description>&lt;p&gt;Jakiś czas temu natknąłem się na moduł &lt;code&gt;pam-usb&lt;/code&gt; , który to w dość ciekawy sposób zabezpiecza dostęp
do konta użytkownika root. &lt;a href=&#34;https://wiki.debian.org/pamusb&#34;&gt;Cały mechanizm opiera się o pendrive&lt;/a&gt;,
którego to unikalne cechy są brane pod uwagę przy uwierzytelnianiu podczas logowania się na konto
super użytkownika, czyli min. gdy wydajemy polecenie &lt;code&gt;su&lt;/code&gt; albo &lt;code&gt;sudo&lt;/code&gt; . Jest to o tyle ciekawa
rzecz, że konto użytkownika root możne stać się niewrażliwe na próby złamania hasła w przypadku
połączenia sieciowego. Jak by nie patrzeć, atakujący, który łączy się zdalnie, nie jest w stanie
podłączyć do naszego komputera żadnego fizycznego urządzenia, w wyniku czego nigdy nie uzyska
dostępu do konta administratora.&lt;/p&gt;
&lt;p&gt;Pakiet &lt;code&gt;libpam-usb&lt;/code&gt; wyleciał z debiana jakiś czas temu. &lt;a href=&#34;https://tracker.debian.org/news/686153&#34;&gt;Powodem
były&lt;/a&gt; zależności, które wskazywały na przestarzały już
pakiet &lt;code&gt;udisks&lt;/code&gt; . Poza tym, nikt nie zajmował się tym pakietem. Obecnie jest on dostępny jedynie w
starszych wydaniach debiana.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Serwer kluczy GPG i kwestia prywatności</title>
      <link>https://morfikov.github.io/post/serwer-kluczy-gpg-i-kwestia-prywatnosci/</link>
      <pubDate>Fri, 16 Oct 2015 18:59:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/serwer-kluczy-gpg-i-kwestia-prywatnosci/</guid>
      <description>&lt;p&gt;Czytając sobie artykuł na temat &lt;a href=&#34;https://trac.torproject.org/projects/tor/wiki/doc/TorifyHOWTO/GnuPG&#34;&gt;TORyfikacji zapytań do serwerów kluczy
GPG&lt;/a&gt;, pomyślałem, że w sumie
mógłbym zreprodukować przedstawione tam kroki dotyczące implementacji tego rozwiązania na windowsie
i wdrożyć je na linux&#39;ie. Chodzi generalnie o to, by serwer kluczy GPG nie był odpytywany
bezpośrednio przy szukaniu/przesyłaniu kluczy przez sieć, bo to może identyfikować nas, jak i grupę
ludzi, która się z nami komunikuje. Jakby nie patrzeć, klucze GPG składają się z dość newralgicznych
informacji, typu imię, nazwisko czy adres email, a serwer kluczy GPG tych danych w żaden sposób nie
zabezpiecza i są one zwykle przesyłane otwartym tekstem przez sieć.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generowanie certyfikatów przy pomocy easy-rsa</title>
      <link>https://morfikov.github.io/post/generowanie-certyfikatow-przy-pomocy-easy-rsa/</link>
      <pubDate>Thu, 08 Oct 2015 14:29:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/generowanie-certyfikatow-przy-pomocy-easy-rsa/</guid>
      <description>&lt;p&gt;Jakiś czas temu przedstawiłem &lt;a href=&#34;https://morfikov.github.io
/post/generowanie-certyfikatow/&#34;&gt;manualny sposób na generowanie
certyfikatów&lt;/a&gt;, które można z powodzeniem
wykorzystać przy ssl, openvpn czy freeradius. Nie było tego znowu aż tak dużo ale jakby nie patrzeć
trochę parametrów trzeba znać, a najlepiej mieć przygotowane odpowiednie linijki, by sam proces
generowania certyfikatów przebiegł dość sprawnie. Jednak wychodzi na to, że nie trzeba się znowu aż
tak wysilać, bo istnieją dedykowane narzędzia, które wygenerują nam wszystkie potrzebne pliki. Mowa
o &lt;code&gt;easy-rsa&lt;/code&gt; i to niego będzie dotyczył ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zaszyfrowane logi w rsyslog i syslog-ng</title>
      <link>https://morfikov.github.io/post/zaszyfrowane-logi-w-rsyslog-i-syslog-ng/</link>
      <pubDate>Thu, 08 Oct 2015 13:53:38 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zaszyfrowane-logi-w-rsyslog-i-syslog-ng/</guid>
      <description>&lt;p&gt;Jakiś czas temu, na forum DUG&#39;a wyczytałem coś o przesyłaniu logów systemowych przez sieć. W sumie,
to nigdy mi to do głowy nie przyszło ale jeśli by się nad tym głębiej zastanowić, tego typu
mechanizm może okazać się całkiem użyteczny. Na dobrą sprawę nie wiem jak to jest rozwiązane w
debianie opartym o systemd, natomiast jeśli chodzi o inne init&#39;y (openrc i sysvinit), to tego typu
funkcjonalność można zaimplementować wykorzystując narzędzie &lt;code&gt;rsyslog&lt;/code&gt; lub &lt;code&gt;syslog-ng&lt;/code&gt; . W tym
wpisie zostanie opisana konfiguracja debianowego serwera, na którym będzie nasłuchiwał daemon
&lt;code&gt;rsyslog&lt;/code&gt; . Dodatkowo, zostanie przedstawiona konfiguracja dwóch klientów, z których jeden będzie
miał zainstalowanego &lt;code&gt;syslog-ng&lt;/code&gt; , a drugi &lt;code&gt;rsyslog&lt;/code&gt; . Z klientów logi zostaną przesłane do serwera.
Dodatkowo, postaramy się &lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/tutorials/tls_cert_summary.html&#34;&gt;zaszyfrować ruch przy pomocy kanału
TLS&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Moduł ssl w Apache2</title>
      <link>https://morfikov.github.io/post/modul-ssl-w-apache/</link>
      <pubDate>Sat, 05 Sep 2015 18:10:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/modul-ssl-w-apache/</guid>
      <description>&lt;p&gt;Przy okazji uszczelniania serwera Apache2, przypomniał mi się &lt;a href=&#34;https://morfikov.github.io
/post/logjam-czyli-nowa-podatnosc-w-ssltls/&#34;&gt;atak
logjam&lt;/a&gt; , przez który to było niemałe
zamieszanie. Pamiętam, że w tamtym czasie próbowałem zabezpieczyć swój serwer testowy, by był na tę
formę ataku odporny. Niemniej jednak, wersja Apache2, która w tamtym czasie była u mnie
zainstalowana, nie do końca dawała taką możliwość. Dziś podszedłem do tej kwestii jeszcze raz i w
oparciu &lt;a href=&#34;https://weakdh.org/sysadmin.html&#34;&gt;o ten link&lt;/a&gt; udało mi się poprawnie skonfigurować mój
serwer www.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Migracja certyfikatów OpenSSL z SHA-1</title>
      <link>https://morfikov.github.io/post/migracja-certyfikatow-openssl-z-sha-1/</link>
      <pubDate>Sat, 05 Sep 2015 17:15:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/migracja-certyfikatow-openssl-z-sha-1/</guid>
      <description>&lt;p&gt;Szukając co by tutaj jeszcze poprawić w moim środowisku testowym, w którym działa między innymi
apache, natrafiłem na komunikat w firefoxie, który oznajmił mi, że certyfikat mojego serwera
korzysta z przestarzałego już algorytmu mieszającego (hash). W tym przypadku jest to SHA-1. &lt;a href=&#34;https://blog.mozilla.org/security/2014/09/23/phasing-out-certificates-with-sha-1-based-signature-algorithms/&#34;&gt;Jak
można przeczytać na blogu
mozilli&lt;/a&gt;,
algorytm SHA-1 wypadł z łask jakiś czas temu i obecnie nie zaleca się jego używania ze względów
bezpieczeństwa. Postanowiłem zatem poprawić tę lukę.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>AppArmor i profilowanie aplikacji</title>
      <link>https://morfikov.github.io/post/apparmor-profilowanie-aplikacji/</link>
      <pubDate>Sat, 08 Aug 2015 23:33:59 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apparmor-profilowanie-aplikacji/</guid>
      <description>&lt;p&gt;Po ostatnich doniesieniach na temat &lt;a href=&#34;https://blog.mozilla.org/security/2015/08/06/firefox-exploit-found-in-the-wild/&#34;&gt;błędu jaki został znaleziony w
Firefox&#39;ie&lt;/a&gt; ,
doszedłem do wniosku, że najwyższy czas nauczyć się obsługi narzędzia &lt;code&gt;AppArmor&lt;/code&gt; . Ma ono pomóc w
kontrolowaniu praw dostępu do zasobów systemu operacyjnego, np. plików, katalogów czy określonych
urządzeń. Jeśli weźmiemy przytoczony wyżej błąd, to przeglądarka bez takiego profilu AppArmor&#39;a była
w stanie przeszukać lokalne pliki i wysłać je gdzieś na net, co powodowałoby udostępnienie poufnych
danych, np. historia poleceń shell&#39;owych, czy klucze prywatne.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Firewall na linux&#39;owe maszyny klienckie</title>
      <link>https://morfikov.github.io/post/firewall-na-linuxowe-maszyny-klienckie/</link>
      <pubDate>Mon, 22 Jun 2015 23:33:58 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/firewall-na-linuxowe-maszyny-klienckie/</guid>
      <description>&lt;p&gt;Prędzej czy później, każdy z nas będzie musiał zabezpieczyć dostęp do swojego komputera w sieci. Do
tego zadania na stacjach z linux&#39;em jest oddelegowane narzędzie &lt;code&gt;iptables&lt;/code&gt; wraz z szeregiem
dodatków, jak np. &lt;code&gt;ipset&lt;/code&gt; . By zbudować solidny firewall nie potrzeba zbytnio się wysilać. Niemniej
jednak, temat zapory linux&#39;owej jest &lt;a href=&#34;https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html&#34;&gt;bardzo
rozległy&lt;/a&gt; i nie będziemy tutaj
opisywać wszystkich możliwych scenariuszy jej zastosowania. Zamiast tego skupimy się jedynie na
bazowym skrypcie, który można rozbudować bez przeszkód i dostosować go zarówno pod maszyny klienckie
jak i te serwerowe.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ECryptfs jako alternatywa dla encfs</title>
      <link>https://morfikov.github.io/post/ecryptfs-jako-alternatywa-dla-encfs/</link>
      <pubDate>Mon, 22 Jun 2015 18:58:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ecryptfs-jako-alternatywa-dla-encfs/</guid>
      <description>&lt;p&gt;Dnia 2014-10-07 w Debianie była aktualizacja pakietu &lt;code&gt;encfs&lt;/code&gt; , która to zawierała informację na
temat &lt;a href=&#34;https://defuse.ca/audits/encfs.htm&#34;&gt;audytu bezpieczeństwa&lt;/a&gt; jaki się dokonał parę miesięcy wstecz. Wyniki niezbyt dobrze
wypadły, a nawet można powiedzieć, że wręcz katastrofalnie. Generalnie cały test został skwitowany
słowami, że jeśli szyfrujemy pliki przy pomocy tego narzędzia, to jesteśmy relatywnie bezpieczni,
nawet w przypadku jeśli ktoś te pliki przechwyci. Natomiast jeśli zaczniemy zmieniać/dodawać pliki
i ten ktoś ponownie przechwyci nasz zaszyfrowany katalog, wtedy może on bez problemu odszyfrować
całą jego zawartość. Jeśli wykorzystujemy &lt;code&gt;encfs&lt;/code&gt; lokalnie, to być może nam nic nie grozi, nawet w
przypadku raidu NSA na naszą chałupę. Problem w tym, że ogromna rzesza ludzi wykorzystuje &lt;code&gt;encfs&lt;/code&gt;
do zaszyfrowania plików w chmurze, np. na Dropbox&#39;ie czy MEGA, a jak wiadomo, przy każdej
synchronizacji, zmiany w danym katalogu są przesyłane do chmury i wszelkie zabezpieczenie jakie
daje &lt;code&gt;encfs&lt;/code&gt; diabli biorą. Może najwyższy czas zainteresować się &lt;code&gt;ecryptfs&lt;/code&gt;?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Autostart i automatyczne montowanie nośników</title>
      <link>https://morfikov.github.io/post/autostart-i-automatyczne-montowanie-nosnikow/</link>
      <pubDate>Fri, 19 Jun 2015 17:17:11 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/autostart-i-automatyczne-montowanie-nosnikow/</guid>
      <description>&lt;p&gt;Menadżery plików potrafią automatycznie montować nośniki wymienne w oparciu o pakiet
&lt;a href=&#34;https://www.freedesktop.org/wiki/Software/udisks/&#34;&gt;udisks2&lt;/a&gt;. Potrafią także uruchamiać odpowiednie
aplikacje zlokalizowane na tych urządzeniach. Może to prowadzić do oczywistych zagrożeń i jeśli nasz
system ma być bezpieczny, to musimy wyłączyć obie te opcje. W różnych menadżerach plików, ten proces
przebiega inaczej. Ja korzystam ze &lt;a href=&#34;https://ignorantguru.github.io/spacefm/&#34;&gt;spacefm&lt;/a&gt; i w jego
przypadku mamy dość rozbudowany mechanizm polityki dotyczącej tych dwóch powyższych kwestii.
Niemniej jednak, w przypadku każdego z menadżera plików, proces postępowania powinien przebiegać
mniej więcej w ten sam sposób.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Automatyczne wylogowanie użytkownika z konsoli</title>
      <link>https://morfikov.github.io/post/automatyczne-wylogowanie-uzytkownika-z-konsoli/</link>
      <pubDate>Wed, 17 Jun 2015 22:06:51 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/automatyczne-wylogowanie-uzytkownika-z-konsoli/</guid>
      <description>&lt;p&gt;Każdemu z nas zdarzyło się zostawić włączoną konsolę, na której byliśmy zalogowani jako
administrator systemu root. Być może nie zdajemy sobie sprawy jak często potrafimy popełnić tego
typu gafę. Jedną z metod obrony jest oczywiście wyłączenie konta root w systemie i korzystanie z
&lt;a href=&#34;https://pl.wikipedia.org/wiki/Sudo&#34;&gt;sudo&lt;/a&gt;. Ja jednak wolę inne rozwiązanie, które zakłada
ograniczenie czasu bezczynności, po którym to użytkownik zostanie automatycznie wylogowany.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Konfiguracja GPG w pliku gpg.conf</title>
      <link>https://morfikov.github.io/post/konfiguracja-gpg-w-pliku-gpg-conf/</link>
      <pubDate>Sun, 14 Jun 2015 23:19:51 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-gpg-w-pliku-gpg-conf/</guid>
      <description>&lt;p&gt;Narzędzie &lt;code&gt;gpg&lt;/code&gt; posiada swój własny plik konfiguracyjnych, który zwykle jest zlokalizowany w
&lt;code&gt;~/.gnupg/gpg.conf&lt;/code&gt; . Można w nim sprecyzować większość z opcji, które zwykle są podawane w
terminalu przy wywoływaniu polecenia &lt;code&gt;gpg&lt;/code&gt; . Po zdefiniowaniu odpowiednich wpisów w pliku
konfiguracyjnym, nie będziemy musieli już wyraźnie podawać tych parametrów ilekroć będziemy chcieli
skorzystać z &lt;code&gt;gpg&lt;/code&gt; . Przy okazji szukania info o kluczach GPG, natknąłem się na dość ciekawy
&lt;a href=&#34;https://riseup.net/security/message-security/openpgp/best-practices&#34;&gt;artykuł na temat GnuPG&lt;/a&gt;. Jest
tam sporo informacji, które są wielce użyteczne w procesie konfiguracji tego narzędzia poprawiając
tym samym dość znacznie bezpieczeństwo komunikacji.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bezpieczny klucz GPG</title>
      <link>https://morfikov.github.io/post/bezpieczny-klucz-gpg/</link>
      <pubDate>Sun, 14 Jun 2015 11:55:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/bezpieczny-klucz-gpg/</guid>
      <description>&lt;p&gt;W poprzednim wpisie przygotowywaliśmy sobie &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-gpg-w-pliku-gpg-conf/&#34;&gt;plik
gpg.conf&lt;/a&gt;. Opcje w nim ustawione są
niezbędne do wygenerowania dobrego pod względem bezpieczeństwa klucza GPG. Taki klucz GPG nie
powinien być krótszy niż 4096 bitów. Dodatkowo, nie powinno się ustawiać daty ważności dłuższej niż
2 lata, a to z tego powodu, że zawszę tę datę można zmienić i to nawet w przypadku gdy klucz straci
ważność. Chodzi generalnie o ustawienie jakiegoś mechanizmu zabezpieczającego na wypadek gdyby nasz
klucz GPG wpadł w niepowołane ręce i stracilibyśmy nad nim panowanie. Wtedy po jakimś czasie
automatycznie się on unieważni i nie będziemy musieli się martwić czy ktoś może przez przypadek go
używać. Jest również szereg innych rzecz, o które powinniśmy się zatroszczyć i tej tematyce będzie
poświęcony ten wpis, który w dużej mierze powstał w oparciu o te
&lt;a href=&#34;https://www.gnupg.org/gph/en/manual/book1.html&#34;&gt;dwa&lt;/a&gt;
&lt;a href=&#34;https://riseup.net/security/message-security/openpgp/best-practices&#34;&gt;linki&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Automatycznie generowane hasło do serwisu www</title>
      <link>https://morfikov.github.io/post/automatycznie-generowane-haslo-do-serwisu-www/</link>
      <pubDate>Wed, 10 Jun 2015 20:51:06 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/automatycznie-generowane-haslo-do-serwisu-www/</guid>
      <description>&lt;p&gt;Każdy z nas dla wygody, albo raczej przez lenistwo, stara się nie używać zbyt skomplikowanych haseł.
Zwykle też korzystamy z tego samego hasła do większości kont online w internecie. Jeśli zdarzyło nam
się tworzyć proste, krótkie i do tego łatwe do przewidzenia hasła, np. w oparciu o datę urodzenia
lub inne tego typu informacji, to przydałoby się nieco popracować nad zabezpieczeniami tych poufnych
danych, tak by nie były proste do odgadnięcia czy też i złamania.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Uwierzytelniające klucze SSH</title>
      <link>https://morfikov.github.io/post/uwierzytelniajace-klucze-ssh/</link>
      <pubDate>Tue, 02 Jun 2015 15:35:53 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/uwierzytelniajace-klucze-ssh/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/SSH_keys&#34;&gt;Klucze SSH&lt;/a&gt; mogą być wykorzystane jako sposób
identyfikacji danej osoby przy logowaniu się do zdalnego serwera SSH. Te klucze zawsze występują w
parach -- jeden prywatny, drugi publiczny. Pierwszy z nich jest znany tylko nam i powinien być
trzymany w sekrecie i pilnie strzeżony. Klucz publiczny z kolei zaś jest przesyłany na każdy serwer
SSH, z którym chcemy się połączyć. Gdy serwer jest w posiadaniu naszego klucza publicznego i widzi
przy tym, że próbujemy nawiązać połączenie, używa on tego klucza by wysłać do nas zapytanie
(challange) -- jest ono zakodowane i musi na nie zostać udzielona odpowiednia odpowiedź, a tej może
dokonać ktoś, kto jest w posiadaniu klucza prywatnego. Nie ma innej opcji by rozkodować wiadomość,
dlatego też nikt inny nie może udzielić na nią prawidłowej odpowiedzi. To rozwiązanie eliminuje
wrażliwość na różne formy podsłuchu -- ten kto nasłuchuje nie będzie w stanie przechwycić pakietów
zawierających hasło, bo ono nie jest nigdy transmitowane prze sieć. No i oczywiście jeśli chodzi o
samo hasło -- odpadają nam ataki typu Brute Force pod kątem jego złamania.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Problemy wynikające z używania pliku .htaccess</title>
      <link>https://morfikov.github.io/post/problemy-wynikajace-z-uzywania-pliku-htaccess/</link>
      <pubDate>Tue, 26 May 2015 13:25:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/problemy-wynikajace-z-uzywania-pliku-htaccess/</guid>
      <description>&lt;p&gt;Na stronie Apache jest &lt;a href=&#34;http://httpd.apache.org/docs/2.0/howto/htaccess.html#when&#34;&gt;kawałek ciekawego
artykułu&lt;/a&gt; na temat zagrożeń jakie niesie
ze sobą stosowanie pliku &lt;code&gt;.htaccess&lt;/code&gt; w katalogach stron trzymanych na serwerze wwww. Oczywiście, w
pewnych sytuacjach, takich jak np. hostingi, nie będziemy mieć innego wyboru jak zdać się na ten
plik ale jeśli mamy bezpośredni dostęp do konfiguracji Apache, możemy przenieść wszystkie te wpisy z
pliku &lt;code&gt;.htaccess&lt;/code&gt; i poprawić tym bezpieczeństwo witryny jak i po części wydajność samego serwera
www.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Wymuszenie SSL/TLS przy pomocy vhost&#39;ów w Apache2</title>
      <link>https://morfikov.github.io/post/wymuszenie-ssl-tls-przy-pomocy-vhostow-apache2/</link>
      <pubDate>Tue, 26 May 2015 11:24:13 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wymuszenie-ssl-tls-przy-pomocy-vhostow-apache2/</guid>
      <description>&lt;p&gt;Mając na stronie www formularze logowania czy rejestracji (ewentualnie panele administracyjne),
rozmyślnym krokiem jest implementacja protokołu SSL/TLS. Jeśli mamy potrzebę, możemy także pokusić
się o zaszyfrowanie całego ruchu w obrębie naszej witryny. Problem w tym, że odwiedzający naszą
stronę użytkownicy mogą korzystać z linków, czy wpisywać adresy, które nie rozpoczynają się od
&lt;code&gt;https://&lt;/code&gt; , a jedynie od &lt;code&gt;http://&lt;/code&gt; . W takim przypadku, nawet jeśli szyfrujemy ruch w serwisie, to
odwiedzenie tego typu adresu zwróci nam stronę kanałem nieszyfrowanym, co może godzić w
bezpieczeństwo samej strony jak i również w naszą/czyjąś prywatność. W tym krótki artykule
spróbujemy tak skonfigurować serwer Apache2, by przekierował tego typu zapytania i słał je
szyfrowanym tunelem.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WordPress: Zmiana domyślnych nazw folderów</title>
      <link>https://morfikov.github.io/post/wordpress-zmiana-domyslnych-nazw-folderow/</link>
      <pubDate>Mon, 25 May 2015 15:03:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wordpress-zmiana-domyslnych-nazw-folderow/</guid>
      <description>&lt;p&gt;Internet to bardzo niebezpieczne miejsce i do tego pełne różnego rodzaju botów szukających
ujawnionych już podatności i niekoniecznie rozchodzi się o kod WordPressa. Tak czy inaczej,
WodrPress to bardzo popularny CMS, którego instalacja przebiega (i wygląda) praktycznie tak samo i
to bez znaczenia gdzie nie zostałby on zainstalowany. Chodzi o to, że zawsze mamy do czynienia z
tymi samymi skryptami czy nazwami katalogów. Nie zmieniają się także ścieżki to plików, no i
oczywiście pluginy, których większa ilość może zagrozić bezpieczeństwu naszej strony. Nie chodzi mi
tutaj o pilnowanie instalacji i ciągłe aktualizowanie kodu, bo to rozumie się samo przez się. Chodzi
mi generalnie o &lt;a href=&#34;https://codex.wordpress.org/Editing_wp-config.php#Moving_wp-content_folder&#34;&gt;zmodyfikowanie nieco samej instalacji&lt;/a&gt; WordPress&#39;a, tak by nie przypominała
wszystkich pozostałych. W ten sposób możemy się uchronić przed zautomatyzowanymi robotami (i innym
syfem), które są w stanie podrzucić coś nam na stronę o ile ta ma domyślne ścieżki. Im wcześniej
zabierzemy się za zmianę domyślnych nazw katalogów, tym lepiej, bo jeśli w przyszłości będziemy
zmieniać te nazwy i to na blogu czy w serwisie gdzie mamy sporo kontentu w postaci grafiki czy innej
załączonej treści, wtedy trzeba będzie te linki przepisać, bo przestaną zwyczajnie działać.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Logjam, czyli nowa podatność w SSL/TLS</title>
      <link>https://morfikov.github.io/post/logjam-czyli-nowa-podatnosc-w-ssltls/</link>
      <pubDate>Mon, 25 May 2015 08:12:39 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/logjam-czyli-nowa-podatnosc-w-ssltls/</guid>
      <description>&lt;p&gt;Jak donoszą &lt;a href=&#34;https://blog.cryptographyengineering.com/2015/05/22/attack-of-week-logjam/&#34;&gt;ostatnio&lt;/a&gt;
&lt;a href=&#34;https://niebezpiecznik.pl/post/logjam-nowa-podatnosc-w-protokolach-https-ssh-i-ipsec/&#34;&gt;media&lt;/a&gt;, mamy
kolejną dziurę (&lt;em&gt;&lt;strong&gt;logjam&lt;/strong&gt;&lt;/em&gt;) dotyczącą szyfrowania SSL/TLS, a konkretnie rozchodzi się o
powszechnie stosowany na całym świecie protokół
&lt;a href=&#34;https://pl.wikipedia.org/wiki/Protok%C3%B3%C5%82_Diffiego-Hellmana&#34;&gt;Diffiego-Hellmana&lt;/a&gt; . I znów
jest podobny scenariusz, bo ten problem nie powinien mieć miejsca ale z powodu wstecznej
kompatybilności, tj. zapewnienie wsparcia dla wszystkich tych przestarzałych szyfrów tak by te
przedwieczne systemy/maszyny mogły działać, można doprowadzić do osłabienie mechanizmów, które
powinny być wykorzystywane obecnie. OK, może nie tyle osłabić, co wykorzystać te słabsze
odpowiedniki zamiast tych mocniejszych.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WordPress: Szyfrowanie SSL/TLS</title>
      <link>https://morfikov.github.io/post/wordpress-szyfrowanie-ssltls/</link>
      <pubDate>Sun, 24 May 2015 19:54:15 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wordpress-szyfrowanie-ssltls/</guid>
      <description>&lt;p&gt;W dzisiejszych czasach bez szyfrowania ani rusz i na dobrą sprawę by prowadzić jakikolwiek serwis
www, trzeba wliczyć w koszty overhead jaki niesie ze sobą zaszyfrowanie zawartości takiej witryny.
Oczywiście, niektórzy minimalizują straty ograniczając się jedynie do zaszyfrowania formularza
rejestracji/logowania lub też i ewentualnego panelu administracyjnego. Tak czy inaczej, &lt;a href=&#34;https://codex.wordpress.org/Administration_Over_SSL&#34;&gt;WordPress
domyślnie nie szyfruje niczego&lt;/a&gt; i przydałoby
się zmienić nieco jego konfigurację.&lt;/p&gt;
&lt;p&gt;Poniższe instrukcje zadziałają jedynie w przypadku gdy pod serwer mamy już podpięty certyfikat. Nie
będę tutaj opisywał jak poprawnie skonfigurować serwer Apache by włączyć w nim obsługę szyfrowania
SSL/TLS. Jak znajdę trochę czasu, to na pewno wstawię tutaj link do przystępnego opisu.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bezpieczeństwo Xserver&#39;a pod linux&#39;em</title>
      <link>https://morfikov.github.io/post/bezpieczenstwo-xservera-pod-linuxem/</link>
      <pubDate>Sat, 09 May 2015 17:21:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/bezpieczenstwo-xservera-pod-linuxem/</guid>
      <description>&lt;p&gt;Prawdopodobnie każdy z nas korzysta, lub też i korzystał, ze skrótu klawiszy Ctrl-Alt-Backspace do
resetowania środowiska graficznego na linux&#39;ie. Może i to jest wygodny sposób na szybki restart
&lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-xservera-na-debianie-xorg/&#34;&gt;sesji graficznej Xserver&#39;a&lt;/a&gt; ale
&lt;a href=&#34;https://www.jwz.org/xscreensaver/faq.html#no-ctl-alt-bs&#34;&gt;nie do końca jest on bezpieczny&lt;/a&gt;. Nie
mówię tutaj o samej utracie danych towarzyszącej takiej akcji ale o możliwości obejścia ekranu
logowania o ile ta kombinacja klawiszy nie jest wyłączona. Jest też kilka innych rzeczy, które mogą
skompromitować źle zabezpieczony Xserver i tej kwestii będzie poświęcony niniejszy wpis.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>