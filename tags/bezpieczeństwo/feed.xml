<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>bezpieczeństwo on Morfitronik</title>
    <link>https://morfikov.github.io/tags/bezpiecze%C5%84stwo/</link>
    <description>Recent content in bezpieczeństwo on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sun, 27 Sep 2020 12:29:00 +0200</lastBuildDate><atom:link href="https://morfikov.github.io/tags/bezpiecze%C5%84stwo/feed.xml" rel="self" type="application/rss" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Uwierzytelnianie odpowiedzi z serwerów czasu NTP przy pomocy NTS</title>
      <link>https://morfikov.github.io/post/uwierzytelnianie-odpowiedzi-z-serwerow-czasu-ntp-przy-pomocy-nts/</link>
      <pubDate>Sun, 27 Sep 2020 12:29:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/uwierzytelnianie-odpowiedzi-z-serwerow-czasu-ntp-przy-pomocy-nts/</guid>
      <description>&lt;p&gt;Przepisując ostatnio stare artykuły dotyczące &lt;a href=&#34;https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/&#34;&gt;zabezpieczenia zapytań DNS za sprawą wdrożenia na
linux dnsmasq i dnscrypt-proxy&lt;/a&gt;, natknąłem się &lt;a href=&#34;https://blog.cloudflare.com/secure-time/&#34;&gt;na informację&lt;/a&gt;, że nie tylko komunikacja DNS
w obecnych czasach w sporej mierze nie jest zaszyfrowana. W zasadzie każda maszyna podłączona do
internetu potrzebuje dysponować w miarę dokładnym czasem. By ten czas był dokładny, wymyślono
mechanizm synchronizacji czasu przez wysyłanie zapytań do serwerów NTP (&lt;a href=&#34;https://pl.wikipedia.org/wiki/Network_Time_Protocol&#34;&gt;Network Time Protocol&lt;/a&gt;).
Niemniej jednak, odpowiedzi z tych serwerów czasu nie są w żaden sposób zabezpieczone i praktycznie
każdy na drodze tych pakietów może nam zmienić ustawienia czasu w systemie (MITM). W taki sposób
możemy zostać cofnięci w czasie, co z kolei może oznaczać, że system zaakceptuje certyfikaty SSL/TLS
czy też &lt;a href=&#34;https://trimstray.github.io/posts/2019-07-21-nginx-optymalizacja_sesji_ssl-tls/#ssl_session_tickets&#34;&gt;klucze/bilety sesji&lt;/a&gt; (używane do wznawiania sesji TLS), które już dawno temu wygasły
lub/i zostały w jakiś sposób skompromitowane. Pchnięcie nas do przodu w czasie również oznacza
problemy, bo możemy zaakceptować certyfikat, który jeszcze nie zaczął być ważny. To z kolei otwiera
drogę do odszyfrowania połączeń z serwisami WWW, a przecie nie po to szyfrujemy ruch, by go ktoś bez
większego problemu odszyfrował. Dlatego też powinniśmy zadbać o to, by informacje o aktualnym czasie
otrzymywane z sieci docierały do nas z wiarygodnego źródła i były w jakiś sposób uwierzytelnione.
Na Debianie standardowo do synchronizacji czasu wykorzystywany jest &lt;code&gt;systemd-timesyncd&lt;/code&gt; ale &lt;a href=&#34;https://github.com/systemd/systemd/issues/9481&#34;&gt;nie
wspiera on póki co protokołu NTS&lt;/a&gt;. Trzeba będzie zatem się go pozbyć i zastąpić go demonem &lt;code&gt;ntpd&lt;/code&gt;
z pakietu &lt;code&gt;ntpsec&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Szyfrowany DNS z dnscrypt-proxy i dnsmasq na Debian linux</title>
      <link>https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/</link>
      <pubDate>Sat, 19 Sep 2020 14:13:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/</guid>
      <description>&lt;p&gt;Ostatnio na forum dug.net.pl jeden z użytkowników &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=31524&#34;&gt;miał dość spory problem&lt;/a&gt; z ogarnięciem
zadania polegającego na zaszyfrowaniu zapytań DNS z wykorzystaniem &lt;a href=&#34;https://dnscrypt.info/&#34;&gt;dnscrypt-proxy&lt;/a&gt; i
&lt;a href=&#34;http://www.thekelleys.org.uk/dnsmasq/doc.html&#34;&gt;dnsmasq&lt;/a&gt;. Ładnych parę lat temu opisywałem &lt;a href=&#34;https://morfikov.github.io/tags/resolver/&#34;&gt;jak skonfigurować te dwa narzędzia na Debianie&lt;/a&gt;
(i też na OpenWRT), choć od tamtego czasu w świecie linux&#39;owym trochę rzeczy się pozmieniało. Dla
przykładu, dnscrypt-proxy przeszedł gruntowną przebudowę, no i też systemd jest w powszechniejszym
użyciu niż to miało miejsce w tamtych czasach, przez co w sporej części przypadków usługi takie jak
&lt;code&gt;systemd-networkd.service&lt;/code&gt; czy &lt;code&gt;systemd-resolved.service&lt;/code&gt; są już włączone domyślnie. Zatem sporo
informacji zawartych w tych napisanych przeze mnie artykułach już niekoniecznie może znaleźć
obecnie zastosowanie. Dlatego też pomyślałem, że nadszedł już czas, by ździebko zaktualizować tamte
wpisy. Ostatecznie stanęło jednak na tym, by w oparciu o te artykuły napisać kompletnie nowy tekst
na temat szyfrowania zapytań DNS na linux przy wykorzystaniu oprogramowania &lt;code&gt;dnscrypt-proxy&lt;/code&gt; oraz
&lt;code&gt;dnsmasq&lt;/code&gt; i zawrzeć w nim te wszystkie ciekawsze informacje, które udało mi się pozyskać przez te
ostatnie lata w kwestii poprawy bezpieczeństwa i prywatności przy przeglądaniu stron WWW.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zweryfikować plik APK aplikacji na Androida</title>
      <link>https://morfikov.github.io/post/jak-zweryfikowac-plik-apk-aplikacji-na-androida/</link>
      <pubDate>Fri, 13 Dec 2019 19:26:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zweryfikowac-plik-apk-aplikacji-na-androida/</guid>
      <description>&lt;p&gt;Część użytkowników smartfonów z Androidem na pokładzie żyje w głębokim przekonaniu, że instalowanie
aplikacji spoza sklepu Google Play nie jest zbyt rozważnym posunięciem. Nie chodzi tutaj tylko o
szeroko rozumiane alternatywne źródła aplikacji, np. serwis apkmirror ale również o Yalp/Aurora
Store czy też repozytoria F-Droid. Zdaniem tych osób pobieranie aplikacji z zewnętrznych źródeł
może skompromitować bezpieczeństwo systemu oraz zagrozić naszej prywatności. No jakby nie patrzeć
wgrywanie czegokolwiek bez zastanowienia się co tak naprawdę instalujemy w systemie nie jest zbyt
mądre. Dlaczego zatem nie weryfikujemy aplikacji obecnych w oficjalnym sklepie Google? Co chwila
przecież można usłyszeć w mediach o syfie, który udało się co prawda z tego sklepu usunąć ale też
jakaś większa liczba użytkowników taką aplikację zdążyła już zainstalować i używała jej przez
dłuższy lub krótszy okres czasu. Rozumowanie na zasadzie, że aplikacje ze sklepu Google Play są
bezpieczne, bo są obecne w sklepie Google Play, daje nam jedynie fałszywe poczucie bezpieczeństwa,
które jest gorsze od całkowitego braku bezpieczeństwa, bo w tym drugim przypadku człowiek
przynajmniej jest świadom czyhających na niego niebezpieczeństw i włącza myślenie. Jak zatem
odróżnić aplikacje, które są w stanie nam wyrządzić krzywdę od tych, które tego nie mają na celu i
czy faktycznie pobieranie aplikacji na Androida z innego źródła niż oficjalny sklep Google Play
jest takie niebezpieczne?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Ograniczenie su do jednego użytkownika w Debianie</title>
      <link>https://morfikov.github.io/post/ograniczanie-su-do-jednego-uzytkownika-w-debianie/</link>
      <pubDate>Fri, 12 Apr 2019 19:40:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ograniczanie-su-do-jednego-uzytkownika-w-debianie/</guid>
      <description>&lt;p&gt;W dzisiejszych czasach dystrybucje linux&#39;a wykorzystują mechanizm &lt;code&gt;sudo&lt;/code&gt; do wykonywania operacji
jako administrator systemu. Zanika więc potrzeba stosowania polecenia &lt;code&gt;su&lt;/code&gt; , by zalogować się na
konto root i to z jego poziomu wykonywać wszystkie niezbędne rzeczy. Jednym z argumentów
zwolenników &lt;code&gt;sudo&lt;/code&gt; za takim sanem rzeczy jest możliwość nadania jedynie konkretnym użytkownikom w
systemie uprawnień do wykonywania poleceń jako administrator, podczas gdy inni użytkownicy
(niebędący w grupie &lt;code&gt;sudo&lt;/code&gt; ) nie mogą w ogóle korzystać z tego mechanizmu . No faktycznie, dostęp
do &lt;code&gt;su&lt;/code&gt; jest w zasadzie dla każdego użytkownika w systemie i tylko hasło konta admina dzieli ich od
uzyskania dość szerokich uprawnień. Niewiele jednak osób wie, że można skonfigurować &lt;code&gt;su&lt;/code&gt; w taki
sposób, by dostęp do niego mieli tylko ci
użytkownicy, &lt;a href=&#34;https://wiki.debian.org/WHEEL/PAM&#34;&gt;którzy powinni&lt;/a&gt;, np. ci obecni w grupie &lt;code&gt;wheel&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Factory Reset Protection (FRP) w smartfonach z Androidem</title>
      <link>https://morfikov.github.io/post/factory-reset-protection-frp-w-smartfonach-z-androidem/</link>
      <pubDate>Fri, 20 Jan 2017 18:37:11 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/factory-reset-protection-frp-w-smartfonach-z-androidem/</guid>
      <description>&lt;p&gt;Kupowanie telefonów czy smartfonów z Androidem z innych źródeł niż oficjalne punkty sprzedaży nie
zawsze jest bezpieczną opcją. Gdy nabywamy takie urządzenie od znajomego, to raczej nie powinniśmy
się martwić o to, że ten telefon może być kradziony. Niemniej jednak, po zakupie takiego urządzenia,
poprzedni użytkownik zwykle resetuje jego ustawienia do fabrycznych, by klient miał świeży system i
nie był w stanie uzyskać dostępu do prywatnych danych poprzedniego właściciela smartfona. Nie byłoby
w tym nic nadzwyczajnego, gdyby nie fakt, że nabywca tak odsprzedanego telefonu może mieć pewne
problemy ze skonfigurowaniem Androida, bo ten system zwróci mu komunikat: &amp;quot;Urządzenie zostało
zresetowane. Aby kontynuować, zaloguj się na konto Google, które było wcześniej synchronizowane na
tym urządzeniu&amp;quot;, czyli telefon został zablokowany przez mechanizm Factory Reset Protection Lock (FRP
Lock). Jeśli znajomy mieszka blisko nas, to naturalnie możemy się przejść do niego w celu zdjęcia
tej blokady. A co w przypadku, gdy nabyliśmy urządzenie na odległość? Czy jest jakiś sposób na
obejście tej blokady w przypadku smartfonów Neffos od TP-LINK?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Apache2: Konfiguracja OCSP Stapling</title>
      <link>https://morfikov.github.io/post/apache2-konfiguracja-ocsp-stapling/</link>
      <pubDate>Sat, 06 Aug 2016 19:16:09 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-konfiguracja-ocsp-stapling/</guid>
      <description>&lt;p&gt;Serwery udostępniające nam różnego rodzaju strony www na protokole SSL/TLS posiadają certyfikaty,
które są ważne przez pewien okres czasu. Z reguły jest to rok albo, jak w przypadku
&lt;a href=&#34;https://morfikov.github.io/post/certyfikat-letsencrypt-dla-bloga-certbot/&#34;&gt;letsencrypt&lt;/a&gt;, są to 3 miesiące.
Taki certyfikat może zostać unieważniony z różnych przyczyn ale informacja o tym fakcie musi trafić
do wszystkich klientów odwiedzających taki serwis www. Do tego celu mogą posłużyć dwa mechanizmy.
Pierwszym z nich są listy &lt;a href=&#34;https://pl.wikipedia.org/wiki/Lista_uniewa%C5%BCnionych_certyfikat%C3%B3w&#34;&gt;Certificate Revocation
Lists&lt;/a&gt; (CRL). Drugim zaś
jest &lt;a href=&#34;https://pl.wikipedia.org/wiki/Online_Certificate_Status_Protocol&#34;&gt;Online Certificate Status
Protocol&lt;/a&gt; (OCSP). W tym wpisie
postaramy się zaimplementować to drugie rozwiązanie na serwerze Apache2.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>HTTP Strict Transport Security (HSTS) w Apache2</title>
      <link>https://morfikov.github.io/post/http-strict-transport-security-hsts-apache2/</link>
      <pubDate>Tue, 19 Jul 2016 19:08:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/http-strict-transport-security-hsts-apache2/</guid>
      <description>&lt;p&gt;Ostatnio na niebezpieczniku czytałem &lt;a href=&#34;https://niebezpiecznik.pl/post/podroze-kosztuja/&#34;&gt;taki oto post&lt;/a&gt;. Historia jak historia, nieco długa ale
mniej więcej w połowie pojawiła się informacja na temat nagłówków HSTS (&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security&#34;&gt;HTTP Strict Transport
Security&lt;/a&gt;), który jest przesyłany w zapytaniach HTTP/HTTPS. Postanowiłem nieco się zainteresować
tym tematem i zbadać czym są te nagłówki HSTS i w jaki sposób są one w stanie poprawić
bezpieczeństwo protokołów SSL/TLS wykorzystywanych podczas szyfrowania zawartości stron
internetowych.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>nf_conntrack: automatic helper assignment is deprecated</title>
      <link>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</link>
      <pubDate>Sat, 16 Jul 2016 18:59:19 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</guid>
      <description>&lt;p&gt;Jeśli ktoś uważnie śledzi logi systemowe, to od czasu do czasu można w nich znaleźć komunikat,
którzy brzmi mniej więcej tak: &lt;code&gt;nf_conntrack: automatic helper assignment is deprecated and it will be removed soon. Use the iptables CT target to attach helpers instead&lt;/code&gt; . Ta wiadomość odnosi się do
jednego z modułów linux&#39;owego filtra pakietów &lt;code&gt;iptables&lt;/code&gt; . Moduł, o którym mowa to &lt;code&gt;nf_conntrack&lt;/code&gt; ,
który odpowiada za śledzenie połączeń nawiązywanych przez system. Sam komunikat zaś dotyczy
mechanizmów pomocniczych, których sposób aktywacji jest już nieco przestarzały i zostanie wkrótce
usunięty. Co to oznacza dla przeciętnego użytkownika linux&#39;a i czym są w istocie te mechanizmy
pomocnicze, które znajdują zastosowane na zaporze sieciowej?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja DMZ w OpenWRT</title>
      <link>https://morfikov.github.io/post/konfiguracja-dmz-openwrt/</link>
      <pubDate>Tue, 05 Jul 2016 18:05:31 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-dmz-openwrt/</guid>
      <description>&lt;p&gt;Strefa zdemilitaryzowana (&lt;a href=&#34;https://pl.wikipedia.org/wiki/Strefa_zdemilitaryzowana_(informatyka)&#34;&gt;DMZ, demilitarized
zone&lt;/a&gt;) to taki mechanizm,
który ma na celu poprawę bezpieczeństwa usług w sieci lokalnej. Generalnie chodzi o podział sieci
na kilka mniejszych podsieci i oddzielenie ich od siebie fizycznie lub logicznie. &lt;a href=&#34;https://wiki.openwrt.org/doc/howto/dmz&#34;&gt;W OpenWRT możemy
wydzielić taką strefę DMZ przy pomocy VLAN&#39;ów&lt;/a&gt;. Z kolei
odpowiednio skonfigurowany firewall odseparuje nam tę strefę od pozostałych maszyn pracujących w
sieci LAN. W taki sposób nawet w przypadku włamania mającego miejsce w strefie DMZ, maszyny w
pozostałych segmentach sieci będą bezpieczne. W tym wpisie postaramy się skonfigurować strefę
zdemilitaryzowaną na routerze wyposażonym w firmware OpenWRT.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak wyczyścić tablicę conntrack&#39;a w debianie</title>
      <link>https://morfikov.github.io/post/jak-wyczyscic-tablice-conntrack-w-debianie/</link>
      <pubDate>Sun, 05 Jun 2016 12:34:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wyczyscic-tablice-conntrack-w-debianie/</guid>
      <description>&lt;p&gt;Sporo użytkowników lunux&#39;a, zwłaszcza dystrybucji debian, korzysta z własnych skryptów firewall&#39;a
aplikujących reguły &lt;code&gt;iptables&lt;/code&gt; . Tego typu rozwiązanie ma jednak swoje wady i zalety. Niewątpliwie
do zalet można zaliczyć brak dodatkowego oprogramowania obsługującego zaporę sieciową. Jeśli chodzi
zaś o wady, to niestety cały skrypt trzeba sobie dobrze przemyśleć przed zaaplikowaniem. Ludzie
często zapominają tutaj o śledzeniu połączeń przez kernel. To właśnie na podstawie wpisów w
&lt;code&gt;/proc/net/ip_conntrack&lt;/code&gt; lub &lt;code&gt;/proc/net/nf_conntrack&lt;/code&gt; system wie, które pakiety należy na zaporze
przepuścić, a które zablokować. Jeśli teraz dodajemy reguły do filtra &lt;code&gt;iptables&lt;/code&gt; , to nowa polityka
zapory nie będzie odnosić się do tych nawiązanych już połączeń, które są określone w tablicy
conntrack&#39;a. By się upewnić, że tego typu scenariusz nigdy nas nie spotka, musimy tę tablicę
opróżnić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Rkhunter jako ochrona przed rootkit&#39;ami</title>
      <link>https://morfikov.github.io/post/rkhunter-jako-ochrona-przed-rootkitami/</link>
      <pubDate>Tue, 08 Mar 2016 15:42:59 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/rkhunter-jako-ochrona-przed-rootkitami/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Rootkit&#34;&gt;Rootkit&lt;/a&gt; to takie ustrojstwo, które jest w stanie przebywać niepostrzeżenie w naszym systemie
przez bardzo długi czas. Dzieje się tak ze względu na uśpioną czujność administratora. Teoretycznie
wszystko jest w należytym porządku, nie widać żadnych złowrogich procesów, a szereg narzędzi, które
mają przeciwdziałać rootkit&#39;om, nie zwraca żadnych ostrzeżeń o ewentualnych próbach naruszenia
bezpieczeństwa systemu operacyjnego. Taki rootkit jest w stanie całkowicie przejąc kontrolę nad
linux&#39;em i np. może decydować o tym jakie procesy zostaną nam pokazane, a jakie ukryte. W świetle
takiego zagrożenia, linux&#39;y wypracowały sobie pewne mechanizmy obronne. W tym wpisie przebadamy
sobie jeden z projektów, tj. &lt;a href=&#34;http://rkhunter.sourceforge.net/&#34;&gt;rkhunter&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Ukrywanie informacji w plikach (steganografia)</title>
      <link>https://morfikov.github.io/post/ukrywanie-informacji-w-plikach-steganografia/</link>
      <pubDate>Thu, 21 Jan 2016 21:49:23 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ukrywanie-informacji-w-plikach-steganografia/</guid>
      <description>&lt;p&gt;Jak możemy wyczytać na wikipedii, &lt;a href=&#34;https://pl.wikipedia.org/wiki/Steganografia&#34;&gt;steganografia&lt;/a&gt; to
nauka, która ma na celu ukrycie faktu prowadzenia komunikacji. Odróżnia ją to nieco od kryptografii,
gdzie wiadomość jest wprawdzie nieczytelna ale wiadome jest, że dokonywana jest wymiana informacji
między dwoma punktami. W przypadku steganografii możemy ukryć pewną informację, np. w pliku
graficznym maskując tym samym cały proces przekazywania danych. W taki sposób osoba, która nie ma
pojęcia o fakcie ukrycia informacji, zobaczymy jedynie zwykły obrazek. Poniższy wpis ma na celu
sprawdzenie jak skuteczna jest ta metoda i czy nadaje się do zastosowania dla przeciętnego zjadacza
chleba.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Nagłówek kontenera LUKS trzymany na pendrive</title>
      <link>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</link>
      <pubDate>Fri, 15 Jan 2016 20:28:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</guid>
      <description>&lt;p&gt;Jeśli kiedyś rozważaliśmy &lt;a href=&#34;https://morfikov.github.io/post/keyfile-trzymany-w-glebokim-ukryciu/&#34;&gt;umieszczenie pliku klucza (keyfile) do zaszyfrowanego kontenera LUKS na
pendrive&lt;/a&gt;, to ciekawszą alternatywą
może okazać się umieszczenie całego nagłówka takiego kontenera na zewnętrznym nośniku. Ma to tę
przewagę nad keyfile, że wszystkie informacje zapewniające dostęp do kontenera, wliczając w to klucz
główny, są oddzielone od zaszyfrowanych danych. W ten sposób nawet jeśli kontener wpadnie w
niepowołane ręce, to nie ma żadnego sposobu na to, by ten ktoś te dane odzyskał, no bo przecie nie
ma klucza szyfrującego. Przechwycenie hasła również nic to nie zmieni, no chyba, że ten ktoś
zdobędzie również pendrive z nagłówkiem kontenera. Z ludzkiego punktu widzenia, to na takim dysku
będą znajdować się jedynie losowymi dane i do tego w formie kompletnie nieczytelnej dla człowieka
(brak systemu plików). Niemniej jednak, jest kilka rzeczy, o których warto pamiętać, gdy w grę
wchodzi nagłówek LUKS i to o nich porozmawiamy sobie w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Odszyfrowanie kontenerów LUKS w systemd</title>
      <link>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</link>
      <pubDate>Fri, 01 Jan 2016 17:18:03 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</guid>
      <description>&lt;p&gt;Osoby, które wykorzystują pełne szyfrowanie dysku, wiedzą, że nie zawsze da radę tak skonfigurować
swój system, by upchnąć go na jednej partycji. Nawet jeśli korzystamy z LVM wewnątrz kontenera LUKS,
to i tak zwykle możemy posiadać inne zaszyfrowane partycje, które są odrębną całością i montowane
osobno przy starcie systemu. W takim przypadku zwykle jesteśmy zmuszeni do podawania hasła do
każdego z tych dysków z osobna, co zajmuje czas. Ten problem opisałem po części przy okazji
&lt;a href=&#34;https://morfikov.github.io/post/dropbox-i-kontener-luks/&#34;&gt;implementacji kontenera LUKS na potrzeby
Dropbox&#39;a&lt;/a&gt;, jak i we wpisie poświęconym &lt;a href=&#34;https://morfikov.github.io/post/przejscie-z-truecrypt-na-luks/&#34;&gt;przejściu
z kontenerów TrueCrypt&#39;a na te linux&#39;owe, które są wspierane natywnie przez sam
kernel&lt;/a&gt;. Niemniej jednak, tamto rozwiązanie
było oparte głównie o starszy init (sysvinit), co wymagało dodatkowej konfiguracji, tak by system
otworzył się po podaniu tylko jednego hasła. W tym wpisie postaramy się wdrożyć mechanizm, który
jest oferowany przez systemd.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Profil AppArmor&#39;a i jego dokładna budowa</title>
      <link>https://morfikov.github.io/post/profil-apparmora-i-jego-dokladna-budowa/</link>
      <pubDate>Tue, 01 Dec 2015 17:57:39 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/profil-apparmora-i-jego-dokladna-budowa/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io/post/apparmor-profilowanie-aplikacji/&#34;&gt;Budowanie samych profili dla AppArmor&#39;a&lt;/a&gt;
nie jest jakoś szczególnie trudne, zwłaszcza, gdy do tego celu wykorzystujemy narzędzia dostępne w
pakiecie &lt;code&gt;apparmor-utils&lt;/code&gt; . Dobrze jest jednak prześledzić sobie
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/xenial/en/man5/apparmor.d.5.html&#34;&gt;manual&lt;/a&gt;
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/xenial/en/man7/apparmor.7.html&#34;&gt;AppArmor&#39;a&lt;/a&gt; oraz to, co twórcy
piszą na swojej stronie w &lt;a href=&#34;http://wiki.apparmor.net/index.php/Documentation&#34;&gt;oficjalnej
dokumentacji&lt;/a&gt; projektu. Poniższy wpis powstał w
celu zrozumienia składni profili AppArmor&#39;a, tak by jeszcze bardziej uprościć proces ich budowania.&lt;/p&gt;
&lt;p&gt;Opis składni znajdujący się poniżej został zaczerpnięty z
&lt;a href=&#34;http://wiki.apparmor.net/index.php/QuickProfileLanguage&#34;&gt;wiki&lt;/a&gt;
&lt;a href=&#34;http://wiki.apparmor.net/index.php/AppArmor_Core_Policy_Reference&#34;&gt;AppArmor&#39;a&lt;/a&gt;. Część z poniższych
informacji może nie mieć zastosowania w przypadku starszych wersji samego AppArmor&#39;a.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Programowe i sprzętowe zerowanie dysku</title>
      <link>https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/</link>
      <pubDate>Tue, 24 Nov 2015 17:54:17 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/</guid>
      <description>&lt;p&gt;Zerowanie dysku twardego ma na celu usunięcie wszystkich znajdujących się na nim danych. Generalnie
chodzi o zapisanie całej powierzchni danego nośnika samymi zerami. Ten proces różni się znacząco of
formatowania dysku, czyli utworzenia nowego systemu plików, gdzie praktycznie wszystkie dane można
bez większego problemu odzyskać. Zerowanie dysku (czy też pendrive) może w pewnych przypadkach
&lt;a href=&#34;https://morfikov.github.io/post/uszkodzony-sektor-na-dysku-i-jego-realokacja/&#34;&gt;naprawić logiczne błędy sektorów&lt;/a&gt; na dysku. Niemniej jednak, nie usuniemy za jego pomocą
fizycznych bad&#39;ów. Generalnie rzecz biorąc, mamy do wyboru dwie techniki zerowania. Jedna jest
dokonywana na poziomie programowym, np. przy pomocy &lt;code&gt;dd&lt;/code&gt; , druga zaś na poziomie sprzętowym, np. w
&lt;code&gt;hdparm&lt;/code&gt; . W tym wpisie postaramy się wyzerować przykładowy dysk.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Integralność plików passwd, group, shadow, gshadow</title>
      <link>https://morfikov.github.io/post/integralnosc-plikow-passwd-group-shadow-gshadow/</link>
      <pubDate>Tue, 24 Nov 2015 12:30:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/integralnosc-plikow-passwd-group-shadow-gshadow/</guid>
      <description>&lt;p&gt;W pliku &lt;code&gt;/etc/passwd&lt;/code&gt; jest przechowywana baza danych kont użytkowników w systemie linux. Z kolei w
&lt;code&gt;/etc/group&lt;/code&gt; mamy wypisane wszystkie grupy oraz powiązanych z nimi użytkowników. Generalnie rzecz
biorąc, to te dwa pliki odpowiadają za konfigurację kont. Problem jednak zaczyna się w momencie gdy
w grę wchodzą hasła, zarówno do kont jak i do grup. Gdyby były one trzymane w tych plikach, nie
byłyby one w żaden sposób szyfrowane. Dlatego też powstał inny mechanizm, który ma na celu
przeniesienie zahashowanych haseł do plików &lt;code&gt;/etc/shadow&lt;/code&gt; i &lt;code&gt;/etc/gshadow&lt;/code&gt; . W debianie
użytkownikami i grupami możemy zarządzać przy pomocy odpowiednich narzędzi, które automatycznie
dostosują wszystkie powyższe pliki. Nic jednak nie stoi na przeszkodzie aby edytować każdy z nich
ręcznie. Problemy mogą się pojawić w momencie, gdy te pliki będą zawierać różne wpisy, np. w pliku
&lt;code&gt;passwd&lt;/code&gt; będzie określony użytkownik, który jednocześnie nie będzie istniał w pliku &lt;code&gt;shadow&lt;/code&gt; ,
podobnie z grupami. W tym wpisie postaramy się sprawdzić te pliki i upewnimy się czy aby na pewno
jest z nimi wszystko w porządku.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czy zmiana nazwy użytkownika root ma sens?</title>
      <link>https://morfikov.github.io/post/czy-zmiana-nazwy-uzytkownika-root-ma-sens/</link>
      <pubDate>Sat, 21 Nov 2015 19:52:58 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-zmiana-nazwy-uzytkownika-root-ma-sens/</guid>
      <description>&lt;p&gt;Wielu ludzi potrafi się rozpisywać na temat bezpieczeństwa systemu linux jednocześnie nie zauważając
jednego bardzo poważnego problemu. Wszyscy wiemy, że linux&#39;y są bezpieczne min. przez fakt
rozgraniczenia konta administratora od konta zwykłego użytkownika i nadaniu im różnych praw dostępu
do poszczególnych części systemu operacyjnego. O ile konta użytkowników mają różne nazwy, o tyle
administrator w praktycznie każdym linux&#39;ie kryje się pod nazwą &lt;code&gt;root&lt;/code&gt; . Znając nazwę konta, można
próbować złamać hasło. To trochę dziwne, że nie można sobie arbitralnie ustalić nazwy dla tego konta
tak by uniknąć wszelkich ataków, które związane są z logowaniem się na określonego użytkownika w
systemie. W tym wpisie postaramy się prześledzić całą procedurę zmiany nazwy konta &lt;code&gt;root&lt;/code&gt; na jakąś
dowolną i zobaczymy czy wpłynie to w jakimś stopniu na pracę naszego systemu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Uprawnienia do plików systemowych w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/uprawnienia-do-plikow-systemowych-w-linuxie/</link>
      <pubDate>Mon, 16 Nov 2015 12:34:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/uprawnienia-do-plikow-systemowych-w-linuxie/</guid>
      <description>&lt;p&gt;Każdy z nas popełnia błędy. Niektóre z nich są błahe i w sporej części łatwe do poprawienia. Zwykle
też nie niosą one ze sobą większych konsekwencji. Natomiast błędy, które popełniamy podczas pracy w
systemie operacyjnym wykonując różne prace administracyjne mogą nas czasem słono kosztować. W
linux&#39;ach ogromną rolę odgrywają prawa do plików. O ile root ma dostęp do wszystkich plików, to w
przypadku zwykłych użytkowników (czy tez usług systemowych) już tak nie jest. Przypadkowa zmiana
tych uprawnień może zaowocować problemami związanymi z bezpieczeństwem takiego systemu, a w
niektórych przypadkach może nawet uniemożliwić jego start. Na necie kilka razy obił mi się o oczy
temat, gdzie ludzie przez przypadek (lub też &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=27876&#34;&gt;całkiem
świadomie&lt;/a&gt;) zmienili masowo uprawnienia w takich
katalogach jak &lt;code&gt;/usr/&lt;/code&gt; czy &lt;code&gt;/etc/&lt;/code&gt; . Powiem nawet więcej, mi się raz taka sytuacja kiedyś
przytrafiła. Co w takim przypadku można zrobić? Czy jedyną opcją, jaka nam pozostaje, to ponowna
instalacja sytemu? Na szczęście nie, bo uprawnienia do plików możemy sobie zwyczajnie spisać i
odtworzyć je w późniejszym czasie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kiedy uruchomiony proces wymaga restartu</title>
      <link>https://morfikov.github.io/post/kiedy-uruchomiony-proces-wymaga-restartu/</link>
      <pubDate>Fri, 13 Nov 2015 14:22:21 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kiedy-uruchomiony-proces-wymaga-restartu/</guid>
      <description>&lt;p&gt;Linux słynie z tego, że nie są wymagane w nim częste restarty całego systemu operacyjnego. Nie ma
przy tym znaczenia czy aktualizujemy jakieś oprogramowanie, czy też wgrywamy nową wersję kernela.
Jeśli by to przenieść na środowisko windowsa, to tam system jest w stanie się automatycznie
zresetować kilka razy tylko podczas samego procesu aktualizacji. Można zatem kwestionować zasadność
twierdzenia, że linux nie wymaga restartu. Może nie koniecznie jesteśmy zmuszeni do dokonania
restartu w danej chwili, tak jak to ma miejsce w przypadku windowsa, ale czy aby na pewno po
instalacji jakichś pakietów w systemie, każdy proces powinien w dalszym ciągu działać bez restartu?
Na to pytanie postaramy się odpowiedzieć w tym wpisie.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
