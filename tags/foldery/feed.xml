<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>foldery on Morfitronik</title>
    <link>https://morfikov.github.io/tags/foldery/</link>
    <description>Recent content in foldery on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Thu, 09 Jun 2016 12:44:12 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/foldery/feed.xml" rel="self" type="application/rss+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak odszukać pliki utworzone godzinę temu (find)</title>
      <link>https://morfikov.github.io/post/jak-odszukac-pliki-utworzone-godzine-temu-find/</link>
      <pubDate>Thu, 09 Jun 2016 12:44:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-odszukac-pliki-utworzone-godzine-temu-find/</guid>
      <description>&lt;p&gt;W linux&#39;ie wszystko może być reprezentowane za pomocą pliku. Te pliki są tworzone, zmieniane i
usuwane praktycznie non stop podczas pracy systemu operacyjnego. Zwykle też nie zwracamy uwagi na
metadane opisujące pliki w systemie plików, bo przecie bardziej interesuje nas ich zawartość.
Niemniej jednak, w pewnych sytuacjach te metadane mogą się okazać bardzo użyteczne. Weźmy sobie
przykład partycji &lt;code&gt;/home/&lt;/code&gt; . Prawie zawsze po odpaleniu aplikacji są tworzone na niej nowe pliki lub
zmieniane te już istniejące. Jako, że nie zawsze wiemy na jakich plikach operuje dany program, to
moglibyśmy przeszukać pliki w katalogu domowym użytkownika i poddać analizie ich czas modyfikacji.
Taką operacje możemy przeprowadzić przy pomocy polecenia &lt;code&gt;find&lt;/code&gt; i w tym wpisie zobaczymy jak tego
dokonać.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Data i czas utworzenia pliku w linux&#39;ie (crtime)</title>
      <link>https://morfikov.github.io/post/data-czas-utworzenia-pliku-w-linuxie-crtime/</link>
      <pubDate>Tue, 07 Jun 2016 17:07:54 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/data-czas-utworzenia-pliku-w-linuxie-crtime/</guid>
      <description>&lt;p&gt;Systemy plików, które wykorzystujemy na partycjach swoich dysków, zawierają metadane opisujące
pliki. Domyślnym systemem plików w większości linux&#39;ów (do nich zalicza się też debian) jest EXT4.
Gdy listujemy pliki przy pomocy narzędzia &lt;code&gt;ls&lt;/code&gt; , jesteśmy w stanie uzyskać szereg informacji
opisujących konkretny plik. Mamy tam min. czas ostatniej modyfikacji i-węzła (i-node), czyli tzw.
&lt;code&gt;ctime&lt;/code&gt; . Narzędzia takie jak &lt;code&gt;stat&lt;/code&gt; są w stanie podać również inne czasy, tj. &lt;code&gt;atime&lt;/code&gt; (ostatni czas
dostępu do pliku) oraz &lt;code&gt;mtime&lt;/code&gt; (ostatni czas modyfikacji pliku). Jednak żaden z tych powyższych nie
przekłada się na czas utworzenia pliku. Co prawda, po stworzeniu pliku, wszystkie te czasy są ze
sobą zsynchronizowane ale po przeprowadzeniu szeregu różnych operacji na tym pliku, problematyczne
może być ustalenie pierwotnej daty jego utworzenia. Celem tego artykułu jest pokazanie, jak przy
pomocy &lt;code&gt;debugfs&lt;/code&gt; uzyskać czas utworzenia dowolnie wskazanego pliku w systemie plików EXT4.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Sparse files (rozrzedzone pliki)</title>
      <link>https://morfikov.github.io/post/sparse-files-rozrzedzone-pliki/</link>
      <pubDate>Thu, 02 Jun 2016 16:42:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/sparse-files-rozrzedzone-pliki/</guid>
      <description>&lt;p&gt;Każdy system plików opiera się na blokach danych. Standardowo taki blok w systemie plików EXT4 ma 4
KiB (8 x 512 bajtów). Za każdym razem, gdy tworzymy jakiś plik na dysku, alokowana jest pewna część
bloków, na których ten plik ma zostać zapisany. Te większe pliki rezerwują więcej bloków, choć nie
zawsze są to bloki ciągłe. W taki sposób, plik o rozmiarze 10 GiB okupowałby dokładnie tyle miejsca
na dysku ile sam waży. Niemniej jednak są pewne pliki, które może i ważą te 10 GiB ale system plików
postrzega je tak jakby miały 100 MiB czy 200 MiB, w zależności od tego ile &amp;quot;faktycznie&amp;quot; taki plik
zajmuje miejsca. Jak to możliwe? Pliki, o których mowa, to tzw. &amp;quot;rozrzedzone pliki&amp;quot; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Sparse_file&#34;&gt;Sparse
files&lt;/a&gt;). Taki plik składa się z szeregu bloków pustych
(mających same zera), których nie trzeba zapisywać na dysk. Zamiast tego, można jedynie zapisać
metadane w strykturze systemu plików, które będą opisywać te puste bloki. Poniższy artykuł ma na
celu pokazać do czego takie pliki sparse mogą nam się przydać i jak z nich korzystać.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Ukrywanie informacji w plikach (steganografia)</title>
      <link>https://morfikov.github.io/post/ukrywanie-informacji-w-plikach-steganografia/</link>
      <pubDate>Thu, 21 Jan 2016 21:49:23 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ukrywanie-informacji-w-plikach-steganografia/</guid>
      <description>&lt;p&gt;Jak możemy wyczytać na wikipedii, &lt;a href=&#34;https://pl.wikipedia.org/wiki/Steganografia&#34;&gt;steganografia&lt;/a&gt; to
nauka, która ma na celu ukrycie faktu prowadzenia komunikacji. Odróżnia ją to nieco od kryptografii,
gdzie wiadomość jest wprawdzie nieczytelna ale wiadome jest, że dokonywana jest wymiana informacji
między dwoma punktami. W przypadku steganografii możemy ukryć pewną informację, np. w pliku
graficznym maskując tym samym cały proces przekazywania danych. W taki sposób osoba, która nie ma
pojęcia o fakcie ukrycia informacji, zobaczymy jedynie zwykły obrazek. Poniższy wpis ma na celu
sprawdzenie jak skuteczna jest ta metoda i czy nadaje się do zastosowania dla przeciętnego zjadacza
chleba.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Metadane plików graficznych (EXIF)</title>
      <link>https://morfikov.github.io/post/metadane-plikow-graficznych-exif/</link>
      <pubDate>Thu, 21 Jan 2016 16:58:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/metadane-plikow-graficznych-exif/</guid>
      <description>&lt;p&gt;Każdy plik posiada szereg opisujących go atrybutów. Możemy się o tym przekonać wykorzystując
narzędzia &lt;code&gt;ls&lt;/code&gt; lub &lt;code&gt;stat&lt;/code&gt; . W ich przypadku zostaną nam zwrócone takie informacje jak rozmiar
pliku, data modyfikacji czy też prawa dostępu. To właśnie są metadane opisujące pliki w obszarze
systemu plików i są one wymagane, by system operacyjny działał prawidłowo. To jednak nie jedyne
metadane, z którymi spotykamy się na co dzień. Najlepszym przykładem są zdjęcia czy filmy robione
smartfonami czy też aparatami lub kamerami cyfrowymi. Każdy plik stworzony za pomocą tych urządzeń
zawiera w sobie bardzo rozbudowane informacje, które nie zawsze chcielibyśmy udostępniać. W tym
wpisie skupimy się głównie na &lt;a href=&#34;https://pl.wikipedia.org/wiki/Exchangeable_Image_File_Format&#34;&gt;danych
EXIF&lt;/a&gt; zawartych w plikach graficznych,
które postaramy się wydobyć, zmienić i usunąć.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Domyślne aplikacje w oparciu o typy plików (MIME)</title>
      <link>https://morfikov.github.io/post/domyslne-aplikacje-w-oparciu-o-typy-plikow-mime/</link>
      <pubDate>Tue, 12 Jan 2016 20:18:33 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/domyslne-aplikacje-w-oparciu-o-typy-plikow-mime/</guid>
      <description>&lt;p&gt;Pełne środowiska graficzne zwykle oferują odpowiednie narzędzia, które mogą posłużyć skonfigurowaniu
domyślnych aplikacji. Jesteśmy zatem w stanie bardzo prosto przypisać szereg &lt;a href=&#34;https://pl.wikipedia.org/wiki/Typ_MIME&#34;&gt;typów MIME&lt;/a&gt; do
odpowiednich programów. Wobec takiego stanu rzeczy, przy próbie uruchomienia jakiegoś pliku, ten
zostanie odpalony przez konkretną aplikację. Niemniej jednak, jeśli chodzi o środowiska graficzne
oparte o menadżery okien, np. Openbox, to na dobrą sprawę mamy bardzo małe pole manewru.
Niezależnie czy korzystamy z GNOME, KDE, XFCE, MATE czy też Openbox&#39;a, wszystkie z nich
wykorzystują dokładnie ten sam mechanizm wiązania aplikacji z typami plików. Możemy zatem ominąć te
wszystkie graficzne nakładki i ręcznie skonfigurować sobie typy MIME, tak by działały niezależnie
od wykorzystywanego środowiska graficznego. W tym wpisie spróbujemy przyjrzeć się nieco bliżej
konfiguracji tego całego mechanizmu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak odzyskać usunięte z dysku pliki</title>
      <link>https://morfikov.github.io/post/jak-odzyskac-usuniete-z-dysku-pliki/</link>
      <pubDate>Mon, 30 Nov 2015 19:03:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-odzyskac-usuniete-z-dysku-pliki/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/&#34;&gt;Całkowite usuwanie plików (shred)&lt;/a&gt; jak i
&lt;a href=&#34;https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/&#34;&gt;zerowanie całych nośników&lt;/a&gt; ma na celu
nieodwracalne zniszczenie danych. W tych podlinkowanych artykułach próbowaliśmy zatrzeć ślady po
skasowanych plikach. W tym wpisie zaś prześledzimy sobie co tak naprawdę się dzieje po utworzeniu i
skasowaniu pliku, a także spróbujemy odzyskać te z nich, które już nie istnieją w naszym systemie.
Ten artykuł będzie dotyczył jedynie systemu plików z rodziny &lt;code&gt;ext&lt;/code&gt; , głównie &lt;code&gt;ext4&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kodowanie nazw plików i jego zmiana</title>
      <link>https://morfikov.github.io/post/kodowanie-nazw-plikow-i-jego-zmiana/</link>
      <pubDate>Fri, 27 Nov 2015 15:15:45 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kodowanie-nazw-plikow-i-jego-zmiana/</guid>
      <description>&lt;p&gt;Chciałem dziś wypakować sobie kilka plików, które były zebrane w paczkę &lt;code&gt;.zip&lt;/code&gt; . Problem w tym, że
ta osoba, co te pliki pakowała, najwyraźniej robiła to na widnowsie no i nie użyła standardowego
kodowania, które jest wykorzystywane na każdym innym systemie, tj. UTF-8. Wobec tego, wszystkie
pliki mają w swoich nazwach znaczek &lt;code&gt;�&lt;/code&gt; w miejscu polskich liter. Jako, że tych plików jest dość
dużo, to odpada ręczna edycja nazw i trzeba pomyśleć nad jakimś innym rozwiązaniem. Zmiana
kodowania nazw plików, to nie jest to samo co &lt;a href=&#34;https://morfikov.github.io/post/zmiana-kodowania-znakow-w-plikach-na-utf-8/&#34;&gt;zmiana kodowania zawartości tych
plików&lt;/a&gt;. Na szczęście w
linux&#39;ie mamy do dyspozycji narzędzie &lt;code&gt;convmv&lt;/code&gt; , które jest w stanie, jak sama nazwa mówi, przepisać
nazwy plików ustawiając przy tym odpowiednie kodowanie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Całkowite usuwanie plików przy pomocy shred</title>
      <link>https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/</link>
      <pubDate>Tue, 24 Nov 2015 15:11:32 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/</guid>
      <description>&lt;p&gt;W przypadku, gdy musimy pozbyć się jakiegoś pliku, który znajduje się na dysku, to nie jest zalecane
korzystanie z narzędzia &lt;code&gt;rm&lt;/code&gt; . Usuwa ono jedynie odnośnik do pliku, który go identyfikuje w
strukturze systemu plików, tzw. &lt;a href=&#34;https://pl.wikipedia.org/wiki/I-w%C4%99ze%C5%82&#34;&gt;i-węzeł&lt;/a&gt; (i-node).
To co uzyskujemy za pomocą takich narzędzi jak &lt;code&gt;rm&lt;/code&gt; , to jedynie oznaczenie pewnych bloków (tych od
pliku) jako wolne, w których system operacyjny będzie w stanie dokonać zapisu danych późniejszym
czasie. Podczas tej operacji nie są usuwane żadne informacje z dysku, a mając na uwadze ten fakt,
możemy bez problemu tak &amp;quot;usunięty&amp;quot; plik odzyskać. By mieć pewność, że plik zostanie trwale
zniszczony, trzeba go ponownie napisać, np. przy pomocy
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/wily/en/man1/shred.1.html&#34;&gt;shred&lt;/a&gt;, który standardowo jest
dostępny w każdej dystrybucji linux&#39;a i to jemu będzie poświęcony ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Uprawnienia do plików systemowych w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/uprawnienia-do-plikow-systemowych-w-linuxie/</link>
      <pubDate>Mon, 16 Nov 2015 12:34:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/uprawnienia-do-plikow-systemowych-w-linuxie/</guid>
      <description>&lt;p&gt;Każdy z nas popełnia błędy. Niektóre z nich są błahe i w sporej części łatwe do poprawienia. Zwykle
też nie niosą one ze sobą większych konsekwencji. Natomiast błędy, które popełniamy podczas pracy w
systemie operacyjnym wykonując różne prace administracyjne mogą nas czasem słono kosztować. W
linux&#39;ach ogromną rolę odgrywają prawa do plików. O ile root ma dostęp do wszystkich plików, to w
przypadku zwykłych użytkowników (czy tez usług systemowych) już tak nie jest. Przypadkowa zmiana
tych uprawnień może zaowocować problemami związanymi z bezpieczeństwem takiego systemu, a w
niektórych przypadkach może nawet uniemożliwić jego start. Na necie kilka razy obił mi się o oczy
temat, gdzie ludzie przez przypadek (lub też &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=27876&#34;&gt;całkiem
świadomie&lt;/a&gt;) zmienili masowo uprawnienia w takich
katalogach jak &lt;code&gt;/usr/&lt;/code&gt; czy &lt;code&gt;/etc/&lt;/code&gt; . Powiem nawet więcej, mi się raz taka sytuacja kiedyś
przytrafiła. Co w takim przypadku można zrobić? Czy jedyną opcją, jaka nam pozostaje, to ponowna
instalacja sytemu? Na szczęście nie, bo uprawnienia do plików możemy sobie zwyczajnie spisać i
odtworzyć je w późniejszym czasie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana kodowania znaków w plikach na UTF-8</title>
      <link>https://morfikov.github.io/post/zmiana-kodowania-znakow-w-plikach-na-utf-8/</link>
      <pubDate>Fri, 13 Nov 2015 16:18:56 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-kodowania-znakow-w-plikach-na-utf-8/</guid>
      <description>&lt;p&gt;Pliki tekstowe w linux&#39;ie są zakodowane w &lt;a href=&#34;https://www.cl.cam.ac.uk/~mgk25/unicode.html&#34;&gt;formacie
UTF-8&lt;/a&gt;. Ta cyfra &lt;code&gt;8&lt;/code&gt; może być jednak myląca, bo ilość
bajtów potrzebnych do zakodowania pojedynczego znaku może się różnić i wynosi od 1 do 4. Tak czy
inaczej, środowiska linux&#39;owe już dawno zaimplementowały obsługę tego systemu kodowania i uczyniły
go sobie domyślnym. Są jednak takie systemy operacyjne, które nie wykorzystują domyślnie UTF-8 do
kodowania tekstu. Wobec czego, gdy spróbujemy otworzyć w edytorze taki plik, to w pewnych miejscach
będziemy mieli krzaczki, zwykle tam gdzie są polskie znaki. To zjawisko jest bardzo
charakterystyczne dla napisów w filmach. Niemniej jednak, zarówno edytory tekstu jak i player&#39;y
video są w stanie dokonać automatycznego doboru systemu kodowania i zwrócić nam czytelny plik. Nie
zawsze jednak tak robią. Zamiast bawić się w tego typu automatyczne wynalazki, dużo lepszym
rozwiązaniem jest zmiana kodowania plików, tak by przekonwertować je do formatu UTF-8 i w tym
wpisie postaramy się to zrobić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Dzielenie i łączenie pliku mp3</title>
      <link>https://morfikov.github.io/post/dzielenie-i-laczenie-pliku-mp3/</link>
      <pubDate>Fri, 13 Nov 2015 13:03:57 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dzielenie-i-laczenie-pliku-mp3/</guid>
      <description>&lt;p&gt;Każdy z nas odsłuchuje czasem pliki &lt;code&gt;.mp3&lt;/code&gt; . Niekoniecznie musi to być muzyka, np. mogą być to
audycje radiowe, czy też inne materiały audio. W przypadku dłuższych nagrań problematyczne może być
odnalezienie w nich tego kawałka, który akurat chcielibyśmy ponownie odsłuchać. Podobnie sprawa ma
się w przypadku, gdy dany materiał chcemy komuś przesłać. Jeśli ślemy całe nagranie, to musimy dodać
informację od którego momentu zaczyna się coś dziać w tym utworze. Nie prościej wyciąć ten
interesujący nas kawałek i zapisać go w osobnym pliku?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Ostatnio używane pliki (recently-used.xbel)</title>
      <link>https://morfikov.github.io/post/ostatnio-uzywane-pliki-recently-used-xbel/</link>
      <pubDate>Mon, 02 Nov 2015 23:54:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ostatnio-uzywane-pliki-recently-used-xbel/</guid>
      <description>&lt;p&gt;Wielu ludzi nie lubi gdy maszyny monitorują każdy ich krok. W tym przypadku chodzi o pliki, które
otwieramy czy zmieniamy podczas codziennej pracy na komputerze. Nasz system domyślnie tworzy listę i
skrupulatnie dodaje do niej nowe pozycje. Ta lista jest przechowywana w pliku &lt;code&gt;recently-used.xbel&lt;/code&gt; ,
który znajduje się w katalogu &lt;code&gt;~/.local/share/&lt;/code&gt; . Gdy popatrzymy na tę funkcjonalność trochę pod
inny kątem, możemy zauważyć, że w pewnych sytuacjach zagraża ona naszej prywatności. Skasowanie tego
pliku nie rozwiązuje problemu, bo jest on tworzony na nowo, a nadawanie atrybutu odporności (
&lt;code&gt;chattr +i&lt;/code&gt; ) nie jest żadnym rozwiązaniem. Na szczęście jest sposób na to by ten mechanizm
dezaktywować i o tym będzie poniższy wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Struktura plików urządzeń usb w katalogu /sys/</title>
      <link>https://morfikov.github.io/post/struktura-plikow-urzadzen-usb-w-katalogu-sys/</link>
      <pubDate>Tue, 23 Jun 2015 20:23:09 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/struktura-plikow-urzadzen-usb-w-katalogu-sys/</guid>
      <description>&lt;p&gt;Jeśli próbowaliśmy odnaleźć odpowiednią ścieżkę do urządzenia usb w linuxowym drzewie katalogów, to
wiemy, że nie jest to łatwe zadanie. Mamy, co prawda, do dyspozycji polecenie &lt;code&gt;lsusb&lt;/code&gt; ale ono nie
daje nam precyzyjnych informacji na temat tego gdzie dokładnie w katalogu &lt;code&gt;/sys/&lt;/code&gt; znajdują się
określone urządzenia. Na necie natrafiłem na &lt;a href=&#34;http://www.linux-usb.org/&#34;&gt;FAQ&lt;/a&gt; dotyczący tego zagadnienia i postanowiłem
napisać kilka zdań o tym jak zinterpretować ciągi typu &lt;code&gt;2-1.1.2:1.1&lt;/code&gt; oraz jakie to może być
urządzenie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>ECryptfs jako alternatywa dla encfs</title>
      <link>https://morfikov.github.io/post/ecryptfs-jako-alternatywa-dla-encfs/</link>
      <pubDate>Mon, 22 Jun 2015 18:58:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ecryptfs-jako-alternatywa-dla-encfs/</guid>
      <description>&lt;p&gt;Dnia 2014-10-07 w Debianie była aktualizacja pakietu &lt;code&gt;encfs&lt;/code&gt; , która to zawierała informację na
temat &lt;a href=&#34;https://defuse.ca/audits/encfs.htm&#34;&gt;audytu bezpieczeństwa&lt;/a&gt; jaki się dokonał parę miesięcy wstecz. Wyniki niezbyt dobrze
wypadły, a nawet można powiedzieć, że wręcz katastrofalnie. Generalnie cały test został skwitowany
słowami, że jeśli szyfrujemy pliki przy pomocy tego narzędzia, to jesteśmy relatywnie bezpieczni,
nawet w przypadku jeśli ktoś te pliki przechwyci. Natomiast jeśli zaczniemy zmieniać/dodawać pliki
i ten ktoś ponownie przechwyci nasz zaszyfrowany katalog, wtedy może on bez problemu odszyfrować
całą jego zawartość. Jeśli wykorzystujemy &lt;code&gt;encfs&lt;/code&gt; lokalnie, to być może nam nic nie grozi, nawet w
przypadku raidu NSA na naszą chałupę. Problem w tym, że ogromna rzesza ludzi wykorzystuje &lt;code&gt;encfs&lt;/code&gt;
do zaszyfrowania plików w chmurze, np. na Dropbox&#39;ie czy MEGA, a jak wiadomo, przy każdej
synchronizacji, zmiany w danym katalogu są przesyłane do chmury i wszelkie zabezpieczenie jakie
daje &lt;code&gt;encfs&lt;/code&gt; diabli biorą. Może najwyższy czas zainteresować się &lt;code&gt;ecryptfs&lt;/code&gt;?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Dzielenie pliku i łączenie jego części w całość</title>
      <link>https://morfikov.github.io/post/dzielenie-pliku-i-laczenie-jego-czesci-w-calosc/</link>
      <pubDate>Fri, 19 Jun 2015 13:24:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dzielenie-pliku-i-laczenie-jego-czesci-w-calosc/</guid>
      <description>&lt;p&gt;Obecnie technika podziału jednego pliku na szereg mniejszych nie jest już tak szeroko stosowana jak
parę lat temu gdy internet dopiero zaczynał pojawiać się w naszych domach. Głównym powodem jest
postęp technologii i dziś już mało kto posiada łącza 128Kbit/s, wobec czego przesłanie pliku, który
waży nawet kilka GiB nie jest niczym niezwykłym i nie ma potrzeby go dzielić na części. Niemniej
jednak, z jakichś powodów ludzie chcą mieć taką możliwość i zastanawiają się &lt;a href=&#34;https://unix.stackexchange.com/questions/24630/whats-the-best-way-to-join-files-again-after-splitting-them&#34;&gt;jak podzielić plik na
kilka
części&lt;/a&gt;
na jednej maszynie i połączyć je na innym komputerze.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>WordPress: Ograniczone prawa dostępu</title>
      <link>https://morfikov.github.io/post/wordpress-ograniczone-prawa-dostepu/</link>
      <pubDate>Sat, 06 Jun 2015 11:41:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wordpress-ograniczone-prawa-dostepu/</guid>
      <description>&lt;p&gt;Mając już zainstalowanego i wstępnie skonfigurowanego WordPress&#39;a, przydałoby się zadbać &lt;a href=&#34;https://codex.wordpress.org/Changing_File_Permissions&#34;&gt;prawa
dostępu do jego plików&lt;/a&gt; jak i również
ograniczyć nieco dostęp do samej bazy danych, tak by możliwie najmniejsze uprawnienia zostały
nadane, co poprawi znacznie bezpieczeństwo naszej witryny. Jeśli opanowaliśmy już operowanie na
instalacji WordPress&#39;a przy pomocy
&lt;a href=&#34;https://morfikov.github.io/post/wordpress-wiersz-polecen-wp-cli/&#34;&gt;skryptu&lt;/a&gt;
&lt;a href=&#34;https://morfikov.github.io/post/wordpress-instalacja-przy-pomocy-wp-cli/&#34;&gt;wp-cli&lt;/a&gt; , to możemy bez wahania
dokręcić śrubę naszemu serwisowi. Jeśli nie zaznajomiliśmy się jeszcze z powyższym narzędziem, to
ograniczenie praw może spowodować problemy z aktualizacją rdzennych plików WordPress&#39;a, jak i
instalacją/konfiguracją jego pluginów czy motywów.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
