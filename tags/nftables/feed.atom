<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>nftables on Morfitronik</title>
    <link>https://morfikov.github.io/tags/nftables/</link>
    <description>Recent content in nftables on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Wed, 02 Sep 2020 18:36:00 +0200</lastBuildDate><atom:link href="https://morfikov.github.io/tags/nftables/feed.atom" rel="self" type="application/atom+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)</title>
      <link>https://morfikov.github.io/post/jak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn/</link>
      <pubDate>Wed, 02 Sep 2020 18:36:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn/</guid>
      <description>&lt;p&gt;Parę dni temu &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=31514&#34;&gt;na forum dug.net.pl pojawiło się zapytanie&lt;/a&gt; dotyczące skonfigurowania linux&#39;a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux&#39;a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy &lt;code&gt;iptables&lt;/code&gt; / &lt;code&gt;nftables&lt;/code&gt; ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Blokowanie niepożądanej komunikacji z nftables na linux</title>
      <link>https://morfikov.github.io/post/blokowanie-niepozadanej-komunikacji-z-nftables-na-linux/</link>
      <pubDate>Fri, 12 Apr 2019 20:53:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/blokowanie-niepozadanej-komunikacji-z-nftables-na-linux/</guid>
      <description>&lt;p&gt;Minęło już trochę czasu od momentu, w którym postanowiłem się przerzucić z &lt;code&gt;iptables&lt;/code&gt; na &lt;code&gt;nftables&lt;/code&gt;
w swoim Debianie i w zasadzie większość mechanizmów obronnych mojego laptopowego firewall&#39;a została
już z powodzeniem przeportowana na ten nowy filtr pakietów. Poza tymi starymi regułami próbuję
czasem ogarniać nieco bardziej wyrafinowane sposoby na unikanie zagrożeń sieciowych, choć
implementacja niektórych rzeczy nie zawsze jest taka oczywista, z tym, że niekoniecznie niemożliwa
do zrealizowana. Tak było w przypadku mechanizmu automatycznego blokowania hostów próbujących się
łączyć z daną maszyną, która sobie najwyraźniej tego nie życzy. Dla przykładu, jest serwer
udostępniający usługę SSH na porcie &lt;code&gt;11111&lt;/code&gt; i tylko ten port jest wystawiony na świat. Wszelkiego
rodzaju boty próbujące dostać się do maszyn linux&#39;owych próbkują z kolei głównie standardowe porty,
w tym przypadku &lt;code&gt;22&lt;/code&gt; . Ci użytkownicy, którzy powinni mieć dostęp do usługi SSH, wiedzą na jakim
porcie ona nasłuchuje. Można zatem założyć, że wszystkie połączenia na port &lt;code&gt;22&lt;/code&gt; będą dokonywane
przez boty albo przez użytkowników, którzy mają niecne zamiary. Wszystkie te połączenia można by
zatem zablokować tworząc mechanizm automatycznego banowania hostów w oparciu o czas ostatniej próby
połączenia, tak jak to zostało opisane mniej
więcej &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?pid=269383&#34;&gt;w tym wątku na forum&lt;/a&gt;. Problem w tym, że
tamto rozwiązanie dotyczy jedynie &lt;code&gt;iptables&lt;/code&gt; w połączeniu z &lt;code&gt;ipset&lt;/code&gt; , co nieco komplikuje wdrożenie
go w przypadku &lt;code&gt;nftables&lt;/code&gt; ale to zadanie jest jak najbardziej możliwe.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Unikanie SYN/ICMP/UDP/PING flood w linux z nftables</title>
      <link>https://morfikov.github.io/post/unikanie-syn-icmp-udp-ping-flood-w-linux-z-nftables/</link>
      <pubDate>Fri, 12 Apr 2019 20:12:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/unikanie-syn-icmp-udp-ping-flood-w-linux-z-nftables/</guid>
      <description>&lt;p&gt;Obecnie &lt;code&gt;nftables&lt;/code&gt; cierpi dość mocno z powodu pewnych problemów związanych z wydajnością przy
aplikowaniu reguł zapory sieciowej. Niemniej jednak, w stosunku do &lt;code&gt;iptables&lt;/code&gt; , &lt;code&gt;nftables&lt;/code&gt; posiada
tablicę &lt;code&gt;netdev&lt;/code&gt; , która jest w stanie nieco zyskać w oczach tych nieco bardziej wybrednych
użytkowników linux&#39;a. Chodzi generalnie o fakt, że ta tablica jest umieszczona zaraz na początku
drogi pakietów, tuż po odebraniu ich z NIC (interfejsu karty sieciowej), a biorąc pod uwagę fakt,
że ruch sieciowy, który nigdy ma nie trafić do naszej maszyny, powinien być zrzucany jak
najwcześniej (by nie marnować zasobów procesora i pamięci), to ta tablica wydaje się być idealnym
miejscem by zablokować cały niepożądany ruch przychodzący. Przy wykorzystaniu &lt;code&gt;iptables&lt;/code&gt; , takie
pakiety zrzuca się w tablicy &lt;code&gt;raw&lt;/code&gt; . Jeśli zaś chodzi o &lt;code&gt;nftables&lt;/code&gt; , to zrzucanie pakietów w
tablicy &lt;code&gt;netdev&lt;/code&gt; jest ponad dwu lub nawet trzykrotnie bardziej wydajne (szybsze i mniej
zasobożerne). Można zatem dość dobrze poradzić sobie z wszelkiego rodzaju atakami DOS/DDOS, np.
ICMP/PING flood czy SYN flood. Zastanawiające może być natomiast ogarnięcie ataku UDP flood ale
przed tym rodzajem ataku linux również jest w stanie się bez problemu ochronić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czy linux&#39;owy firewall powinien blokować pakiety not-syn w stanie NEW</title>
      <link>https://morfikov.github.io/post/czy-linuxowy-firewall-powinien-blokowac-pakiety-not-syn-w-stanie-new/</link>
      <pubDate>Fri, 15 Mar 2019 18:02:21 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-linuxowy-firewall-powinien-blokowac-pakiety-not-syn-w-stanie-new/</guid>
      <description>&lt;p&gt;Od czasu do czasu w logu systemowym mojego Debiana można zanotować szereg pakietów przychodzących,
które są zrzucane przez linux&#39;owy firewall (&lt;code&gt;nftables&lt;/code&gt;/&lt;code&gt;iptables&lt;/code&gt; ). Po krótkiej analizie okazało
się, że są to pakiety protokołu TCP mające stan &lt;code&gt;NEW&lt;/code&gt; (czyli są to nowe połączenia) ale
niezawierające przy tym flagi &lt;code&gt;SYN&lt;/code&gt; . Mój laptop nie ma aktualnie przydzielonego zewnętrznego
routowalnego adresu IPv4/IPv6, więc nasunęło się pytanie o przyczynę takiego stanu
rzeczy -- przecie będąc za NAT, nikt spoza sieci nie powinien być w stanie nawiązać połączenia z
moją maszyną, a ewidentnie co się do jej bram dobija i to nie z adresu lokalnego. Niby mam też
odfiltrowane pakiety w stanie &lt;code&gt;INVALID&lt;/code&gt; (np. te mające niepoprawny zestaw flag) ale widać te
pakiety, o których mowa, nie zaliczają się do tego stanu, więc wygląda na to, że wszystko z nimi
jest w porządku. Czy tego typu pakiety TCP w stanie &lt;code&gt;NEW&lt;/code&gt; niemające ustawionej flagi &lt;code&gt;SYN&lt;/code&gt;
stanowią jakieś zagrożenie dla naszego komputera? Czy powinno się je zablokować, a może przepuścić
w filtrze pakietów? A jeśli zablokować, to czy zwykły &lt;code&gt;DROP&lt;/code&gt; wystarczy czy może powinno się te
pakiety potraktować przy pomocy &lt;code&gt;REJECT&lt;/code&gt; ?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Brak wsparcia dla ipset w nftables</title>
      <link>https://morfikov.github.io/post/brak-wsparcia-dla-ipset-w-nftables/</link>
      <pubDate>Sat, 02 Mar 2019 02:21:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/brak-wsparcia-dla-ipset-w-nftables/</guid>
      <description>&lt;p&gt;Użytkownicy Debiana często w roli firewall&#39;a wykorzystują już dość leciwy &lt;code&gt;iptables&lt;/code&gt; . W zasadzie,
to tej implementacji linux&#39;owego filtra pakietów sieciowych nic nie dolega, no może poza szeregiem
wad konstrukcyjnych, które są obecnie tak ciężkie do zaadresowania, że w sumie trzeba by cały ten
&lt;code&gt;iptables&lt;/code&gt; napisać od początku. Wszystko przez rozwój internetu, za sprawą którego pojawiło się
zapotrzebowanie na tworzenie całej masy reguł (w postaci adresów/portów źródłowych/docelowych),
gdzie w standardowym &lt;code&gt;iptables&lt;/code&gt; trzeba tworzyć osobne wpisy. Im więcej reguł w filtrze, tym
przechodzenie pakietów przez zaporę sieciową trwa dłużej i wiąże się z mocnym obciążeniem dla
procesora (zwłaszcza, gdy tych reguł jest kilkadziesiąt tysięcy). By jakoś uporać się z tymi
problemami (nieznanymi w innych filtrach sieciowych) stworzono &lt;code&gt;ipset&lt;/code&gt; . I faktycznie odciążył on
mocno procesor maszyny ale i tak nie wyeliminował on podstawowych wad &lt;code&gt;iptables&lt;/code&gt; . Dlatego też
zaczęto szukać innego rozwiązania i tak pojawiła się alternatywa m.in. w postaci &lt;code&gt;nftables&lt;/code&gt; . W
przyszłym stabilnym Debianie (buster) &lt;code&gt;nftables&lt;/code&gt; będzie wykorzystywany jako domyślny filtr pakietów
i ci, który korzystali z &lt;code&gt;ipset&lt;/code&gt; mogą się nieco zdziwić, że &lt;code&gt;nftables&lt;/code&gt; nie posiada dla niego
wsparcia. Rzecz w tym, że &lt;code&gt;nftables&lt;/code&gt; potrafi natywnie obsługiwać listy adresów/portów i &lt;code&gt;ipset&lt;/code&gt;
nie jest mu w tym do niczego potrzebny.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Migracja z iptables na nftables w Debianie</title>
      <link>https://morfikov.github.io/post/migracja-z-iptables-na-nftables-w-debianie/</link>
      <pubDate>Sat, 16 Feb 2019 11:05:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/migracja-z-iptables-na-nftables-w-debianie/</guid>
      <description>&lt;p&gt;Zgodnie z &lt;a href=&#34;http://ral-arturo.org/2018/06/16/nfws2018.html&#34;&gt;informacją&lt;/a&gt;, która pojawiła się już ponad pół roku temu, dystrybucje linux&#39;a powoli
zaczynają odchodzić od &lt;code&gt;iptables&lt;/code&gt; . Prawdopodobnie w niedługim czasie &lt;code&gt;iptables&lt;/code&gt; zostanie już
całkowicie wyparty i zastąpiony przez &lt;code&gt;nftables&lt;/code&gt; , przynajmniej jeśli chodzi o desktopy. Nawet
&lt;a href=&#34;https://wiki.debian.org/nftables#Current_status&#34;&gt;Debian zakomunikował&lt;/a&gt;, że następne wydanie stabilne tej dystrybucji (Buster) będzie domyślnie
wykorzystywało &lt;code&gt;nftables&lt;/code&gt; . Wypadałoby zatem się przenieść na ten nowy framework i przygotować
sobie kilka podstawowych reguł firewall&#39;a, które zabezpieczoną naszą maszynę przed nieautoryzowanym
dostępem z sieci.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czy brak wsparcia dla SYNPROXY w nftables jest problemem</title>
      <link>https://morfikov.github.io/post/czy-brak-wsparcia-dla-synproxy-w-nftables-jest-problemem/</link>
      <pubDate>Sat, 16 Feb 2019 10:20:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-brak-wsparcia-dla-synproxy-w-nftables-jest-problemem/</guid>
      <description>&lt;p&gt;Przenosząc swoje reguły z &lt;code&gt;iptables&lt;/code&gt; na &lt;code&gt;nftables&lt;/code&gt; zauważyłem, że jedna z nich (gdyby tylko jedna)
nie została przetłumaczona przez ten dedykowany translator do reguł. Chodzi
o &lt;a href=&#34;/post/unikanie-atakow-ddos-z-synproxy/&#34;&gt;mechanizm SYNPROXY&lt;/a&gt;, który jest zwykle wykorzystywany do ograniczenia skali ataków DDOS z
wykorzystaniem pakietów SYN. Co by nie mówić, to ochrona jaką daje SYNPROXY jest jak najbardziej
pożądana z perspektywy serwerów. Dlaczego zatem, gdy się zajrzy na stronę
&lt;a href=&#34;https://wiki.nftables.org/wiki-nftables/index.php/Supported_features_compared_to_xtables&#34;&gt;wspieranych rzeczy w nftables&lt;/a&gt;, to przy SYNPROXY widnieje bliżej nieokreślone sformułowanie
&lt;code&gt;consider native interface&lt;/code&gt; ? Po rozmowach z deweloperami udało się ustalić, że ten zapis oznacza
brak wsparcia dla SYNPROXY w &lt;code&gt;nftables&lt;/code&gt; . Jeśli zatem ktoś wykorzystuje ten mechanizm mając dodane
stosowne reguły w &lt;code&gt;iptables&lt;/code&gt; , to czy powinien się on obawiać przejścia na &lt;code&gt;nftables&lt;/code&gt; ?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ustalić nazwę procesu korzystającego z sieci</title>
      <link>https://morfikov.github.io/post/jak-ustalic-nazwe-procesu-korzystajacego-z-sieci/</link>
      <pubDate>Fri, 08 Feb 2019 20:10:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ustalic-nazwe-procesu-korzystajacego-z-sieci/</guid>
      <description>&lt;p&gt;Konfigurując filtr pakietów &lt;code&gt;iptables&lt;/code&gt;/&lt;code&gt;nftables&lt;/code&gt; na Debianie zwykle nie przykładamy większej wagi
do procesów, które chcą nawiązać połączenia wychodzące z naszego linux&#39;owego hosta. Mamy przecież
&amp;quot;skonfigurowany&amp;quot; firewall w łańcuchach &lt;code&gt;INPUT&lt;/code&gt; i &lt;code&gt;FORWARD&lt;/code&gt; i wszelkie zagrożenia z sieci nie
powinny nas dotyczyć. Problem w tym, że jeśli jakiś złowrogi proces zostanie uruchomiony w naszym
systemie, to jest on w stanie komunikować się ze światem zewnętrznym praktycznie bez żadnych
ograniczeń za sprawą braku jakichkolwiek reguł w łańcuchu &lt;code&gt;OUTPUT&lt;/code&gt; . Można oczywiście temu zaradzić
budując zaporę sieciową na bazie &lt;code&gt;cgroups&lt;/code&gt; , gdzie każda aplikacja będzie miała oznaczone pakiety,
przez co będzie można je rozróżnić i zablokować albo przepuścić przez filter. W tym wpisie jednak
nie będziemy się zajmować konstrukcją tego typu FW, tylko spróbujemy sobie odpowiedzieć na pytanie
jak namierzyć proces, który komunikuje się z siecią (lub też próbuje), posiadając jedynie log
&lt;code&gt;iptables&lt;/code&gt;/&lt;code&gt;nftables&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
