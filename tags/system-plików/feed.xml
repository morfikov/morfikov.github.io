<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>system-plików on Morfitronik</title>
    <link>https://morfikov.github.io/tags/system-plik%C3%B3w/</link>
    <description>Recent content in system-plików on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Fri, 22 Mar 2019 16:23:42 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/system-plik%C3%B3w/feed.xml" rel="self" type="application/rss" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czy w linux plik SWAP jest lepszy niż partycja wymiany</title>
      <link>https://morfikov.github.io/post/czy-w-linux-plik-swap-jest-lepszy-niz-partycja-wymiany/</link>
      <pubDate>Fri, 22 Mar 2019 16:23:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-w-linux-plik-swap-jest-lepszy-niz-partycja-wymiany/</guid>
      <description>&lt;p&gt;Ostatnimi czasy, z racji rozwoju technologicznego, mamy do dyspozycji coraz to szybsze komputery,
co przekłada się w znacznym stopniu na prędkość wykonywania operacji przez ich systemy operacyjne.
Obecnie przeciętnej klasy desktop czy laptop jest już wyposażony w 16G czy nawet 32G pamięci
operacyjnej (w niedługim czasie
nawet &lt;a href=&#34;https://android.com.pl/news/200097-samsung-12-gb-ram-lpddr4x/&#34;&gt;smartfony będą posiadać 12G RAM&lt;/a&gt;).
Spada zatem zapotrzebowanie wykorzystania dysku twardego jako pamięci RAM. W linux używanie
dysku twardego jako rozszerzenie pamięci operacyjnej było i jest w dalszym ciągu realizowane za
sprawą przestrzeni wymiany SWAP. Ta przestrzeń wymiany może być zaimplementowana w postaci osobnej
partycji dysku twardego albo też jako plik umieszczony w obrębie systemu plików, np. ext4. Część
dystrybucji linux&#39;a decyduję się na porzucenie partycji wymiany na rzecz pliku SWAP. Czy taki krok
jest uzasadniony i czy korzystając aktualnie z partycji wymiany powinniśmy zmigrować na plik SWAP?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czym jest Online ext4 Metadata Check w linux&#39;owym LVM</title>
      <link>https://morfikov.github.io/post/czym-jest-online-ext4-metadata-check-w-linuxowym-lvm/</link>
      <pubDate>Sun, 17 Mar 2019 19:10:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czym-jest-online-ext4-metadata-check-w-linuxowym-lvm/</guid>
      <description>&lt;p&gt;Przeglądając dzisiaj rano logi systemowe wpadł mi w oczy komunikat, którego treść brzmiała mniej
więcej tak: &lt;code&gt;e2scrub Volume group &amp;quot;wd_blue_label&amp;quot; has insufficient free space (0 extents): 64 required&lt;/code&gt; , po którym z kolei można zanotować &lt;code&gt;e2scrub snapshot FAILED, will not check!&lt;/code&gt; oraz
&lt;code&gt;Failed to start Online ext4 Metadata Check for /media/Debian&lt;/code&gt; . Oczywiście ten punkt montowania to
nazwa partycji odnosząca się do jednego z dysków logicznych struktury LVM. Skąd się te błędy
wzięły? Przecież jeszcze do niedawna (przez ostatnich parę lat) wszystko z moim linux&#39;em
rezydującym na dysku (LUKS+LVM) było w porządku, a teraz nagle takie bardzo niepokojące błędy.
Czym jest w ogóle ten &lt;code&gt;e2scrub&lt;/code&gt; i czym jest ten cały &lt;code&gt;Online ext4 Metadata Check&lt;/code&gt; , który
najwyraźniej ma coś wspólnego ze sprawdzaniem systemu plików voluminów logicznych w locie? No i
najważniejsze chyba pytanie -- czemu to nie działa jak należy?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Unexpected Inconsistency: Inode has corrupt extent header</title>
      <link>https://morfikov.github.io/post/unexpected-inconsistency-inode-corrupt-extent-header/</link>
      <pubDate>Fri, 01 Jul 2016 14:27:57 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/unexpected-inconsistency-inode-corrupt-extent-header/</guid>
      <description>&lt;p&gt;Dzisiaj system plików jednej z partycji mojego głównego dysku uległ awarii z niewiadomych przyczyn.
Dałbym sobie nawet głowę uciąć, że wszystkie partycje zostały poprawnie odmontowane podczas
wyłączania maszyny. Niemniej jednak, z jakiegoś powodu podczas startu systemu, ten wyrzuca szereg
komunikatów dotyczących głównego systemu plików, tj. &lt;code&gt;/&lt;/code&gt; . Sam komunikat brzmi mniej więcej tak:
&lt;code&gt;UNEXPECTED INCONSISTENCY; RUN fsck MANUALLY&lt;/code&gt; . Oznacza to, że błędy w systemie plików nie są łatwe
do naprawy i wymagana jest nasza ingerencja w ten proces. Przy sprawdzaniu systemu plików w
poszukiwaniu błędów przy pomocy &lt;code&gt;fsck.ext4&lt;/code&gt; można było dostrzec min. taką wiadomość: &lt;code&gt;Inode 556975 has corrupt extent header&lt;/code&gt; . Co ona tak naprawdę oznacza i czy damy radę wybrnąć z tej sytuacji bez
szwanku?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Data i czas utworzenia pliku w linux&#39;ie (crtime)</title>
      <link>https://morfikov.github.io/post/data-czas-utworzenia-pliku-w-linuxie-crtime/</link>
      <pubDate>Tue, 07 Jun 2016 17:07:54 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/data-czas-utworzenia-pliku-w-linuxie-crtime/</guid>
      <description>&lt;p&gt;Systemy plików, które wykorzystujemy na partycjach swoich dysków, zawierają metadane opisujące
pliki. Domyślnym systemem plików w większości linux&#39;ów (do nich zalicza się też debian) jest EXT4.
Gdy listujemy pliki przy pomocy narzędzia &lt;code&gt;ls&lt;/code&gt; , jesteśmy w stanie uzyskać szereg informacji
opisujących konkretny plik. Mamy tam min. czas ostatniej modyfikacji i-węzła (i-node), czyli tzw.
&lt;code&gt;ctime&lt;/code&gt; . Narzędzia takie jak &lt;code&gt;stat&lt;/code&gt; są w stanie podać również inne czasy, tj. &lt;code&gt;atime&lt;/code&gt; (ostatni czas
dostępu do pliku) oraz &lt;code&gt;mtime&lt;/code&gt; (ostatni czas modyfikacji pliku). Jednak żaden z tych powyższych nie
przekłada się na czas utworzenia pliku. Co prawda, po stworzeniu pliku, wszystkie te czasy są ze
sobą zsynchronizowane ale po przeprowadzeniu szeregu różnych operacji na tym pliku, problematyczne
może być ustalenie pierwotnej daty jego utworzenia. Celem tego artykułu jest pokazanie, jak przy
pomocy &lt;code&gt;debugfs&lt;/code&gt; uzyskać czas utworzenia dowolnie wskazanego pliku w systemie plików EXT4.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Sparse files (rozrzedzone pliki)</title>
      <link>https://morfikov.github.io/post/sparse-files-rozrzedzone-pliki/</link>
      <pubDate>Thu, 02 Jun 2016 16:42:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/sparse-files-rozrzedzone-pliki/</guid>
      <description>&lt;p&gt;Każdy system plików opiera się na blokach danych. Standardowo taki blok w systemie plików EXT4 ma 4
KiB (8 x 512 bajtów). Za każdym razem, gdy tworzymy jakiś plik na dysku, alokowana jest pewna część
bloków, na których ten plik ma zostać zapisany. Te większe pliki rezerwują więcej bloków, choć nie
zawsze są to bloki ciągłe. W taki sposób, plik o rozmiarze 10 GiB okupowałby dokładnie tyle miejsca
na dysku ile sam waży. Niemniej jednak są pewne pliki, które może i ważą te 10 GiB ale system plików
postrzega je tak jakby miały 100 MiB czy 200 MiB, w zależności od tego ile &amp;quot;faktycznie&amp;quot; taki plik
zajmuje miejsca. Jak to możliwe? Pliki, o których mowa, to tzw. &amp;quot;rozrzedzone pliki&amp;quot; (&lt;a href=&#34;https://en.wikipedia.org/wiki/Sparse_file&#34;&gt;Sparse
files&lt;/a&gt;). Taki plik składa się z szeregu bloków pustych
(mających same zera), których nie trzeba zapisywać na dysk. Zamiast tego, można jedynie zapisać
metadane w strykturze systemu plików, które będą opisywać te puste bloki. Poniższy artykuł ma na
celu pokazać do czego takie pliki sparse mogą nam się przydać i jak z nich korzystać.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana rozmiaru katalogu /tmp/ pod OpenWRT</title>
      <link>https://morfikov.github.io/post/zmiana-rozmiaru-katalogu-tmp-pod-openwrt/</link>
      <pubDate>Wed, 27 Apr 2016 18:24:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-rozmiaru-katalogu-tmp-pod-openwrt/</guid>
      <description>&lt;p&gt;OpenWRT ma w swoich repozytoriach całe mnóstwo pakietów. By móc je zainstalować, potrzebne jest nam
miejsce na flash&#39;u routera. Ten z kolei nie jest zbyt duży, często nie przekracza 16 MiB. Podczas
pracy, system operacyjny routera przeprowadza cały szereg operacji. Część z nich generuje jakieś
dane, np. tworzone są pliki konfiguracyjne, generowane statystyki czy pobierane z internetu pliki w
celu dalszego ich przetworzenia. Zwykle są to pliki, które wędrują do katalogu &lt;code&gt;/tmp/&lt;/code&gt; . Gdybyśmy
chcieli zapisać wszystkie te informacje na flash&#39;u routera, to zabrakłoby nam zwyczajnie miejsca.
Inną kwestią są problemy związane z zapisem samego flash&#39;a, który ulega zużyciu. Dlatego też, szereg
operacji zapisu został przeniesiony do pamięci operacyjnej RAM. W ten sposób mamy do wykorzystania
nieco więcej miejsca ale standardowo nie więcej niż 50% wielkości pamięci operacyjnej. Wielkość tego
&lt;a href=&#34;https://pl.wikipedia.org/wiki/Ramdysk&#34;&gt;RAMdysku&lt;/a&gt; można dostosować i w tym wpisie zobaczymy jak to
zrobić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana identyfikatora UUID</title>
      <link>https://morfikov.github.io/post/zmiana-identyfikatora-uuid/</link>
      <pubDate>Sat, 30 Jan 2016 16:52:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-identyfikatora-uuid/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=28210&#34;&gt;Na forum DUG&#39;a po raz kolejny pojawił się post&lt;/a&gt;
dotyczący unikalnych identyfikatorów, które są nadawane partycjom dysków twardych. Nie wiem jak
sprawa ma się w przypadku windowsów ale linux na podstawie tych numerów
&lt;a href=&#34;https://en.wikipedia.org/wiki/Universally_unique_identifier&#34;&gt;UUID&lt;/a&gt;
(&lt;a href=&#34;https://pl.wikipedia.org/wiki/Globally_Unique_Identifier&#34;&gt;GUID&lt;/a&gt;) jest w stanie identyfikować
konkretne urządzenia. Czasem się zdarza tak, że dwa dyski czy partycje mają taki sam identyfikator,
co prowadzi zwykle do problemów. Kolizja numerów identyfikacyjnych może być wynikiem pozostałości po
procesie produkcyjnym ale może także powstać za sprawą klonowania nośnika za pomocą narzędzia &lt;code&gt;dd&lt;/code&gt; .
Tak czy inaczej, przydałoby się wiedzieć jak ustalić, poprawnie wygenerować czy też zmienić UUID
wszędzie tam, gdzie jest on wykorzystywany i o tym będzie ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kopia struktury dysku twardego</title>
      <link>https://morfikov.github.io/post/kopia-struktury-dysku-twardego/</link>
      <pubDate>Fri, 18 Dec 2015 17:01:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kopia-struktury-dysku-twardego/</guid>
      <description>&lt;p&gt;Wszyscy wiedzą, że zabawa z dyskiem zwykle kończy się tragicznie dla zawartych na nim danych. W tym
wpisie spróbujemy się przyjrzeć sytuacjom, które nie jednego użytkownika linux&#39;a potrafią przyprawić
o zawał serca. Chodzi generalnie o uszkodzenie struktury dysku, oczywiście tylko tej programowej. Na
błędy fizyczne nie możemy zbytnio nic poradzić. Natomiast jeśli chodzi o sferę logiczną, to mamy
tutaj dość duże pole do popisu i jesteśmy w stanie się zabezpieczyć przed wieloma krytycznymi
sytuacjami. Postaramy się tutaj omówić to jak wykonać kopię dysku. Taka kopia będzie miała tylko
kilka (ew. kilkanaście) MiB, w skład której wchodzić będzie superblok systemu plików, nagłówki
zaszyfrowanych partycji LUKS, struktura LVM i tablica partycji. Uszkodzenie każdego z tych
powyższych uniemożliwia nam dostęp do danych zgromadzonych na dysku.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana rozmiaru partycji FAT32 pod linux&#39;em</title>
      <link>https://morfikov.github.io/post/zmiana-rozmiaru-partycji-fat32/</link>
      <pubDate>Thu, 17 Dec 2015 16:05:23 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-rozmiaru-partycji-fat32/</guid>
      <description>&lt;p&gt;Partycje mające system plików FAT32 są głównie wykorzystywane w przypadku pendrive i innych pamięci
flash, gdzie nie mamy do czynienia ze sporą ilością danych czy też dużymi plikami. Czasem się zdarza
tak, że układ partycji, który chcieliśmy zrobić, nie wyszedł nam tak jak powinien i musimy tego
pendrive jeszcze raz przeformatować. Pół biedy, gdy na nim nie ma żadnych danych lub mamy możliwość
zgrania ich na osobny dysk. Natomiast w przypadku, gdy nie możemy z jakiegoś powodu skorzystać z w/w
opcji, to musimy liczyć się z utratą danych. Oczywiście, możemy także spróbować zmienić rozmiar
takiej partycji i nic nie powinno się stać znajdującym się na niej danym. W tym wpisie postaramy się
przejść przez proces zmiany rozmiaru partycji mającej system plików FAT32 i zobaczymy czy nasz linux
poradzi sobie z tym zdaniem bez większego problemu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana rozmiaru partycji EXT4</title>
      <link>https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ext4/</link>
      <pubDate>Wed, 16 Dec 2015 19:06:57 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ext4/</guid>
      <description>&lt;p&gt;Jeśli jeszcze nie dokonaliśmy &lt;a href=&#34;https://morfikov.github.io/post/migracja-systemu-plikow-ext2-i-ext3-na-ext4/&#34;&gt;migracji systemu plików z EXT2/3 na
EXT4&lt;/a&gt;, to powinniśmy rozważyć
tę kwestię z przyczyn czysto praktycznych. W tym wpisie nie będziemy sobie głowy zawracać migracją
między poszczególnymi wersjami systemu plików z rodziny EXT, a raczej skupimy się na tym jak zmienić
rozmiar partycji, której systemem plików jest właśnie EXT4. Bawienie się rozmiarem partycji w tym
przypadku niczym zbytnio się nie różni w stosunku do omawianego wcześniej &lt;a href=&#34;https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ntfs-pod-linuxem/&#34;&gt;systemu plików
NTFS&lt;/a&gt;. Będziemy wykorzystywać
tylko nieco inne narzędzia.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana rozmiaru partycji NTFS pod linux&#39;em</title>
      <link>https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ntfs-pod-linuxem/</link>
      <pubDate>Wed, 16 Dec 2015 18:03:54 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ntfs-pod-linuxem/</guid>
      <description>&lt;p&gt;Zmiana rozmiaru partycji, nie tylko tej zawierającej system plików NTFS, nie sprawia w dzisiejszych
czasach praktycznie żadnych problemów. Mamy przecie do dyspozycji takie narzędzia jak
&lt;a href=&#34;http://gparted.org/&#34;&gt;gparted&lt;/a&gt;, które w dużej mierze automatyzują cały proces tworzenia i usuwania
partycji, czy też zmiany ich rozmiaru. W tym wpisie przyjrzymy się temu procesowi z bliska, z tym,
że nie będziemy korzystać z żadnych graficznych nakładek. Wszystkie kroki postaramy się
zreprodukować ręcznie z poziomu konsoli przy pomocy takich narzędzi jak &lt;code&gt;fdisk&lt;/code&gt; czy &lt;code&gt;ntfsresize&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak wymusić sprawdzenie systemu plików w systemd</title>
      <link>https://morfikov.github.io/post/jak-wymusic-sprawdzenie-systemu-plikow-w-systemd/</link>
      <pubDate>Fri, 04 Dec 2015 20:11:46 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wymusic-sprawdzenie-systemu-plikow-w-systemd/</guid>
      <description>&lt;p&gt;Jakiś czas temu opisywałem jak w systemach linux&#39;owych przeprowadzić &lt;a href=&#34;https://morfikov.github.io/post/sprawdzanie-bledow-systemu-plikow-ext4/&#34;&gt;sprawdzenie systemu plików pod
kątem ewentualnych błędów&lt;/a&gt;. Był tam
poświęcony kawałek na temat ręcznego wymuszenia takiego skanowania. Ten sposób, który został opisany
w tamtym wpisie działa wyśmienicie w przypadku sysvinit. Natomiast przy systemd mogą pojawić się
pewne problemy, w efekcie czego nie będziemy w stanie wymusić skanowania pewnych partycji.
Generalnie to rozchodzi się o tę główną, na której znajduje się system plików &lt;code&gt;/&lt;/code&gt; . Postanowiłem się
przyjrzeć nieco temu mechanizmowi i sprawdzić czy faktycznie nic nie da się zrobić i czy musimy
czekać pełną ilość cykli startu systemu, by ten system plików został przez niego przeskanowany
automatycznie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak odzyskać usunięte z dysku pliki</title>
      <link>https://morfikov.github.io/post/jak-odzyskac-usuniete-z-dysku-pliki/</link>
      <pubDate>Mon, 30 Nov 2015 19:03:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-odzyskac-usuniete-z-dysku-pliki/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/&#34;&gt;Całkowite usuwanie plików (shred)&lt;/a&gt; jak i
&lt;a href=&#34;https://morfikov.github.io/post/programowe-sprzetowe-zerowanie-dysku/&#34;&gt;zerowanie całych nośników&lt;/a&gt; ma na celu
nieodwracalne zniszczenie danych. W tych podlinkowanych artykułach próbowaliśmy zatrzeć ślady po
skasowanych plikach. W tym wpisie zaś prześledzimy sobie co tak naprawdę się dzieje po utworzeniu i
skasowaniu pliku, a także spróbujemy odzyskać te z nich, które już nie istnieją w naszym systemie.
Ten artykuł będzie dotyczył jedynie systemu plików z rodziny &lt;code&gt;ext&lt;/code&gt; , głównie &lt;code&gt;ext4&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Całkowite usuwanie plików przy pomocy shred</title>
      <link>https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/</link>
      <pubDate>Tue, 24 Nov 2015 15:11:32 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/</guid>
      <description>&lt;p&gt;W przypadku, gdy musimy pozbyć się jakiegoś pliku, który znajduje się na dysku, to nie jest zalecane
korzystanie z narzędzia &lt;code&gt;rm&lt;/code&gt; . Usuwa ono jedynie odnośnik do pliku, który go identyfikuje w
strukturze systemu plików, tzw. &lt;a href=&#34;https://pl.wikipedia.org/wiki/I-w%C4%99ze%C5%82&#34;&gt;i-węzeł&lt;/a&gt; (i-node).
To co uzyskujemy za pomocą takich narzędzi jak &lt;code&gt;rm&lt;/code&gt; , to jedynie oznaczenie pewnych bloków (tych od
pliku) jako wolne, w których system operacyjny będzie w stanie dokonać zapisu danych późniejszym
czasie. Podczas tej operacji nie są usuwane żadne informacje z dysku, a mając na uwadze ten fakt,
możemy bez problemu tak &amp;quot;usunięty&amp;quot; plik odzyskać. By mieć pewność, że plik zostanie trwale
zniszczony, trzeba go ponownie napisać, np. przy pomocy
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/wily/en/man1/shred.1.html&#34;&gt;shred&lt;/a&gt;, który standardowo jest
dostępny w każdej dystrybucji linux&#39;a i to jemu będzie poświęcony ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Migracja systemu plików ext2 i ext3 na ext4</title>
      <link>https://morfikov.github.io/post/migracja-systemu-plikow-ext2-i-ext3-na-ext4/</link>
      <pubDate>Thu, 12 Nov 2015 14:16:49 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/migracja-systemu-plikow-ext2-i-ext3-na-ext4/</guid>
      <description>&lt;p&gt;Dyski twarde są w stanie pomieścić setki gigabajtów danych. Ilość informacji, które jesteśmy w
stanie przechować na pojedynczym nośniku, rośnie w zastraszającym tempie. Rozwój technologii nie
jest jedynym polem gdzie prowadzone są prace nad nowymi rozwiązaniami poprawiającymi szereg aspektów
pracy tych urządzeń. Innym polem jest sfera programowa, która w przypadków dysków twardych w dużej
mierze dotyczy systemu plików. Albowiem każda powierzchnia, na której mają być przechowywane dane,
potrzebuje odpowiedniej struktury, którą również można usprawnić. Wobec czego, ten domyślny system
plików w linux&#39;ie, tj. &lt;code&gt;ext&lt;/code&gt; , przeszedł szereg modyfikacji i pojawiły się wersje &lt;code&gt;ext2&lt;/code&gt; , &lt;code&gt;ext3&lt;/code&gt; i
&lt;code&gt;ext4&lt;/code&gt; . Jeśli jakaś partycja dysku twardego zawiera starszą wersję systemu plików, powinniśmy
dokonać migracji na jego nowszy odpowiednik. W przypadku migracji z &lt;code&gt;ntfs&lt;/code&gt; na &lt;code&gt;ext4&lt;/code&gt; (czy też
odwrotnie), nieunikniona jest utrata danych. Czy w przypadku migracji z systemu plików &lt;code&gt;ext2&lt;/code&gt; i
&lt;code&gt;ext3&lt;/code&gt; na &lt;code&gt;ext4&lt;/code&gt; również musimy zgrywać wszystkie dane na osobny nośnik by przeformatować
odpowiednio taki dysk czy partycję? Okazuje się że nie musimy i możemy dokonać takiej migracji bez
obaw o utratę danych i w tym wpisie postaramy się ten zabieg przeprowadzić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Montowanie katalogu /tmp/ jako tmpfs</title>
      <link>https://morfikov.github.io/post/montowanie-katalogu-tmp-jako-tmpfs/</link>
      <pubDate>Wed, 21 Oct 2015 22:19:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/montowanie-katalogu-tmp-jako-tmpfs/</guid>
      <description>&lt;p&gt;Linux jest w stanie operować na wielu systemach plików, np. ext4, ntfs, fat. Większość z nich odnosi
się do dysków twardych, czy też innych urządzeń przechowujących spore ilości danych. Problem z tego
typu systemami plików jest taki, że operacje na plikach w ich obrębie, jak i same pliki, zostawiają
ślady. Dlatego też jeśli musimy tymczasowo skopiować plik zawierający tajne dane, lub też taki plik
poddać obróbce, nie powinniśmy go umieszczać bezpośrednio na dysku. No chyba, że wykorzystujemy
pełne szyfrowanie. Inną opcją (i o wiele prostszą w implementacji) jest przeznaczenie części
pamięci operacyjnej RAM pod &lt;a href=&#34;https://wiki.archlinux.org/index.php/Tmpfs&#34;&gt;system plików tmpfs&lt;/a&gt; i o
tym będzie ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kompaktowanie katalogów w systemie plików ext4</title>
      <link>https://morfikov.github.io/post/kompaktowanie-katalogow-w-systemie-plikow-ext4/</link>
      <pubDate>Sat, 11 Jul 2015 13:39:06 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kompaktowanie-katalogow-w-systemie-plikow-ext4/</guid>
      <description>&lt;p&gt;Jakiś czas temu pewien człowiek &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=27485&#34;&gt;miał dziwaczny
problem&lt;/a&gt;. Jak możemy wyczytać w przytoczonym linku,
system tego użytkownika lekko mówiąc nie zachowywał się tak jak powinien. Objawiało się to przez
dość ekstensywne wykorzystywanie pamięci operacyjnej RAM przy zwykłym listowaniu plików via &lt;code&gt;ls&lt;/code&gt; w
pewnych określonych katalogach. Struktura systemu plików zdaje się być porządku, bo program &lt;code&gt;fsck&lt;/code&gt;
nie zwraca żadnych błędów. Zatem w czym problem?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Opcja extents w systemach plików ext4</title>
      <link>https://morfikov.github.io/post/opcja-extents-w-systemach-plikow-ext4/</link>
      <pubDate>Fri, 10 Jul 2015 15:20:44 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/opcja-extents-w-systemach-plikow-ext4/</guid>
      <description>&lt;p&gt;Dziś postanowiłem sprawdzić jak wygląda struktura plików mojego dysku. Chodzi oczywiście o ich
fragmentację. Zgodnie z tym co pokazał mi &lt;code&gt;fsck&lt;/code&gt; , pofragmentowanych plików jest 350. Po
zapuszczeniu defragmentacji via &lt;code&gt;e4defrag&lt;/code&gt; ilość tych plików spadła do nieco ponad 100 i jeśli by
się przyjrzeć procesowi defragmentacji, to można było zauważyć linijki mające
&lt;code&gt;extents: 100 -&amp;gt; 10&lt;/code&gt; . Wychodzi na to, że plik dalej jest w kawałkach i nie idzie go
zdefragmentować. Jak rozumieć taki zapis?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Etykieta systemu plików i jej dostosowanie</title>
      <link>https://morfikov.github.io/post/etykieta-systemu-plikow-i-jej-dostosowanie/</link>
      <pubDate>Thu, 18 Jun 2015 18:32:32 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/etykieta-systemu-plikow-i-jej-dostosowanie/</guid>
      <description>&lt;p&gt;W poprzednim wpisie dostosowywaliśmy &lt;a href=&#34;https://morfikov.github.io/post/zarezerwowane-miejsce-w-systemie-plikow-ext4/&#34;&gt;zarezerwowane
miejsce&lt;/a&gt; na określonych
partycjach dla systemowych procesów. Okazuje się także, że zmiana etykiety systemu plików może
przysporzyć wiele problemów początkującym użytkownikom linuxa. Choć jeśli chodzi akurat o nadawanie
czy zmianę etykiet, to tutaj już mamy możliwość przeprowadzenia tej operacji z poziomu narzędzi GUI,
takich jak &lt;code&gt;gparted&lt;/code&gt; , z tym, że niektóre jego komunikaty mogą nieco odstraszać.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zarezerwowane miejsce w systemie plików ext4</title>
      <link>https://morfikov.github.io/post/zarezerwowane-miejsce-w-systemie-plikow-ext4/</link>
      <pubDate>Thu, 18 Jun 2015 17:29:16 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zarezerwowane-miejsce-w-systemie-plikow-ext4/</guid>
      <description>&lt;p&gt;Zwykle nie zwracamy uwagi na to jak formatujemy partycje w systemie linux i akceptujemy domyślne
ustawienia jakie przyjęli sobie deweloperzy danej dystrybucji. Nie ma tutaj znaczenia czy
instalujemy świeży system za pośrednictwem instalatora i przy jego pomocy kroimy dysk, czy też
tworzymy partycje indywidualnie już z poziomu jakiegoś zainstalowanego systemu, bądź też płytki czy
pendrive live. Domyślne ustawienia mają spełniać oczekiwania jak największej liczby odbiorców i nie
zawsze nam one odpowiadają. W przypadku formatowania dysku, problematyczne może być rezerwowanie
miejsca dla procesów użytkownika root.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
