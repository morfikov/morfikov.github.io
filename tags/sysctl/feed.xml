<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>sysctl on Morfitronik</title>
    <link>https://morfikov.github.io/tags/sysctl/</link>
    <description>Recent content in sysctl on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sun, 09 Aug 2020 11:11:00 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/sysctl/feed.xml" rel="self" type="application/rss" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja HugePages pod maszyny wirtualne QEMU/KVM</title>
      <link>https://morfikov.github.io/post/konfiguracja-hugepages-pod-maszyny-wirtualne-qemu-kvm/</link>
      <pubDate>Sun, 09 Aug 2020 11:11:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-hugepages-pod-maszyny-wirtualne-qemu-kvm/</guid>
      <description>&lt;p&gt;W linux rozmiar stron pamięci operacyjnej RAM ma domyślnie 4096 bajtów (4 KiB). Maszyny wirtualne
QEMU/KVM mają to do siebie, że wykorzystują dość spore zasoby pamięci (wile GiB), przez co mały
rozmiar strony może niekorzystnie wpływać na wydajność systemów gościa. Chodzi generalnie o to, że
rozrostowi ulega tablica stron, której przeszukiwanie jest czasochłonną operacją. By temu zaradzić,
wymyślono TLB (&lt;a href=&#34;https://en.wikipedia.org/wiki/Translation_lookaside_buffer&#34;&gt;Translation Lookaside Buffer&lt;/a&gt;), który ulokowany jest albo w CPU albo gdzieś
pomiędzy CPU i główną pamięcią operacyjną. TLB to mały ale za to bardzo szybki cache. W przypadku
systemów z duża ilością pamięci RAM, niewielki rozmiar TLB sprawia, że odpowiedzi na zapytania nie
są brane z cache, tylko system wraca do przeszukiwania normalnej tablicy stron zlokalizowanej w
pamięci RAM (TLB miss). Taka sytuacja jest bardzo kosztowna, spowalnia cały system i dlatego trzeba
jej unikać. Na szczęście jest &lt;a href=&#34;https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt&#34;&gt;mechanizm HugePages&lt;/a&gt;, który pozwala na zwiększenie rozmiaru
strony pamięci z domyślnych 4 KiB do 2 MiB lub nawet do 1 GiB w zależności od właściwości głównego
procesora. W tym artykule postaramy się skonfigurować HugePages na potrzeby maszyn wirtualnych dla
systemu Debian Linux.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Unikanie SYN/ICMP/UDP/PING flood w linux z nftables</title>
      <link>https://morfikov.github.io/post/unikanie-syn-icmp-udp-ping-flood-w-linux-z-nftables/</link>
      <pubDate>Fri, 12 Apr 2019 20:12:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/unikanie-syn-icmp-udp-ping-flood-w-linux-z-nftables/</guid>
      <description>&lt;p&gt;Obecnie &lt;code&gt;nftables&lt;/code&gt; cierpi dość mocno z powodu pewnych problemów związanych z wydajnością przy
aplikowaniu reguł zapory sieciowej. Niemniej jednak, w stosunku do &lt;code&gt;iptables&lt;/code&gt; , &lt;code&gt;nftables&lt;/code&gt; posiada
tablicę &lt;code&gt;netdev&lt;/code&gt; , która jest w stanie nieco zyskać w oczach tych nieco bardziej wybrednych
użytkowników linux&#39;a. Chodzi generalnie o fakt, że ta tablica jest umieszczona zaraz na początku
drogi pakietów, tuż po odebraniu ich z NIC (interfejsu karty sieciowej), a biorąc pod uwagę fakt,
że ruch sieciowy, który nigdy ma nie trafić do naszej maszyny, powinien być zrzucany jak
najwcześniej (by nie marnować zasobów procesora i pamięci), to ta tablica wydaje się być idealnym
miejscem by zablokować cały niepożądany ruch przychodzący. Przy wykorzystaniu &lt;code&gt;iptables&lt;/code&gt; , takie
pakiety zrzuca się w tablicy &lt;code&gt;raw&lt;/code&gt; . Jeśli zaś chodzi o &lt;code&gt;nftables&lt;/code&gt; , to zrzucanie pakietów w
tablicy &lt;code&gt;netdev&lt;/code&gt; jest ponad dwu lub nawet trzykrotnie bardziej wydajne (szybsze i mniej
zasobożerne). Można zatem dość dobrze poradzić sobie z wszelkiego rodzaju atakami DOS/DDOS, np.
ICMP/PING flood czy SYN flood. Zastanawiające może być natomiast ogarnięcie ataku UDP flood ale
przed tym rodzajem ataku linux również jest w stanie się bez problemu ochronić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak włączyć IPv6 Privacy Extensions w Debianie (SLAAC)</title>
      <link>https://morfikov.github.io/post/jak-wlaczyc-ipv6-privacy-extensions-w-debianie-slaac/</link>
      <pubDate>Sun, 10 Feb 2019 08:22:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wlaczyc-ipv6-privacy-extensions-w-debianie-slaac/</guid>
      <description>&lt;p&gt;Protokół IPv6 został opracowany już dość dawno temu, a jednak ilość hostów w internecie
komunikujących się za jego pomocą wciąż nie jest zbyt wysoka
i &lt;a href=&#34;https://www.google.com/intl/en/ipv6/statistics.html&#34;&gt;oscyluje w granicach 25%&lt;/a&gt;. Faktem jest, że
migracja z IPv4 na IPv6 może być sporym kosztem dla niektórych podmiotów jeśli chodzi o kwestię
związaną z wymianą sprzętu i ze zmianą konfiguracji sieci, co pewnie zniechęca część ISP do
wdrożenia tego protokołu. Użytkownicy korzystający z sieci z kolei nie wiedzieć czemu też
preferują IPv4 nad IPv6. Jakiś czas temu czytałem nawet artykuł na temat zagrożenia prywatności
jakie może nieść ze sobą protokół IPv6. Chodzi generalnie o to, że obecnie wszyscy przywykliśmy do
rozwiązania jakie oferuje nam NAT, które jest w stanie utrudnić nieco naszą identyfikację i analizę
naszej aktywności w internecie. W przypadku IPv6 adresy IP są dość unikatowe w skali globalnej, a
część odpowiedzialna za identyfikację hosta (ostatnie 64 bity) stanowi identyfikator EUI64, który z
kolei jest generowany na podstawie adresu MAC karty sieciowej. W taki oto sposób interfejs tej
karty będzie miał stały identyfikator EUI64, a hosta będzie można zidentyfikować bez problemu i
bez względu na to u którego ISP podłączymy nasz komputer. Rozwiązaniem tego problemu jest mechanizm
zwany IPv6 Privacy Extensions. Przydałoby się zatem rzucić na niego okiem i jeśli okaże się
użyteczny, to wypadałoby go włączyć w naszym Debian Linux.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>packet_write_wait: Connection to IP port 22: Broken pipe</title>
      <link>https://morfikov.github.io/post/packet_write_wait-connection-to-ip-port-22-broken-pipe/</link>
      <pubDate>Wed, 03 Aug 2016 13:41:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/packet_write_wait-connection-to-ip-port-22-broken-pipe/</guid>
      <description>&lt;p&gt;Operowanie na VPS nie jest jakoś specjalnie trudne, zwłaszcza w przypadku, gdy mamy dostęp root i
możemy logować się na serwer z wykorzystaniem protokołu SSH. Dalej to już zwykła linux&#39;owa
mechanika, która może być nieco inna, w zależności od tego, jaki dokładnie system operacyjny na tym
VPS stoi. Czasami jednak, w pewnym momencie podczas połączenia możemy zostać rozłączeni z
niewiadomych nam przyczyn. Niemniej jednak, zawsze, gdy ten problem występuje, w terminalu można
zobaczyć komunikat: &lt;code&gt;packet_write_wait: Connection to 1.2.3.4 port 22: Broken pipe&lt;/code&gt; . Przydałoby się
zatem coś na ten stan rzeczy poradzić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>nf_conntrack: automatic helper assignment is deprecated</title>
      <link>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</link>
      <pubDate>Sat, 16 Jul 2016 18:59:19 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</guid>
      <description>&lt;p&gt;Jeśli ktoś uważnie śledzi logi systemowe, to od czasu do czasu można w nich znaleźć komunikat,
którzy brzmi mniej więcej tak: &lt;code&gt;nf_conntrack: automatic helper assignment is deprecated and it will be removed soon. Use the iptables CT target to attach helpers instead&lt;/code&gt; . Ta wiadomość odnosi się do
jednego z modułów linux&#39;owego filtra pakietów &lt;code&gt;iptables&lt;/code&gt; . Moduł, o którym mowa to &lt;code&gt;nf_conntrack&lt;/code&gt; ,
który odpowiada za śledzenie połączeń nawiązywanych przez system. Sam komunikat zaś dotyczy
mechanizmów pomocniczych, których sposób aktywacji jest już nieco przestarzały i zostanie wkrótce
usunięty. Co to oznacza dla przeciętnego użytkownika linux&#39;a i czym są w istocie te mechanizmy
pomocnicze, które znajdują zastosowane na zaporze sieciowej?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Równoważenie ruchu łącz kilku ISP (load balancing)</title>
      <link>https://morfikov.github.io/post/rownowazenie-ruchu-lacz-kilku-isp-load-balancing/</link>
      <pubDate>Sun, 22 May 2016 13:40:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/rownowazenie-ruchu-lacz-kilku-isp-load-balancing/</guid>
      <description>&lt;p&gt;Podłączenie pojedynczego komputera do sieci raczej nie stanowi żadnego problemu dla przeciętnego
użytkownika linux&#39;a. Wystarczy jedynie skonfigurować kilka parametrów i możemy oglądać swoje
ulubione serwisy www. Co jednak w przypadku, gdy mamy do dyspozycji kilka łącz internetowych? Jedną
z opcji jest używanie łącza tego ISP, które jest lepsze gabarytowo, a pozostałe łącza trzymać na
wypadek awarii tego pierwszego. Nie jest to zbytnio satysfakcjonujące rozwiązanie, zwłaszcza w
przypadku, gdy tym providerom płacimy za świadczone nam usługi. W taki sposób płacimy, np. za dwa
łącza, a korzystamy z jednego w danej chwili. W linux&#39;ie obsługa wielu łącz różnych ISP jest dość
skomplikowana. By taki mechanizm zaimplementować sobie, trzeba stworzyć kilka tablic routingu.
Następnie ruch sieciowy musi zostać oznaczony w &lt;code&gt;iptables&lt;/code&gt; i przekierowany do tych tablic przez
kernel. Przy odrobienie wysiłku jesteśmy jednak w stanie zaprojektować sobie load balancer, który
będzie równoważył obciążenie łącza między kilku ISP. Dodatkowo, jeśli jedno z łączy nam nawali, to
automatycznie zostaniemy przełączeni na drugie łącze (failover). W tym artykule postaramy się
zaprojektować taki właśnie mechanizm.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Aktywacja i konfiguracja klawisza SysRq</title>
      <link>https://morfikov.github.io/post/aktywacja-i-konfiguracja-klawisza-sysrq/</link>
      <pubDate>Thu, 29 Oct 2015 01:57:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/aktywacja-i-konfiguracja-klawisza-sysrq/</guid>
      <description>&lt;p&gt;SysRq (System Request) to klawisz na klawiaturze, po którego przyciśnięciu można wysłać
niskopoziomowe zapytana bezpośrednio do kernela linux&#39;a. Te komendy działają nawet w przypadku
pozornego braku kontaktu z systemem operacyjnym, tj. zacięcia dźwięku, nieruchomy kursor myszy, a
nawet w przypadku braku możliwości wpisywania znaków z klawiatury. Zwykle po opisanych wyżej
symptomach, człowiek jest skłonny przycisnąć przycisk reset na obudowie swojego komputera, no bo jak
inaczej odwiesić taki system? Problem z twardym resetem (za pomocą przycisku) jest taki, że
praktycznie zawsze po nim występuje uszkodzenie struktury systemu plików na dysku, a czasami
uszkodzeniu ulega cała partycja. To niesie ze sobą ryzyko utraty danych. Dlatego też powinniśmy
zaprzestać resetowania komputerów przy pomocy przycisków i zacząć korzystać z klawisza SysRq .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Automatyczny restart maszyny po kernel panic</title>
      <link>https://morfikov.github.io/post/automatyczny-restart-maszyny-po-kernel-panic/</link>
      <pubDate>Wed, 28 Oct 2015 23:56:51 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/automatyczny-restart-maszyny-po-kernel-panic/</guid>
      <description>&lt;p&gt;Gdy nasz linux napotka z jakiegoś powodu błąd wewnątrz swojej struktury, to istnieją sytuacje, w
których obsługa tego błędu czasem nie jest możliwa. Wobec czego, zostaje wyrzucony komunikat
systemowy oznajmiający nam, że &lt;a href=&#34;https://pl.wikipedia.org/wiki/Kernel_panic&#34;&gt;kernel spanikował (kernel
panic)&lt;/a&gt;, bo nie wie co w takim przypadku zrobić. Gdy
tego typu sytuacja się nam przytrafia, nie ma innego wyjścia jak tylko uruchomić system ponownie. Co
jednak w przypadku gdy pracujemy zdalnie i nie jesteśmy w stanie zresetować takiej maszyny
fizycznie? Na szczęście kernel ma kilka opcji, które mogą zainicjować automatyczny restart w
przypadku wystąpienia kernel panic.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Mechanizm SYN cookies w protokole TCP</title>
      <link>https://morfikov.github.io/post/mechanizm-syn-cookies-w-protokole-tcp/</link>
      <pubDate>Sat, 24 Oct 2015 20:22:02 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/mechanizm-syn-cookies-w-protokole-tcp/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/SYN_flood&#34;&gt;Atak SYN flood&lt;/a&gt; to rodzaj ataku DoS, którego celem jest
wyczerpanie zasobów serwera uniemożliwiając mu tym samym poprawne realizowanie danej usługi, do
której został oddelegowany. Jest to dość popularne zjawisko i w przypadku, gdy mamy postawioną
jakąś maszynę na publicznym adresie IP, przydałoby się nieco zainteresować tym problem, który może
wystąpić w najmniej oczekiwanym momencie. W tym wpisie rzucimy okiem na mechanizm SYN cookies.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Unikanie ataków DDoS z SYNproxy</title>
      <link>https://morfikov.github.io/post/unikanie-atakow-ddos-z-synproxy/</link>
      <pubDate>Sat, 24 Oct 2015 17:39:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/unikanie-atakow-ddos-z-synproxy/</guid>
      <description>&lt;p&gt;Internet nie jest zbyt przyjaznym miejscem i jest wielce prawdopodobne, że prędzej czy później ktoś
zaatakuje jedną z naszych maszyn, która świadczy w nim jakieś usługi. Są różne typy ataków, w tym
przypadku chodzi o ataki DDoS z wykorzystaniem pakietów wchodzących w proces potrójnego witania
(three way handshake) przy nawiązywaniu połączenia w protokole TCP, tj. pakiety &lt;code&gt;SYN&lt;/code&gt; , &lt;code&gt;SYN-ACK&lt;/code&gt; i
&lt;code&gt;ACK&lt;/code&gt; . Istnieje szereg mechanizmów, które adresują problem SYN flooding&#39;u ale żaden z nich nie jest
doskonały. Jakiś czas temu, do kernela linux&#39;owego trafił patch implementujący &lt;a href=&#34;https://lwn.net/Articles/563151/&#34;&gt;mechanizm
SYNproxy&lt;/a&gt; i w tym wpisie obadamy go sobie nieco dokładniej.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Retransmisja i duplikaty pakietów w TCP</title>
      <link>https://morfikov.github.io/post/retransmisja-i-duplikaty-pakietow-w-tcp/</link>
      <pubDate>Wed, 23 Sep 2015 19:31:27 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/retransmisja-i-duplikaty-pakietow-w-tcp/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Retransmisja&#34;&gt;Retransmisja&lt;/a&gt; pakietu w przypadku sieci opartych na
protokołach TCP/IP nie jest niczym niezwykłym. Oczywiście, pozostaje kwestia samego realizowania
tego przedsięwzięcia ale generalnie rzecz biorąc, systemy linux&#39;owe mają szereg opcji w kernelu,
które możemy sobie dostosować konfigurując tym samym, to w jaki sposób nasz system reaguje na
zjawisko utraty pakietów podczas ich przesyłu między dwoma punktami sieciowymi.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Aplikowanie zmiennych sysctl przy pomocy udev&#39;a</title>
      <link>https://morfikov.github.io/post/aplikowanie-zmiennych-sysctl-przy-pomocy-udeva/</link>
      <pubDate>Sun, 06 Sep 2015 11:08:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/aplikowanie-zmiennych-sysctl-przy-pomocy-udeva/</guid>
      <description>&lt;p&gt;Kernele linux&#39;owe mają dość sporo opcji, które możemy zmienić przy pomocy pliku &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; .
Niby nic nadzwyczajnego ale co w przypadku tych zmiennych, które muszą być ustawione, z tym, że
moduł, który stworzy odpowiednie ścieżki w katalogu &lt;code&gt;/proc/sys/&lt;/code&gt; , nie został załadowany z jakichś
względów przy starcie systemu? Zmienne te nie zostaną ustawione, a w logu pojawi się komunikat
informujący nas o nieodnalezieniu określonego pliku. Okazuje się, że jesteśmy w stanie aplikować
określone ustawienia sysctl w momencie ładowania określonych modułów i temu mechanizmowi się
przyjrzymy bliżej w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wolny start połączeń w protokole TCP</title>
      <link>https://morfikov.github.io/post/wolny-start-polaczen-w-protokole-tcp/</link>
      <pubDate>Tue, 07 Jul 2015 19:33:16 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wolny-start-polaczen-w-protokole-tcp/</guid>
      <description>&lt;p&gt;Wolny start jest wynikiem braku zaufania maszyny nadawczej do utworzonego kanału przesyłowego --
połączenia. Nie wie ona czy to łącze jest bowiem w stanie obsłużyć taką porcję danych, którą ma
zamiar przesłać bez czekania na pakiet &lt;code&gt;ACK&lt;/code&gt; . W przypadku bufora odbiorczego, wszystko jest proste,
bo dane dotyczące wielkości okien są zdefiniowane w nagłówku pakietów, do których ma wgląd druga ze
stron. W przypadku gdy nadawca przesyła dane, prędkość z jaką to robi zależy głównie od niego.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Bufor połączeń w protokole TCP</title>
      <link>https://morfikov.github.io/post/bufor-polaczen-w-protokole-tcp/</link>
      <pubDate>Wed, 01 Jul 2015 10:20:16 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/bufor-polaczen-w-protokole-tcp/</guid>
      <description>&lt;p&gt;Wraz ze zwiększaniem zapotrzebowania na szybsze łącza internetowe, ograniczenia wynikające z
protokółu TCP zaczęły powoli dawać się ludziom we znaki. Problemem była bariera prędkości, którą
ciężko było pokonać mając do dyspozycji domyślną formę nagłówka protokołu TCP. Było w nim zwyczajnie
za mało miejsca, co zapoczątkowało jego rozbudowę kosztem ilości danych, które można było przesłać w
pojedynczym segmencie. W tym wpisie skupię się głównie na dwóch opcjach jakie zostały dodane do
nagłówka TCP, tj. dynamiczne skalowanie okien oraz znaczniki czasu, bo te dwa parametry nie mogą
wręcz bez siebie istnieć, zwłaszcza gdy rozmawiamy o łączach pokroju 1 czy 10 gbit/s.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>SACK, czyli selektywne potwierdzenia pakietów</title>
      <link>https://morfikov.github.io/post/sack-czyli-selektywne-potwierdzenia-pakietow/</link>
      <pubDate>Wed, 01 Jul 2015 06:04:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/sack-czyli-selektywne-potwierdzenia-pakietow/</guid>
      <description>&lt;p&gt;Protokół TCP jest tak zbudowany by zapewnić rzetelny transfer danych między dwoma komunikującymi się
punktami. Z początku jednak, ta cecha tego protokołu powodowała marnowanie dość sporych ilości
zasobów jeśli chodzi o przepustowość łącza. Stało się to widoczne przy większych prędkościach
połączeń, gdzie &lt;a href=&#34;https://morfikov.github.io
/post/bufor-polaczen-w-protokole-tcp/&#34;&gt;skalowany był bufor&lt;/a&gt;
(okno) TCP, co umożliwiło przesyłanie szeregu segmentów bez potrzeby czekania na ich potwierdzenie
przez odbiorcę. To zwiększyło, co prawda, transfer danych ale pojawił się problem z zagubionymi
pakietami.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Fragmentacja pakietu i zmiana wartości MTU</title>
      <link>https://morfikov.github.io/post/fragmentacja-pakietu-i-zmiana-wartosci-mtu/</link>
      <pubDate>Mon, 29 Jun 2015 21:35:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/fragmentacja-pakietu-i-zmiana-wartosci-mtu/</guid>
      <description>&lt;p&gt;MTU (Maximum Transmission Unit) to maksymalna długość pakietu jaki może zostać przesłany przez sieć.
Może ona wynosić do 64KiB ale większość punktów sieciowych, takich jak routery, wymusza o wiele
mniejsze rozmiary pakietów. Domyślna wartość MTU dla protokołu Ethernet to 1500 bajtów, oczywiście
bez nagłówka warstwy fizycznej, który ma dodatkowe 14 bajtów. Czasami te standardowe ustawienia mogą
powodować problemy w przypadku pewnych konfiguracji sieci i gdy ich doświadczamy, przydałoby się
zmienić rozmiar MTU przesyłanych pakietów.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Znacznik czasu (timestamp) w protokole TCP</title>
      <link>https://morfikov.github.io/post/znacznik-czasu-timestamp-w-protokole-tcp/</link>
      <pubDate>Sun, 28 Jun 2015 17:33:54 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/znacznik-czasu-timestamp-w-protokole-tcp/</guid>
      <description>&lt;p&gt;O znacznikach czasu (timestamp) wspominałem już raz w ramach omawiania mechanizmu jakim jest &lt;a href=&#34;https://morfikov.github.io
/post/bufor-polaczen-w-protokole-tcp/&#34;&gt;bufor
połączenia&lt;/a&gt;, a konkretnie rozchodziło się o
skalowanie okien TCP. Generalnie rzecz biorąc, przy wyższych prędkościach, rzędu 1 gbit/s, nie ma
innej opcji jak skorzystanie z opcji znaczników czasu, które są niejako rozszerzeniem czegoś co
widnieje pod nazwą &lt;a href=&#34;https://morfikov.github.io
/post/numery-sekwencyjne-w-strumieniu-tcp/&#34;&gt;numery sekwencyjne&lt;/a&gt;
. Z jednej strony może i mamy możliwość implementacji łącz o większej przepustowości ale z drugiej
te znaczniki czasu w pakietach TCP &lt;a href=&#34;https://nfsec.pl/security/2306&#34;&gt;mogą zagrozić bezpieczeństwu&lt;/a&gt;
stacji roboczej.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Numery sekwencyjne w strumieniu TCP</title>
      <link>https://morfikov.github.io/post/numery-sekwencyjne-w-strumieniu-tcp/</link>
      <pubDate>Thu, 25 Jun 2015 21:24:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/numery-sekwencyjne-w-strumieniu-tcp/</guid>
      <description>&lt;p&gt;Jeśli zastanawialiście się czym są numery sekwencyjne i potwierdzeń w strumieniach protokołu TCP, to
nie jesteście jedyni, którym to zagadnienie spędza sen z powiek. Dlatego też poniżej postanowiłem
opisać najdokładniej jak umiem proces jaki zachodzi przy przesyłaniu danych z jednego punktu
sieciowego na drugi. Bez zaprzęgnięcia sniffera sieciowego raczej nie da się zrozumieć tego tematu i
poniższy przykład zawiera szereg odwołań do programu wireshark.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czas życia pakietów, czyli zmiana TTL</title>
      <link>https://morfikov.github.io/post/czas-zycia-pakietow-czyli-zmiana-ttl/</link>
      <pubDate>Wed, 24 Jun 2015 17:50:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czas-zycia-pakietow-czyli-zmiana-ttl/</guid>
      <description>&lt;p&gt;Czasem niektórzy ISP z jakiegoś bliżej nieokreślonego powodu blokują dostęp do internetu hostom
zlokalizowanym za routerem czy innym komputerem udostępniającym połączenie sieciowe. ISP zwykle
stara się blokować konkretną wartość pola TTL, która jest ustawiana w każdym przesyłanym przez nasze
maszyny pakiecie. Innym sposobem zablokowania możliwości udostępniania internetu jest ograniczenie
wartości pola TTL do jednego hopa wszystkim pakietom dochodzącym do routera od strony ISP. Jeśli
mamy nieszczęście trafić na takiego providera, to warto wiedzieć, że przy pomocy iptables możemy
ustawić/podbić/zmniejszyć czas życia pakietów, które docierają do routera zarówno od strony LAN jak
i WAN i tym samym bez większego trudu możemy sobie poradzić z tą blokadą.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Udostępnianie połączenia internetowego</title>
      <link>https://morfikov.github.io/post/udostepnianie-polaczenia-internetowego/</link>
      <pubDate>Wed, 24 Jun 2015 13:57:02 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/udostepnianie-polaczenia-internetowego/</guid>
      <description>&lt;p&gt;Każdy z nas ma router w domu, który potrafi rozdzielić sygnał na szereg komputerów w naszej sieci
lokalnej. Jeśli z jakichś powodów nie chcemy posiadać w domu tego cuda techniki i chcielibyśmy mieć
możliwość udostępniania połączenia internetowego za pośrednictwem innego komputera, to nic nie stoi
nam na przeszkodzie by to zrobić. Taki komputer stacjonarny niczym się nie różni od routera, no może
za wyjątkiem poboru prądu.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
