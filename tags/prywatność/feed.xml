<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>prywatność on Morfitronik</title>
    <link>https://morfikov.github.io/tags/prywatno%C5%9B%C4%87/</link>
    <description>Recent content in prywatność on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sat, 19 Sep 2020 14:13:00 +0200</lastBuildDate><atom:link href="https://morfikov.github.io/tags/prywatno%C5%9B%C4%87/feed.xml" rel="self" type="application/rss" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Szyfrowany DNS z dnscrypt-proxy i dnsmasq na Debian linux</title>
      <link>https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/</link>
      <pubDate>Sat, 19 Sep 2020 14:13:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/</guid>
      <description>&lt;p&gt;Ostatnio na forum dug.net.pl jeden z użytkowników &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=31524&#34;&gt;miał dość spory problem&lt;/a&gt; z ogarnięciem
zadania polegającego na zaszyfrowaniu zapytań DNS z wykorzystaniem &lt;a href=&#34;https://dnscrypt.info/&#34;&gt;dnscrypt-proxy&lt;/a&gt; i
&lt;a href=&#34;http://www.thekelleys.org.uk/dnsmasq/doc.html&#34;&gt;dnsmasq&lt;/a&gt;. Ładnych parę lat temu opisywałem &lt;a href=&#34;https://morfikov.github.io
/tags/resolver/&#34;&gt;jak skonfigurować te dwa narzędzia na Debianie&lt;/a&gt;
(i też na OpenWRT), choć od tamtego czasu w świecie linux&#39;owym trochę rzeczy się pozmieniało. Dla
przykładu, dnscrypt-proxy przeszedł gruntowną przebudowę, no i też systemd jest w powszechniejszym
użyciu niż to miało miejsce w tamtych czasach, przez co w sporej części przypadków usługi takie jak
&lt;code&gt;systemd-networkd.service&lt;/code&gt; czy &lt;code&gt;systemd-resolved.service&lt;/code&gt; są już włączone domyślnie. Zatem sporo
informacji zawartych w tych napisanych przeze mnie artykułach już niekoniecznie może znaleźć
obecnie zastosowanie. Dlatego też pomyślałem, że nadszedł już czas, by ździebko zaktualizować tamte
wpisy. Ostatecznie stanęło jednak na tym, by w oparciu o te artykuły napisać kompletnie nowy tekst
na temat szyfrowania zapytań DNS na linux przy wykorzystaniu oprogramowania &lt;code&gt;dnscrypt-proxy&lt;/code&gt; oraz
&lt;code&gt;dnsmasq&lt;/code&gt; i zawrzeć w nim te wszystkie ciekawsze informacje, które udało mi się pozyskać przez te
ostatnie lata w kwestii poprawy bezpieczeństwa i prywatności przy przeglądaniu stron WWW.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)</title>
      <link>https://morfikov.github.io/post/jak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn/</link>
      <pubDate>Wed, 02 Sep 2020 18:36:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn/</guid>
      <description>&lt;p&gt;Parę dni temu &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=31514&#34;&gt;na forum dug.net.pl pojawiło się zapytanie&lt;/a&gt; dotyczące skonfigurowania linux&#39;a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux&#39;a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy &lt;code&gt;iptables&lt;/code&gt; / &lt;code&gt;nftables&lt;/code&gt; ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak włączyć stabilne adresy prywatne w IPv6 na linux</title>
      <link>https://morfikov.github.io/post/jak-wlaczyc-stabilne-adresy-prywatne-w-ipv6-na-linux/</link>
      <pubDate>Wed, 19 Aug 2020 19:31:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wlaczyc-stabilne-adresy-prywatne-w-ipv6-na-linux/</guid>
      <description>&lt;p&gt;Jakiś już czas temu opisywałem &lt;a href=&#34;https://morfikov.github.io
/post/jak-wlaczyc-ipv6-privacy-extensions-w-debianie-slaac/&#34;&gt;jak włączyć rozszerzenia prywatności IPv6 na Debianie&lt;/a&gt; (IPv6
Privacy Extensions) w przypadku korzystania z mechanizmu automatycznej konfiguracji adresacji
hostów SLAAC (StateLess Address AutoConfiguration). Miało to za zadanie poprawić nieco prywatność
osób podłączonych do internetu za sprawą protokołu IPv6, bo generowane adresy IP standardowo
zawierają adresy MAC kart sieciowych (&lt;a href=&#34;https://en.wikipedia.org/wiki/MAC_address&#34;&gt;identyfikator EUI64&lt;/a&gt;). Parę dni temu dowiedziałem się, że
w linux można również aktywować inny mechanizm zwany stabilnymi adresami prywatnymi
(&lt;a href=&#34;https://tools.ietf.org/html/rfc7217&#34;&gt;stable-privacy addresses&lt;/a&gt;), które to wykorzystują inny system przy generowaniu identyfikatorów
interfejsów sieciowych. Ten mechanizm sprawia, że część adresu IPv6 odpowiedzialna za identyfikację
hosta ma losowe, choć stabilne wartości, które nie mają nic wspólnego z adresem MAC karty sieciowej
naszego komputera. W ten sposób możemy ukrócić śledzenie nas w sieci na podstawie adresu IPv6.
Poniższy artykuł ma za zadanie pomóc skonfigurować nam te stabilne adresy prywatne na linux oraz
pokazać w jaki sposób są one w stanie pomóc naszej prywatności.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak włączyć w Firefox ESNI (Encrypted SNI)</title>
      <link>https://morfikov.github.io/post/jak-wlaczyc-w-firefox-esni-encrypted-sni/</link>
      <pubDate>Mon, 10 Aug 2020 18:15:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wlaczyc-w-firefox-esni-encrypted-sni/</guid>
      <description>&lt;p&gt;Obecnie szyfrowanie zapytań DNS staje się powoli normą za sprawą protokołu DoH (&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_HTTPS&#34;&gt;DNS over HTTPS&lt;/a&gt;)
lub DoT (&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_TLS&#34;&gt;DNS over TLS&lt;/a&gt;). Można by zatem pomyśleć, że wraz z implementacją szyfrowania tego
kluczowego dla działania internetu protokołu (przynajmniej z naszego ludzkiego punktu widzenia),
poprawie ulegnie również nasza prywatność w kwestii odwiedzanych przez nas stron WWW. Niemniej
jednak, w dalszym ciągu można bez problemu wyciągnąć adresy domen, które zamierzamy odwiedzić. Nie
ma przy tym żadnego znaczenia ile stron jest hostowanych na danym adresie IP, ani nawet fakt, że
ruch do serwera WWW będzie szyfrowany (w pasku adresu wpiszemy &lt;code&gt;https://&lt;/code&gt; ) z wykorzystaniem
protokołu SSL/TLS (w tym również TLS v1.3). Wszystko przez rozszerzenie SNI (&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;Server Name
Indication&lt;/a&gt;), którego to zadaniem jest umożliwienie jednemu serwerowi na prezentowanie wielu
certyfikatów hostowanych w jego obrębie domen. Dzięki takiemu rozwiązaniu, każda domena może
szyfrować ruch niezależnie od siebie na linii serwer&amp;lt;-&amp;gt;klient (używać innych kluczy szyfrujących).
Niemniej jednak, podczas nawiązywania szyfrowanego połączenia, w pakiecie ClientHello przesyłanym
do takiego serwera musi znaleźć się nazwa domeny, której to certyfikat serwer będzie musiał nam
przedstawić. Niestety ten pakiet jest przesyłany przez sieć otwartym tekstem, przez co każdy, kto
podsłuchuje naszą komunikację (w tym też nasz ISP), bez problemu może ustalić na jakie strony
internetowe wchodzimy. Ostatnimi czasy jednak pojawiły się dwa rozszerzenia ECH (&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication#Encrypted_Client_Hello&#34;&gt;Encrypted Client
Hello&lt;/a&gt;) oraz ESNI (&lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-esni-07&#34;&gt;Encrypted SNI&lt;/a&gt;), które mają zaadresować problemy związane z prywatnością
przez pełne zaszyfrowanie pakietu ClientHello lub też zaszyfrowanie jedynie pola SNI w tym pakiecie.
Póki co, prace nad tymi rozszerzeniami nie są jeszcze skończone ale Firefox w połączeniu z
CloudFlare powoli testują ESNI. Postanowiłem zatem dobrowolnie przyłączyć się do grupy testerów i
wdrożyć na swoim linux&#39;ie to rozszerzenie ESNI dla przeglądarki Firefox.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zmienić hostname w telefonie z Androidem</title>
      <link>https://morfikov.github.io/post/jak-zmienic-hostname-w-telefonie-z-androidem/</link>
      <pubDate>Wed, 29 Jan 2020 19:00:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zmienic-hostname-w-telefonie-z-androidem/</guid>
      <description>&lt;p&gt;Przeglądając ostatnio listę sprzętów podłączonych do mojego routera WiFi, zauważyłem, że niektóre
pozycje na niej w polu z hostname mają coś na wzór &lt;code&gt;android-4c52c33baae0b4fa&lt;/code&gt; . Pierwsza część
nazwy tego hosta wskazuje na system operacyjny, a drugi kawałek to unikalny numerek ID.  Nie jestem
zbytnio fanem rozgłaszania takich informacji publicznie, bo mogą one ułatwić ewentualne ataki, oraz
też identyfikują jednoznacznie dane urządzenie (&lt;a href=&#34;https://source.android.com/devices/tech/connect/wifi-mac-randomization&#34;&gt;osobną kwestią jest adres MAC karty sieciowej&lt;/a&gt;).
Ponadto, mając w sieci wiele mobilnych urządzeń, ciężko jest czasem połapać się który telefon ma
przypisany konkretny adres IP (bez patrzenia w ustawienia telefonu). Z reguły na linux&#39;owym
desktopie czy laptopie zmiana hostname jest stosunkowo łatwym zadaniem ale w przypadku smartfona z
Androidem ten zabieg okazał się niezmiernie trudnym procesem. Jak zatem zmienić hostname telefonu,
by można było mu przypisać jakaś w miarę ludzką nazwę?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zweryfikować plik APK aplikacji na Androida</title>
      <link>https://morfikov.github.io/post/jak-zweryfikowac-plik-apk-aplikacji-na-androida/</link>
      <pubDate>Fri, 13 Dec 2019 19:26:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zweryfikowac-plik-apk-aplikacji-na-androida/</guid>
      <description>&lt;p&gt;Część użytkowników smartfonów z Androidem na pokładzie żyje w głębokim przekonaniu, że instalowanie
aplikacji spoza sklepu Google Play nie jest zbyt rozważnym posunięciem. Nie chodzi tutaj tylko o
szeroko rozumiane alternatywne źródła aplikacji, np. serwis apkmirror ale również o Yalp/Aurora
Store czy też repozytoria F-Droid. Zdaniem tych osób pobieranie aplikacji z zewnętrznych źródeł
może skompromitować bezpieczeństwo systemu oraz zagrozić naszej prywatności. No jakby nie patrzeć
wgrywanie czegokolwiek bez zastanowienia się co tak naprawdę instalujemy w systemie nie jest zbyt
mądre. Dlaczego zatem nie weryfikujemy aplikacji obecnych w oficjalnym sklepie Google? Co chwila
przecież można usłyszeć w mediach o syfie, który udało się co prawda z tego sklepu usunąć ale też
jakaś większa liczba użytkowników taką aplikację zdążyła już zainstalować i używała jej przez
dłuższy lub krótszy okres czasu. Rozumowanie na zasadzie, że aplikacje ze sklepu Google Play są
bezpieczne, bo są obecne w sklepie Google Play, daje nam jedynie fałszywe poczucie bezpieczeństwa,
które jest gorsze od całkowitego braku bezpieczeństwa, bo w tym drugim przypadku człowiek
przynajmniej jest świadom czyhających na niego niebezpieczeństw i włącza myślenie. Jak zatem
odróżnić aplikacje, które są w stanie nam wyrządzić krzywdę od tych, które tego nie mają na celu i
czy faktycznie pobieranie aplikacji na Androida z innego źródła niż oficjalny sklep Google Play
jest takie niebezpieczne?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak włączyć IPv6 Privacy Extensions w Debianie (SLAAC)</title>
      <link>https://morfikov.github.io/post/jak-wlaczyc-ipv6-privacy-extensions-w-debianie-slaac/</link>
      <pubDate>Sun, 10 Feb 2019 08:22:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wlaczyc-ipv6-privacy-extensions-w-debianie-slaac/</guid>
      <description>&lt;p&gt;Protokół IPv6 został opracowany już dość dawno temu, a jednak ilość hostów w internecie
komunikujących się za jego pomocą wciąż nie jest zbyt wysoka
i &lt;a href=&#34;https://www.google.com/intl/en/ipv6/statistics.html&#34;&gt;oscyluje w granicach 25%&lt;/a&gt;. Faktem jest, że
migracja z IPv4 na IPv6 może być sporym kosztem dla niektórych podmiotów jeśli chodzi o kwestię
związaną z wymianą sprzętu i ze zmianą konfiguracji sieci, co pewnie zniechęca część ISP do
wdrożenia tego protokołu. Użytkownicy korzystający z sieci z kolei nie wiedzieć czemu też
preferują IPv4 nad IPv6. Jakiś czas temu czytałem nawet artykuł na temat zagrożenia prywatności
jakie może nieść ze sobą protokół IPv6. Chodzi generalnie o to, że obecnie wszyscy przywykliśmy do
rozwiązania jakie oferuje nam NAT, które jest w stanie utrudnić nieco naszą identyfikację i analizę
naszej aktywności w internecie. W przypadku IPv6 adresy IP są dość unikatowe w skali globalnej, a
część odpowiedzialna za identyfikację hosta (ostatnie 64 bity) stanowi identyfikator EUI64, który z
kolei jest generowany na podstawie adresu MAC karty sieciowej. W taki oto sposób interfejs tej
karty będzie miał stały identyfikator EUI64, a hosta będzie można zidentyfikować bez problemu i
bez względu na to u którego ISP podłączymy nasz komputer. Rozwiązaniem tego problemu jest mechanizm
zwany IPv6 Privacy Extensions. Przydałoby się zatem rzucić na niego okiem i jeśli okaże się
użyteczny, to wypadałoby go włączyć w naszym Debian Linux.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Szyfrowanie rozmów i SMS&#39;ów na smartfonie z Androidem (Signal)</title>
      <link>https://morfikov.github.io/post/szyfrowanie-rozmow-i-smsow-na-smartfonie-z-androidem-signal/</link>
      <pubDate>Sun, 26 Mar 2017 18:35:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-rozmow-i-smsow-na-smartfonie-z-androidem-signal/</guid>
      <description>&lt;p&gt;Każdy z nas ma już raczej w swoim posiadaniu telefon, czy jego nieco bardziej zaawansowaną wersję
określaną mianem smartfona. Te urządzenia to w zasadzie przenośne i do tego bardzo małe komputery,
które umożliwiają nam komunikowanie się z osobami na całym świecie. Wykonywanie połączeń głosowych,
przesyłanie SMS&#39;ów/MMS&#39;ów czy też korzystanie z Internetu w naszych komórkach od dawna jest już
standardem i ciężko byłoby nam się obejść bez tej technologii obecnie. Problem w tym, że nasza
komunikacja jest narażona na podsłuch. W przypadku Internetu większość połączeń jest już szyfrowana
na linii dwóch klientów (E2E, End To End). Natomiast jeśli chodzi o telefony, to tutaj sprawa kuleje
i to bardzo poważnie, bo w zasadzie nasze połączenia głosowe czy SMS&#39;y są do wglądu dla każdych
służb, które z jakiegoś powodu uznają, że mogą naruszać naszą prywatność. Jedyna opcja, która jest
w stanie zabezpieczyć nas przed tego typu praktykami, to szyfrowanie rozmów. Tak się składa, że jest
kilka aplikacji na Androida, które są w stanie realizować tego typu przedsięwzięcie. Jedną z nich
jest darmowa i otwartoźródłowa aplikacja Signal, której się przyjrzymy nieco bliżej w tym artykule.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak skonfigurować połączenie VPN przez SSH</title>
      <link>https://morfikov.github.io/post/jak-skonfigurowac-polaczenie-vpn-przez-ssh/</link>
      <pubDate>Sun, 11 Dec 2016 15:59:06 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-skonfigurowac-polaczenie-vpn-przez-ssh/</guid>
      <description>&lt;p&gt;Szukając informacji na &lt;a href=&#34;https://morfikov.github.io
/post/jak-ukryc-ruch-openvpn-przy-pomocy-stunnel/&#34;&gt;temat ukrycia ruchu generowanego przez
OpenVPN&lt;/a&gt;, natrafiłem także na
sposób, który &lt;a href=&#34;https://help.ubuntu.com/community/SSH_VPN&#34;&gt;wykorzystuje do tego celu połączenie SSH&lt;/a&gt;.
W efekcie jesteśmy w stanie upodobnić ruch VPN do tego, który zwykle służy do zarządzania zdalnymi
systemami linux. Jako, że temat maskowania połączenia VPN jest kluczowy w walce z cenzurą internetu,
to im więcej sposobów, by taki zabieg przeprowadzić, tym lepiej. Dlatego też postanowiłem odświeżyć
nieco podlinkowany wyżej artykuł i sprawdzić czy jest on jeszcze aktualny. Wprawdzie nie dysponuję
Ubuntu, a jedynie dystrybucją Debian ale raczej nie powinno być problemów z odwzorowaniem
konfiguracji na tym systemie, choć artykuł jest dość leciwy już i pewnie trzeba będzie kilka rzeczy
zaktualizować.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ukryć ruch OpenVPN przy pomocy stunnel</title>
      <link>https://morfikov.github.io/post/jak-ukryc-ruch-openvpn-przy-pomocy-stunnel/</link>
      <pubDate>Sat, 10 Dec 2016 15:18:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-ruch-openvpn-przy-pomocy-stunnel/</guid>
      <description>&lt;p&gt;Ci z nas, którzy korzystają codziennie z internetu, wiedzą, że większość nawiązywanych połączeń
między dwoma punktami w tej sieci globalnej przechodzi przez szereg węzłów i jest podatnych na
przechwycenie i podsłuchanie. Nawet jeśli ruch z określonymi serwisami jest szyfrowany, to w dalszym
ciągu nie jesteśmy w stanie ukryć pewnych newralgicznych informacji, takich jak docelowy adres IP i
port, na którym nasłuchuje zdalna usługa. Wszystkie połączenia sieciowe zestawiane z naszego
komputera czy routera domowego przechodzą przez infrastrukturę ISP, u którego mamy wykupiony
internet. Tacy ISP są nam w stanie pod naciskiem rządu zablokować połączenia z konkretnymi adresami
wprowadzając na terenie danego kraju cenzurę treści dostępnej w internecie, czego obecnie jesteśmy
świadkami w Europie, no i w Polsce. Można oczywiście posiłkować się rozwiązaniami opartymi o VPN,
np. &lt;a href=&#34;https://morfikov.github.io
/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/&#34;&gt;stawiając serwer OpenVPN w innym
kraju&lt;/a&gt;. Problem jednak w
tym, że ruch OpenVPN różni się od tego, z którym mamy do czynienia w przypadku choćby HTTPS. Jest
zatem możliwość rozpoznania ruchu VPN i zablokowania go stosując &lt;a href=&#34;https://en.wikipedia.org/wiki/Deep_packet_inspection&#34;&gt;głęboką analizę
pakietów&lt;/a&gt; (Deep Packet Inspection, DPI). By
się przed tego typu sytuacją ochronić, trzeba upodobnić ruch generowany przez OpenVPN do zwykłego
ruchu SSL/TLS. Do tego celu służy &lt;a href=&#34;https://www.stunnel.org/index.html&#34;&gt;narzędzie stunnel&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak skonfigurować klienta VPN na routerze z LEDE/OpenWRT</title>
      <link>https://morfikov.github.io/post/jak-skonfigurowac-klienta-vpn-na-routerze-z-ledeopenwrt/</link>
      <pubDate>Thu, 08 Dec 2016 18:13:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-skonfigurowac-klienta-vpn-na-routerze-z-ledeopenwrt/</guid>
      <description>&lt;p&gt;Ostatnio pisałem trochę o &lt;a href=&#34;https://morfikov.github.io
/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/&#34;&gt;konfiguracji serwera VPN na
Debianie&lt;/a&gt; oraz podłączaniu
do niego różnych linux&#39;owych klientów, w tym też &lt;a href=&#34;https://morfikov.github.io
/post/jak-skonfigurowac-polaczenie-vpn-na-smartfonie-z-androidem/&#34;&gt;smartfonów wyposażonych w system
Android&lt;/a&gt;. O ile
konfiguracja pojedynczego klienta OpenVPN nie jest jakoś szczególnie trudna, to mając w swojej sieci
domowej kilka urządzeń zdolnych łączyć się z internetem zarówno przewodowo jak i bezprzewodowo, to
dostosowanie konfiguracji na każdym z tych sprzętów może być ździebko problematyczne. To co łączy te
wszystkie urządzenia w naszym domu, to router WiFi. Zwykle każdy komputer, nawet ten najmniejszy,
łączy się z takim routerem w celu nawiązania połączenia ze światem. Dlatego też zamiast
konfigurować osobno wszystkie te urządzenia elektroniczne, możemy skonfigurować sobie router w taki
sposób, by cały zebrany ruch z sieci lokalnej przesłał do serwera VPN. Standardowej klasy routery
nie wspierają połączeń VPN i by taki mechanizm zaimplementować potrzebne nam będzie alternatywne
firmware pokroju LEDE/OpenWRT. W tym artykule postaramy się skonfigurować połączenie VPN dla sieci
domowej w oparciu o &lt;a href=&#34;http://www.tp-link.com.pl/products/details/Archer-C2600.html&#34;&gt;router Archer
C2600&lt;/a&gt; od TP-LINK, który ma wgrany
najnowszy snapshot LEDE Chaos Calmer (r2392).&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak skonfigurować serwer VPN na Debianie (OpenVPN)</title>
      <link>https://morfikov.github.io/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/</link>
      <pubDate>Tue, 06 Dec 2016 19:22:49 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/</guid>
      <description>&lt;p&gt;Co raz częściej słychać w mediach o próbie cenzurowania internetu i blokowaniu dostępu do kolejnych
serwisów i stron www. Ostatnio znowu podnieśli kwestię blokowania pokemonów bezpośrednio u ISP tak,
by za zgodą ISP (władzy) można przeglądać tego typu serwisy. W sumie mam już tego dość i korzystając
z okazji, że posiadam za granicą niewielkich rozmiarów VPS, który i tak nie jest zbytnio obciążony,
to postanowiłem sobie skonfigurować na nim serwer VPN w oparciu o &lt;a href=&#34;https://openvpn.net/index.php/open-source/documentation/howto.html&#34;&gt;oprogramowanie
OpenVPN&lt;/a&gt;, które jest standardowo
dostępne w każdej dystrybucji linux&#39;a. Proces konfiguracji serwera jak i klienta z zainstalowanym
Debianem zostanie opisany poniżej. Niemniej jednak, inne urządzenia takie jak routery WiFi i
smartfony również wymagają zaimplementowania w nich mechanizmu szyfrującego ruch ale te rozwiązania
zostaną opisane w osobnych wątkach.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ukryć user-agent w nagłówku email</title>
      <link>https://morfikov.github.io/post/jak-ukryc-user-agent-w-naglowku-email/</link>
      <pubDate>Sun, 29 May 2016 12:05:46 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-user-agent-w-naglowku-email/</guid>
      <description>&lt;p&gt;Na każdym kroku można natknąć się na przecieki informacyjne, które zagrażają naszej prywatności.
Widzieliśmy to choćby i na przykładzie &lt;a href=&#34;https://morfikov.github.io
/post/jak-ukryc-prywatny-adres-ip-w-naglowku-email/&#34;&gt;prywatnego adresu IP widocznego w nagłówku w wiadomości
email&lt;/a&gt;. Przeglądając ten
podlinkowany wpis mogliśmy z grubsza zobaczyć jak wygląda taki nagłówek wiadomości. Bardziej uważni
czytelnicy zwrócili uwagę na jego zawartość. Poza polem zawierającym adres IP, można było też
zobaczyć pole odpowiadające za &lt;a href=&#34;https://pl.wikipedia.org/wiki/User_agent&#34;&gt;user-agent&lt;/a&gt;. Ciąg zawarty
w tym polu zdradza informacje na temat wykorzystywanego klienta pocztowego oraz systemu
operacyjnego. Ten komunikat możemy jednak ukryć i w tym wpisie zostanie to pokazane na przykładzie
&lt;a href=&#34;https://www.mozilla.org/pl/thunderbird/&#34;&gt;Thunderbird&#39;a&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ukryć prywatny adres IP w nagłówku email</title>
      <link>https://morfikov.github.io/post/jak-ukryc-prywatny-adres-ip-w-naglowku-email/</link>
      <pubDate>Sat, 28 May 2016 18:29:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-prywatny-adres-ip-w-naglowku-email/</guid>
      <description>&lt;p&gt;Korzystając z różnego rodzaju klientów email udostępniamy serwerom mailowym nieco więcej informacji
niż gdybyśmy to robili z panelu webowego serwera pocztowego. Chodzi generalnie o adres IP hosta,
który przesłał wiadomość na serwer. Tradycyjnie w nagłówku email&#39;a znajdzie się nasz adres
zewnętrzny, ten przypisany przez ISP. Niemniej jednak, w części przypadków będzie załączony również
adres IP z przestrzeni prywatnej, np. 10.0.0.0/8 lub 192.168.0.0/16 . O ile nie damy rady zataić
publicznego IP naszego ISP, to jesteśmy w stanie ukryć ten prywatny adres i tym samym nieco poprawić
naszą prywatność. W tym wpisie zostanie pokazane, to jak ten adres prywatny ukryć w nagłówku
wiadomości email w kliencie &lt;a href=&#34;https://www.mozilla.org/pl/thunderbird/&#34;&gt;Thunderbird&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ukryć hostname w protokole DHCP</title>
      <link>https://morfikov.github.io/post/jak-ukryc-hostname-w-protokole-dhcp/</link>
      <pubDate>Tue, 24 May 2016 20:07:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-hostname-w-protokole-dhcp/</guid>
      <description>&lt;p&gt;Darmowe hotspoty sieci WiFi są dostępne w każdym mieście. Dzięki nim możemy uzyskać połączenie z
internetem praktycznie za free. Niemniej jednak, takie połączenie nie jest do końca bezpieczne i
może zagrażać naszej prywatności. Wiele osób stara się temu przeciwdziałać &lt;a href=&#34;https://morfikov.github.io
/post/jak-przypisac-losowy-adres-mac-interfejsu/&#34;&gt;generując losowy adres
MAC&lt;/a&gt;. No i to jest jakieś
wyjście, o ile ten adres jest generowany z głową. Niemniej jednak, w takich sieciach WiFi, host ma
przydzielaną adresację za pomocą &lt;a href=&#34;https://pl.wikipedia.org/wiki/Dynamic_Host_Configuration_Protocol&#34;&gt;protokołu
DHCP&lt;/a&gt;. Ci, którzy wiedza, jak
odbywa się konfiguracja za pomocą tego protokołu, wiedzą też, że nasz komputer przesyła pewne dane
do serwera DHCP. Jakie dane? To zwykle zależy od konfiguracji klienta DHCP. Na linux&#39;ach domyślnym
klientem DHCP jest &lt;code&gt;dhclinet&lt;/code&gt; i on standardowo przesyła nazwę hosta (hostname) w zapytaniu o
adresację. Co nam zatem po losowym adresie MAC, gdy można nas zidentyfikować po nazwie hosta? W tym
artykule postaramy się ukryć lub też losowo wygenerować hostname danej maszyny w sieci.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak przypisać losowy adres MAC do interfejsu</title>
      <link>https://morfikov.github.io/post/jak-przypisac-losowy-adres-mac-interfejsu/</link>
      <pubDate>Fri, 29 Apr 2016 16:42:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-przypisac-losowy-adres-mac-interfejsu/</guid>
      <description>&lt;p&gt;Interfejsy kart sieciowych, które są instalowane w komputerach, posiadają adres MAC (&lt;a href=&#34;https://en.wikipedia.org/wiki/MAC_address&#34;&gt;Media Access
Control&lt;/a&gt;). Jest to unikalny identyfikator, który wyróżnia
nasz komputer spośród tłumu. Na podstawie tego adresu można nie tylko określić markę sprzętu, którą
się posługujemy ale także można sklasyfikować cały nasz ruch sieciowy. W ten sposób bardzo prosto
możemy zostać zidentyfikowani wymieniając dane przez darmowe hotspoty sieci bezprzewodowych WiFi.
Niemniej jednak, jesteśmy się w stanie obronić przed tego typu inwigilacją zmieniając adres MAC
naszego komputera. Nie jest to zbytnio trudne ale trzeba uważać, by znowu nie przesadzić w drugą
stronę i czasem nie zostać zidentyfikowanym przez naszą &amp;quot;odmienność&amp;quot;. W tym wpisie postaramy się
wypracować taki mechanizm, który zmieni nam adres MAC przy każdym podłączeniu do sieci i przy
zachowaniu zdroworozsądkowych zasad.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Przeciek DNS (DNS leak) w VPN (resolvconf)</title>
      <link>https://morfikov.github.io/post/przeciek-dns-dns-leak-w-vpn-resolvconf/</link>
      <pubDate>Mon, 25 Apr 2016 14:37:51 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/przeciek-dns-dns-leak-w-vpn-resolvconf/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://dnsleaktest.com/what-is-a-dns-leak.html&#34;&gt;Przeciek DNS (dns leak)&lt;/a&gt; to nic innego jak wyciek
poufnej informacji, za sprawą nieprawidłowej konfiguracji resolver&#39;a DNS. Może niekoniecznie jest
winne tutaj samo oprogramowanie, które realizuje zapytania DNS, czy też serwer domen jakiejś
organizacji. Chodzi głównie o tematykę &lt;a href=&#34;https://pl.wikipedia.org/wiki/Virtual_Private_Network&#34;&gt;VPN&lt;/a&gt;,
gdzie cały ruch sieciowy powinien być wrzucany do tunelu SSL/TLS i szyfrowany. W pewnych sytuacjach,
zapytania DNS mogą zostać wysyłane pod zewnętrzny resolver, często w formie niezaszyfrowanej i do
tego poza połączeniem VPN. Ten ruch można podsłuchać, przechwycić i poddać analizie. Celem tego
artykułu jest tak skonfigurowanie linux&#39;a (w tym przypadku dystrybucja Debian), by te przecieki
wyeliminować. Jest to możliwe za sprawą narzędzia &lt;code&gt;resolvconf&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Metadane plików graficznych (EXIF)</title>
      <link>https://morfikov.github.io/post/metadane-plikow-graficznych-exif/</link>
      <pubDate>Thu, 21 Jan 2016 16:58:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/metadane-plikow-graficznych-exif/</guid>
      <description>&lt;p&gt;Każdy plik posiada szereg opisujących go atrybutów. Możemy się o tym przekonać wykorzystując
narzędzia &lt;code&gt;ls&lt;/code&gt; lub &lt;code&gt;stat&lt;/code&gt; . W ich przypadku zostaną nam zwrócone takie informacje jak rozmiar
pliku, data modyfikacji czy też prawa dostępu. To właśnie są metadane opisujące pliki w obszarze
systemu plików i są one wymagane, by system operacyjny działał prawidłowo. To jednak nie jedyne
metadane, z którymi spotykamy się na co dzień. Najlepszym przykładem są zdjęcia czy filmy robione
smartfonami czy też aparatami lub kamerami cyfrowymi. Każdy plik stworzony za pomocą tych urządzeń
zawiera w sobie bardzo rozbudowane informacje, które nie zawsze chcielibyśmy udostępniać. W tym
wpisie skupimy się głównie na &lt;a href=&#34;https://pl.wikipedia.org/wiki/Exchangeable_Image_File_Format&#34;&gt;danych
EXIF&lt;/a&gt; zawartych w plikach graficznych,
które postaramy się wydobyć, zmienić i usunąć.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Całkowite usuwanie plików przy pomocy shred</title>
      <link>https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/</link>
      <pubDate>Tue, 24 Nov 2015 15:11:32 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/usuwanie-plikow-przy-pomocy-shred/</guid>
      <description>&lt;p&gt;W przypadku, gdy musimy pozbyć się jakiegoś pliku, który znajduje się na dysku, to nie jest zalecane
korzystanie z narzędzia &lt;code&gt;rm&lt;/code&gt; . Usuwa ono jedynie odnośnik do pliku, który go identyfikuje w
strukturze systemu plików, tzw. &lt;a href=&#34;https://pl.wikipedia.org/wiki/I-w%C4%99ze%C5%82&#34;&gt;i-węzeł&lt;/a&gt; (i-node).
To co uzyskujemy za pomocą takich narzędzi jak &lt;code&gt;rm&lt;/code&gt; , to jedynie oznaczenie pewnych bloków (tych od
pliku) jako wolne, w których system operacyjny będzie w stanie dokonać zapisu danych późniejszym
czasie. Podczas tej operacji nie są usuwane żadne informacje z dysku, a mając na uwadze ten fakt,
możemy bez problemu tak &amp;quot;usunięty&amp;quot; plik odzyskać. By mieć pewność, że plik zostanie trwale
zniszczony, trzeba go ponownie napisać, np. przy pomocy
&lt;a href=&#34;http://manpages.ubuntu.com/manpages/wily/en/man1/shred.1.html&#34;&gt;shred&lt;/a&gt;, który standardowo jest
dostępny w każdej dystrybucji linux&#39;a i to jemu będzie poświęcony ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Ostatnio używane pliki (recently-used.xbel)</title>
      <link>https://morfikov.github.io/post/ostatnio-uzywane-pliki-recently-used-xbel/</link>
      <pubDate>Mon, 02 Nov 2015 23:54:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ostatnio-uzywane-pliki-recently-used-xbel/</guid>
      <description>&lt;p&gt;Wielu ludzi nie lubi gdy maszyny monitorują każdy ich krok. W tym przypadku chodzi o pliki, które
otwieramy czy zmieniamy podczas codziennej pracy na komputerze. Nasz system domyślnie tworzy listę i
skrupulatnie dodaje do niej nowe pozycje. Ta lista jest przechowywana w pliku &lt;code&gt;recently-used.xbel&lt;/code&gt; ,
który znajduje się w katalogu &lt;code&gt;~/.local/share/&lt;/code&gt; . Gdy popatrzymy na tę funkcjonalność trochę pod
inny kątem, możemy zauważyć, że w pewnych sytuacjach zagraża ona naszej prywatności. Skasowanie tego
pliku nie rozwiązuje problemu, bo jest on tworzony na nowo, a nadawanie atrybutu odporności (
&lt;code&gt;chattr +i&lt;/code&gt; ) nie jest żadnym rozwiązaniem. Na szczęście jest sposób na to by ten mechanizm
dezaktywować i o tym będzie poniższy wpis.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
