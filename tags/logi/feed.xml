<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>logi on Morfitronik</title>
    <link>https://morfikov.github.io/tags/logi/</link>
    <description>Recent content in logi on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Fri, 08 Feb 2019 20:10:41 +0000</lastBuildDate>
    
	<atom:link href="https://morfikov.github.io/tags/logi/feed.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>Jak ustalić nazwę procesu korzystającego z sieci</title>
      <link>https://morfikov.github.io/post/jak-ustalic-nazwe-procesu-korzystajacego-z-sieci/</link>
      <pubDate>Fri, 08 Feb 2019 20:10:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ustalic-nazwe-procesu-korzystajacego-z-sieci/</guid>
      <description>&lt;p&gt;Konfigurując filtr pakietów &lt;code&gt;iptables&lt;/code&gt;/&lt;code&gt;nftables&lt;/code&gt; na Debianie zwykle nie przykładamy większej wagi
do procesów, które chcą nawiązać połączenia wychodzące z naszego linux&#39;owego hosta. Mamy przecież
&amp;quot;skonfigurowany&amp;quot; firewall w łańcuchach &lt;code&gt;INPUT&lt;/code&gt; i &lt;code&gt;FORWARD&lt;/code&gt; i wszelkie zagrożenia z sieci nie
powinny nas dotyczyć. Problem w tym, że jeśli jakiś złowrogi proces zostanie uruchomiony w naszym
systemie, to jest on w stanie komunikować się ze światem zewnętrznym praktycznie bez żadnych
ograniczeń za sprawą braku jakichkolwiek reguł w łańcuchu &lt;code&gt;OUTPUT&lt;/code&gt; . Można oczywiście temu zaradzić
budując zaporę sieciową na bazie &lt;code&gt;cgroups&lt;/code&gt; , gdzie każda aplikacja będzie miała oznaczone pakiety,
przez co będzie można je rozróżnić i zablokować albo przepuścić przez filter. W tym wpisie jednak
nie będziemy się zajmować konstrukcją tego typu FW, tylko spróbujemy sobie odpowiedzieć na pytanie
jak namierzyć proces, który komunikuje się z siecią (lub też próbuje), posiadając jedynie log
&lt;code&gt;iptables&lt;/code&gt;/&lt;code&gt;nftables&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jak zalogować błędy podczas zamykania systemu Debian Linux</title>
      <link>https://morfikov.github.io/post/jak-zalogowac-bledy-podczas-zamykania-systemu-debian-linux/</link>
      <pubDate>Sat, 02 Feb 2019 06:12:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zalogowac-bledy-podczas-zamykania-systemu-debian-linux/</guid>
      <description>&lt;p&gt;By wyłączyć komputer, jego system operacyjny musi pierw zatrzymać (lub też ubić siłowo) wszystkie
działające usługi za wyjątkiem tego mającego PID z numerkiem 1. Zwykle proces zamykania się systemu
Debian Linux nie trwa więcej niż parę sekund ale czasami pojawiają się dziwne problemy, które mogą
to zadanie utrudnić lub też całkowicie uniemożliwić. Nawet jeśli system będzie się w stanie
zresetować, to zanim to nastąpi, to na konsoli mogą pojawić się komunikaty mogące pomóc nam w
zdiagnozowaniu dolegliwości, która doskwiera naszej maszynie. Problem w tym, że część tych
wiadomości nie zostanie nigdy zalogowana do pliku, gdzie moglibyśmy ich poszukać. Dzieje się tak
dlatego, że w pewnym określonym momencie zamykania się systemu trzeba wyłączyć usługę logowania, co
zwykle widać w logu jako &lt;code&gt;systemd-journald[]: Journal stopped&lt;/code&gt; . Gdy dziennik zostanie zatrzymany,
żadna wiadomość, która od tego momentu pojawi się na ekranie, nie zostanie już zalogowana do pliku.
Jeśli teraz pojawią nam się ostrzeżenia lub błędy, a po chwili komputer się zresetuje, to możemy
mieć nie lada problem z ustaleniem przyczyny mimo, że system nam ją zgłasza. Przydałoby się zapisać
te komunikaty, tylko jak to zrobić, skoro usługa logowania jest już nieaktywna?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Apache2: Jak odchudzić nieco plik access.log</title>
      <link>https://morfikov.github.io/post/apache2-jak-odchudzic-nieco-plik-access-log/</link>
      <pubDate>Thu, 04 Aug 2016 11:10:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-jak-odchudzic-nieco-plik-access-log/</guid>
      <description>&lt;p&gt;Mając serwer www oparty o oprogramowanie Apache2, w pewnym momencie zacznie nas nieco przytłaczać
kwestia logowania do pliku &lt;code&gt;/var/log/apache2/access.log&lt;/code&gt; wszystkiego co się nawinie. Jak nazwa pliku
sugeruje, znajdują się w nim komunikaty, które serwer generuje ilekroć tylko ktoś odwiedzi nasz
serwis. Każdy zasób przesłany do klienta, np. style CSS czy obrazki, zostanie zalogowany w powyższym
pliku. Generalnie rzecz ujmując, nie musimy logować wszystkich tych informacji, chyba, że ich
faktycznie potrzebujemy. Trzeba jednak wziąć pod uwagę fakt, że w przypadku obciążonych serwerów,
ilość operacji I/O dysku może być znaczna. Dodatkowo, miejsce na dysku za sprawą takiego obszernego
logu może bardzo szybko się wyczerpać. W tym artykule postaramy się nieco ograniczyć apetyt serwera
Apache2 na logi i oduczymy go logować większość zbędnych komunikatów za sprawą dyrektywy
&lt;code&gt;SetEnvIf&lt;/code&gt;/&lt;code&gt;SetEnvIFNoCase&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>&#34;Internal dummy connection&#34; w logu Apache2 (mpm_prefork)</title>
      <link>https://morfikov.github.io/post/internal-dummy-connection-apache2-mpm_prefork/</link>
      <pubDate>Sat, 30 Jul 2016 20:00:28 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/internal-dummy-connection-apache2-mpm_prefork/</guid>
      <description>&lt;p&gt;Od czasu do czasu przeglądam sobie logi Apache2 w poszukiwaniu pewnych nieprawidłowości. Na dobrą
sprawę, to nie ma tutaj zbytnio dużo roboty, przynajmniej póki co. Niemniej jednak, w pliku
&lt;code&gt;/var/log/apache2/access.log&lt;/code&gt; co jakiś czas pojawiają się komunikaty zawierające &amp;quot;internal dummy
connection&amp;quot;. Za co one odpowiadają i czy można je w zupełności zignorować bez stwarzania zagrożenia
bezpieczeństwa dla serwera www?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie logów w OpenWRT (syslog-ng)</title>
      <link>https://morfikov.github.io/post/szyfrowanie-logow-w-openwrt-syslog-ng/</link>
      <pubDate>Fri, 29 Apr 2016 02:36:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-logow-w-openwrt-syslog-ng/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io
/post/logread-czyli-system-logowania-w-openwrt/&#34;&gt;We wpisie dotyczącym logread&lt;/a&gt;
została podniesiona kwestia przesłania logów przez sieć. OpenWRT jest w stanie tego typu zadanie
realizować po określeniu kilku dodatkowych opcji w pliku &lt;code&gt;/etc/config/system&lt;/code&gt; . Trzeba jednak zdawać
sobie sprawę, że tak przesyłane komunikaty nie będą w żaden sposób zabezpieczone. W sieci domowej
raczej nie musimy sobie zawracać głowy tym mankamentem. Niemniej jednak, gdy w grę wchodzi
przesyłanie logów do zdalnego serwera zlokalizowanego gdzieś w internecie, to taką komunikację
należy zabezpieczyć przed podsłuchem. Niestety OpenWRT standardowo nie wspiera takich udziwnień ale
dysponuje on pakietami, które mogą nam zapewnić taką funkcjonalność. Szyfrowanie logów możemy w
łatwy sposób wdrożyć za pomocą pakietu &lt;code&gt;syslog-ng3&lt;/code&gt; . W nim znajduje się demon &lt;code&gt;syslog-ng&lt;/code&gt; , który
jest kompatybilny w pełni z innymi linux&#39;owymi demonami logowania. Nie powinno zatem być problemów
ze skonfigurowaniem tego całego mechanizmu.&lt;/p&gt;
&lt;p&gt;W OpenWRT w wersji Chaos Calmer nie ma pakietu &lt;code&gt;syslog-ng3&lt;/code&gt; . W efekcie szyfrowanie logów routera
nie jest obecnie możliwe. Ten wpis dotyczy jedynie wydania Barrier Breaker i zostanie zaktualizowany
jak tylko wspomniany pakiet trafi do repozytorium.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Logread, czyli system logowania w OpenWRT</title>
      <link>https://morfikov.github.io/post/logread-czyli-system-logowania-w-openwrt/</link>
      <pubDate>Thu, 28 Apr 2016 21:04:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/logread-czyli-system-logowania-w-openwrt/</guid>
      <description>&lt;p&gt;Każdy szanujący się system, nawet ten najmniejszy na bazie OpenWRT, musi posiadać mechanizm
logowania komunikatów. Logi routera to bardzo ważna rzecz. Jeśli coś dolega naszemu małemu
przyjacielowi, to jest niemal pewne, że właśnie wśród tych wiadomości znajdziemy przyczynę
problemów. Każda usługa systemowa działająca na routerze przesyła logi, które są zbierane przez
demon logowania. W Chaos Calmer odpowiadają za to &lt;code&gt;logd&lt;/code&gt; oraz &lt;code&gt;logread&lt;/code&gt; . Standardowa konfiguracja
logów w OpenWRT nie jest raczej skomplikowana ale niewiele osób wie, że logi routera można zapisywać
w pliku lub przesłać je przez sieć do innego hosta. W tym wpisie postaramy się właśnie zrealizować
te dwa zadania.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jak zdiagnozować kernel OOPS</title>
      <link>https://morfikov.github.io/post/jak-zdiagnozowac-kernel-oops/</link>
      <pubDate>Mon, 22 Feb 2016 18:41:27 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zdiagnozowac-kernel-oops/</guid>
      <description>&lt;p&gt;Kernel linux&#39;a, jak każdy inny program, podczas swojego działania może napotkać nieprzewidzianą
przez programistów sytuację. W przypadku zwykłych aplikacji, pewne błędy krytyczne mogą doprowadzić
do &amp;quot;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Naruszenie_ochrony_pami%C4%99ci&#34;&gt;naruszenia ochrony pamięci&lt;/a&gt;&amp;quot;, co
szerzej jest znane jako segfault. W przypadku wystąpienia tego błędu, proces zwykle jest
unicestwiany. Co jednak w przypadku kernela? Odpowiedź jest prosta: &lt;a href=&#34;https://pl.wikipedia.org/wiki/Kernel_panic&#34;&gt;kernel
panic&lt;/a&gt;, czyli panika kernela, która pozostawia system w
stanie braku jakichkolwiek oznak życia. Są jednak pewne błędy, z którymi kernel jest w stanie sobie
poradzić i odzyskać sprawność w mniejszym lub większym stopniu. Te błędy są nazywane &lt;a href=&#34;http://slacksite.com/slackware/oops.html&#34;&gt;kernel
OOPS&lt;/a&gt;. W tym wpisie postaramy się przeanalizować
przykładowy OOPS i zobaczymy czy uda nam się ustalić przyczynę zaistniałego problemu.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>