<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>openbox on Morfitronik</title>
    <link>https://morfikov.github.io/tags/openbox/</link>
    <description>Recent content in openbox on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sun, 08 Mar 2020 19:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://morfikov.github.io/tags/openbox/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Zmiana DPI w Openbox/Xorg dla monitora HiDPI</title>
      <link>https://morfikov.github.io/post/zmiana-dpi-w-openbox-xorg-dla-monitora-hidpi/</link>
      <pubDate>Sun, 08 Mar 2020 19:00:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-dpi-w-openbox-xorg-dla-monitora-hidpi/</guid>
      <description>&lt;p&gt;Jeśli mieliśmy do czynienia z monitorami wysokiej rozdzielczości, to za pewne natrafiliśmy na
problem zbyt małych czcionek, które czyniły interfejs aplikacji w naszym linux&#39;ie mało czytelnym. W
przypadku środowisk graficznych takich jak GNOME czy KDE5/Plasma5 skalowanie interfejsu i czcionek
powinno odbywać się automatycznie (&lt;a href=&#34;https://wiki.gnome.org/HowDoI/HiDpi&#34;&gt;jeśli nasz ekran ma 192+ DPI i rozdzielczość 1200+ pikseli&lt;/a&gt;)
lub też za sprawą drobnej zmiany w konfiguracji, tak by użytkownik mógł w miarę komfortowo
korzystać z systemu. O ile w przypadku tych pełnowymiarowych środowisk graficznych można w zasadzie
przełączyć tylko jedną opcję i wszystkie jego aplikacje powinny zostać z powodzeniem odpowiednio
zeskalowane, o tyle problem zaczyna się w momencie, gdy mamy mieszane aplikacje lub też zwyczajnie
używamy jedynie prostego menadżera okien dla Xserver&#39;a, np. Openbox i do tego jeszcze nasz
wyświetlacz ma mniejsze DPI niż 192. W takiej sytuacji konfiguracja interfejsu użytkownika i
czcionek dla ekranów wysokiej rozdzielczości może być nie lada wyzwaniem.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Debian: Profilowanie sieci z guessnet, ifplugd i wpasupplicant</title>
      <link>https://morfikov.github.io/post/debian-profilowanie-sieci-guessnet-ifplugd-wpasupplicant/</link>
      <pubDate>Mon, 05 Sep 2016 13:01:08 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/debian-profilowanie-sieci-guessnet-ifplugd-wpasupplicant/</guid>
      <description>&lt;p&gt;Kilka dni temu na &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?id=28903&#34;&gt;forum dug.net.pl&lt;/a&gt; pojawił się
ciekawy wątek dotyczący problemu skonfigurowania profilowanych sieci. Chodzi o to, że praktycznie
każdy z nas jest po części w jakiś sposób mobilny i zabiera laptopa ze sobą w dziwne miejsca. Sieci
w tych lokalizacjach mogą cechować się różnym poziomem bezpieczeństwa. Dlatego też zamiast korzystać
z jednej konfiguracji sieci na linux&#39;ie, można stworzyć szereg profili i w oparciu o nie dostosować
sobie połączenie sieciowe. W tym artykule spróbujemy zaimplementować takie rozwiązanie na Debianie
wyposażonym w menadżer okien Openbox. W skrócie stworzymy automat, który będzie nam działał w
oparciu o pakiety guessnet, &lt;a href=&#34;http://0pointer.de/lennart/projects/ifplugd/&#34;&gt;ifplugd&lt;/a&gt; oraz
&lt;a href=&#34;https://w1.fi/wpa_supplicant/&#34;&gt;wpasupplicant&lt;/a&gt;. Cała konfiguracja zaś sprowadzać się będzie jedynie
do edycji plików &lt;code&gt;/etc/network/interfaces&lt;/code&gt; oraz &lt;code&gt;/etc/wpa_supplicant/wpa_supplicant.conf&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;Niniejszy artykuł został nieco przerobiony po fazach eksperymentów. Przede wszystkim, zrezygnowałem
z zaprzęgania &lt;code&gt;guessnet&lt;/code&gt; do rozpoznawania sieci WiFi i aplikowania roamingu. Zamiast tego zostały
wykorzystane natywne rozwiązania roamingowe oferowane przez &lt;code&gt;wpa_supplicant&lt;/code&gt; . Zaowocowało to
uproszczeniem całej konfiguracji, co przełożyło się na wyeliminowanie pewnych błędów.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Metryki tras interfejsów eth0 i wlan0 w laptopie (metric)</title>
      <link>https://morfikov.github.io/post/metryki-tras-interfejsow-eth0-wlan0-laptop-metric/</link>
      <pubDate>Fri, 02 Sep 2016 17:50:11 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/metryki-tras-interfejsow-eth0-wlan0-laptop-metric/</guid>
      <description>&lt;p&gt;W obecnych czasach posiadanie komputera, który dysponuje kilkoma interfejsami sieciowymi nie jest
niczym niezwykłym. Praktycznie każdy laptop posiada już na pokładzie co najmniej jedną kartę WiFi i
minimum jeden port ethernet. W efekcie czego jesteśmy w stanie podłączyć się do sieci zarówno
przewodowo jak i bezprzewodowo. Problem jednak pojawia się w momencie, gdy chcemy wykorzystywać oba
te interfejsy, z tym, że dysponujemy jedynie niezbyt zaawansowanym menadżerem okien Openbox. Takie
środowiska zwykle nie mają na pokładzie automatów pokroju Network Manager, przez co bardziej
zaawansowana konfiguracja sieci może być dość skomplikowana. Do tej pory wykorzystywałem &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-interfejsow-bond-bonding/&#34;&gt;interfejs
bond0&lt;/a&gt;, by mieć możliwość łatwego
przełączania się miedzy sieciami. Istnieje inny sposób konfiguracji interfejsów &lt;code&gt;eth0&lt;/code&gt; i &lt;code&gt;wlan0&lt;/code&gt; w
pliku &lt;code&gt;/etc/network/interfaces&lt;/code&gt; tak, by działały one nam równolegle i nie powodowały problemów z
połączeniem, a wszystko za sprawą opcji &lt;code&gt;metric&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dynamiczna konfiguracja sieci w oparciu o ifplugd</title>
      <link>https://morfikov.github.io/post/dynamiczna-konfiguracja-sieci-ifplugd/</link>
      <pubDate>Thu, 01 Sep 2016 12:24:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dynamiczna-konfiguracja-sieci-ifplugd/</guid>
      <description>&lt;p&gt;Sporo użytkowników różnego rodzaju linux&#39;ów, zwłaszcza dystrybucji Debian, niezbyt chwali sobie
automaty konfigurujące połączenie sieciowe typu &lt;a href=&#34;https://wiki.gnome.org/Projects/NetworkManager&#34;&gt;Network
Manager&lt;/a&gt;. W sumie nigdy się jemu bliżej nie
przyglądałem ale na necie nie cieszy się on najlepszą opinią. Niemniej jednak, Network Manager
potrafi automatyzować pewne aspekty pracy w sieci. Weźmy przykład korzystania z dwóch różnych pod
względem parametrów sieci przewodowych. Jak się zachowa nasz OS w chwili przełączania się między
tymi sieciami w przypadku, gdy nie będziemy mieli zainstalowanego jakiegoś automatu dynamicznie
konfigurującego połączenie? W przypadku jednej sieci, połączenie będzie nam działać, w przypadku
drugiej zaś napotkamy problemy. W lekkich środowiskach opartych o menadżery okien, np. Openbox, nie
musimy instalować Network Manager&#39;a, by ogarnąć tę kwestię konfiguracyjną. Możemy posiłkować się
demonem &lt;code&gt;ifplugd&lt;/code&gt; i to tym narzędziu będzie ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Osadzanie urxvt na pulpicie przy pomocy openbox&#39;a</title>
      <link>https://morfikov.github.io/post/osadzanie-urxvt-na-pulpicie-przy-pomocy-openboxa/</link>
      <pubDate>Mon, 09 Nov 2015 21:27:51 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/osadzanie-urxvt-na-pulpicie-przy-pomocy-openboxa/</guid>
      <description>&lt;p&gt;Wszyscy wiemy, że ogromna rzesza ludzi nie patrzy w logi systemowe. Nawet jeśli części z nas zdarza
się to raz na jakiś czas, to zwykle nie wtedy, gdy coś złego się dzieje z naszym systemem. W
przypadku jakichkolwiek problemów, mamy spore prawdopodobieństwo, że szereg zdarzeń może zostać
zalogowanych w dzienniku systemowym. Dlaczego zatem nie osadzić jakiegoś terminala na pulpicie, w
którym będą zbierane logi w czasie rzeczywistym? W takim przypadku co kilka (czy kilkanaście) minut
będziemy w stanie podejrzeć wszystkie komunikaty jakie zostały zalogowane przez system. W tym wpisie
postaramy się osadzić na pulpicie terminal urxvt i posłużymy się w tym celu menadżerem okien openbox
.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>