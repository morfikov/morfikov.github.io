<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Apache2 on Morfitronik</title>
    <link>https://morfikov.github.io/tags/apache2/</link>
    <description>Recent content in Apache2 on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Wed, 24 Aug 2016 22:52:29 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/apache2/feed.xml" rel="self" type="application/rss+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Request body exceeds maximum size (131072) for SSL buffer</title>
      <link>https://morfikov.github.io/post/request-body-exceeds-maximum-size-131072-for-ssl-buffer/</link>
      <pubDate>Wed, 24 Aug 2016 22:52:29 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/request-body-exceeds-maximum-size-131072-for-ssl-buffer/</guid>
      <description>&lt;p&gt;Dziś chciałem zaktualizować jeden z moich bardziej obszerniejszych wpisów na tym blogu ale
oczywiście nie mogło odbyć się bez problemów. Gdy już wszystkie poprawki zostały naniesione i cały
artykuł trafił do formularza WordPress&#39;a, przeglądarka zwróciła mi błąd &lt;code&gt;Request Entity Too Large&lt;/code&gt; .
Z początku nie wiedziałem o co chodzi ale, że ten aktualizowany artykuł był naprawdę długi, to
domyśliłem się, że chodzi o ilość bajtów, które chciałem przesłać w zapytaniu. Przeglądając logi
serwera Apache2, znalazłem tam jeszcze dodatkowo komunikaty &lt;code&gt;[ssl:error] request body exceeds maximum size (131072) for SSL buffer&lt;/code&gt; oraz &lt;code&gt;[ssl:error] could not buffer message body to allow SSL renegotiation to proceed&lt;/code&gt; . Może ta cała sytuacja brzmi groźnie ale wybrnięcie z niej jest wręcz
banalne. Wystarczy dostosować wartość dyrektywy &lt;code&gt;SSLRenegBufferSize&lt;/code&gt; w konfiguracji serwera Apache2.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Chroot Apache2 vs dyrektywa open_basedir w PHP</title>
      <link>https://morfikov.github.io/post/chroot-apache2-vs-dyrektywa-open_basedir-w-php/</link>
      <pubDate>Mon, 22 Aug 2016 22:03:02 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/chroot-apache2-vs-dyrektywa-open_basedir-w-php/</guid>
      <description>&lt;p&gt;Kilka dni temu wpadł mi w oko artykuł na temat wykonania &lt;a href=&#34;https://nfsec.pl/root/5874&#34;&gt;chroot serwera
Apache2&lt;/a&gt;. Problem z tamtym tekstem jest taki, że nie uwzględnia on
serwera bazy danych MySQL. W efekcie, taki chroot&#39;owany Apache2 będzie miał problemy z połączeniem
się do bazy, a nasz serwis bez niej raczej nie będzie działał prawidłowo. Przydałoby się zatem
dopracować nieco ten artykuł i wypracować takie rozwiązanie, które nie popsuje przy okazji naszego
serwisu www. Dlatego też w tym wpisie wykonamy sobie chroot zarówno serwera Apache2 z obsługą PHP i
bazy danych MySQL za sprawą modułu &lt;code&gt;unixd&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Apache2: Konfiguracja OCSP Stapling</title>
      <link>https://morfikov.github.io/post/apache2-konfiguracja-ocsp-stapling/</link>
      <pubDate>Sat, 06 Aug 2016 19:16:09 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-konfiguracja-ocsp-stapling/</guid>
      <description>&lt;p&gt;Serwery udostępniające nam różnego rodzaju strony www na protokole SSL/TLS posiadają certyfikaty,
które są ważne przez pewien okres czasu. Z reguły jest to rok albo, jak w przypadku
&lt;a href=&#34;https://morfikov.github.io/post/certyfikat-letsencrypt-dla-bloga-certbot/&#34;&gt;letsencrypt&lt;/a&gt;, są to 3 miesiące.
Taki certyfikat może zostać unieważniony z różnych przyczyn ale informacja o tym fakcie musi trafić
do wszystkich klientów odwiedzających taki serwis www. Do tego celu mogą posłużyć dwa mechanizmy.
Pierwszym z nich są listy &lt;a href=&#34;https://pl.wikipedia.org/wiki/Lista_uniewa%C5%BCnionych_certyfikat%C3%B3w&#34;&gt;Certificate Revocation
Lists&lt;/a&gt; (CRL). Drugim zaś
jest &lt;a href=&#34;https://pl.wikipedia.org/wiki/Online_Certificate_Status_Protocol&#34;&gt;Online Certificate Status
Protocol&lt;/a&gt; (OCSP). W tym wpisie
postaramy się zaimplementować to drugie rozwiązanie na serwerze Apache2.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Apache2: Moduł evasive, ipset i iptables (anty DOS/DDOS)</title>
      <link>https://morfikov.github.io/post/apache2-modul-evasive-ipset-iptables/</link>
      <pubDate>Sat, 06 Aug 2016 09:13:20 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-modul-evasive-ipset-iptables/</guid>
      <description>&lt;p&gt;Apache2 ma kilka ciekawych modułów, które mogą uchronić nasz serwer www przed atakami DOS i DDOS.
Jednym z nich jest moduł &lt;code&gt;evasive&lt;/code&gt; . Nie jest on jednak oficjalnym modułem i brak o nim
jakiejkolwiek wzmianki w oficjalnej dokumentacji na stronie Apache2. Niemniej jednak, jest to bardzo
prosty moduł składający się dosłownie z kilku dyrektyw, które są w stanie zablokować zapytania o
zasoby serwera w przypadku, gdy zostanie przekroczony pewien ustalony przez nas limit. Dodatkowo,
ten moduł może współgrać z filtrem &lt;code&gt;iptables&lt;/code&gt; oraz &lt;code&gt;ipset&lt;/code&gt; , dając nam możliwość wygodnego
blokowania uporczywych klientów na poziomie pakietów sieciowych.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Problemy z dyrektywą SSLOpenSSLConfCmd w Apache2</title>
      <link>https://morfikov.github.io/post/problemy-z-dyrektywa-sslopensslconfcmd-w-apache2/</link>
      <pubDate>Fri, 05 Aug 2016 15:52:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/problemy-z-dyrektywa-sslopensslconfcmd-w-apache2/</guid>
      <description>&lt;p&gt;W stabilnej dystrybucji linux&#39;a Debian niewiele rzeczy ulega zmianie w przeciągu roku czy dwóch lat.
Dlatego też ta gałąź jest wykorzystywana głównie w przypadku serwerów, min. na tym VPS. Na co dzień
jednak korzystam z Debiana SID, czyli gałęzi niestabilnej, która jest nieco bardziej aktualna i
przystosowana do otaczającej nas tej wirtualnej rzeczywistości. Chodzi generalnie o nowsze
oprogramowanie implementujące całą masę ficzerów, których starsze wersje nie posiadają. W tym
przypadku problem dotyczy serwera Apache2, który ostatnimi czasy wypracował szereg mechanizmów
obronnych adresujących ataki na protokół SSL/TLS. Jedną z podatności jest słaba liczba pierwsza
wykorzystywana w &lt;a href=&#34;https://pl.wikipedia.org/wiki/Protok%C3%B3%C5%82_Diffiego-Hellmana&#34;&gt;protokole Diffie-Hellman&#39;a&lt;/a&gt;. Ten problem można stosunkowo łatwo poprawić w
nowszej wersji Apache2 wykorzystując dyrektywę &lt;code&gt;SSLOpenSSLConfCmd&lt;/code&gt; . W starszych wersjach ona
niestety nie działa. Niemniej jednak, w dalszym ciągu możemy użyć własnych parametrów dla protokołu
Diffie-Hellman&#39;a, z tym, że trzeba to zrobić nieco inaczej.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Apache2: Jak odchudzić nieco plik access.log</title>
      <link>https://morfikov.github.io/post/apache2-jak-odchudzic-nieco-plik-access-log/</link>
      <pubDate>Thu, 04 Aug 2016 11:10:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-jak-odchudzic-nieco-plik-access-log/</guid>
      <description>&lt;p&gt;Mając serwer www oparty o oprogramowanie Apache2, w pewnym momencie zacznie nas nieco przytłaczać
kwestia logowania do pliku &lt;code&gt;/var/log/apache2/access.log&lt;/code&gt; wszystkiego co się nawinie. Jak nazwa pliku
sugeruje, znajdują się w nim komunikaty, które serwer generuje ilekroć tylko ktoś odwiedzi nasz
serwis. Każdy zasób przesłany do klienta, np. style CSS czy obrazki, zostanie zalogowany w powyższym
pliku. Generalnie rzecz ujmując, nie musimy logować wszystkich tych informacji, chyba, że ich
faktycznie potrzebujemy. Trzeba jednak wziąć pod uwagę fakt, że w przypadku obciążonych serwerów,
ilość operacji I/O dysku może być znaczna. Dodatkowo, miejsce na dysku za sprawą takiego obszernego
logu może bardzo szybko się wyczerpać. W tym artykule postaramy się nieco ograniczyć apetyt serwera
Apache2 na logi i oduczymy go logować większość zbędnych komunikatów za sprawą dyrektywy
&lt;code&gt;SetEnvIf&lt;/code&gt;/&lt;code&gt;SetEnvIFNoCase&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Cache-Control, Last-Modified, ETag i Expires w Apache2</title>
      <link>https://morfikov.github.io/post/cache-control-last-modified-etag-i-expires-w-apache2/</link>
      <pubDate>Mon, 01 Aug 2016 18:50:48 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/cache-control-last-modified-etag-i-expires-w-apache2/</guid>
      <description>&lt;p&gt;Każda przeglądarka internetowa potrafi buforować dane w swoim cache w celach optymalizacji
przeglądanych stron www. Dzięki temu, szereg elementów odwiedzonych już witryn nie musi być
ponownie pobieranych z serwera. Zyskuje na tym nie tylko serwer ale również i sam klient, któremu
strona ładuje się parokrotnie szybciej. Pod ten mechanizm podpadają nie tylko pliki graficzne ale
również style CSS, skrypty JS, a nawet pliki &lt;code&gt;.html&lt;/code&gt; . Generalnie rzecz ujmując, wszystko co serwer
www jest w stanie przesłać przeglądarce. Problemem może jednak się okazać zbyt krótki/długi okres
ważności cache. Jeśli ten czas jest za krótki, to elementy strony będą niepotrzebnie utylizować
łącze, nie tylko nasze ale również i serwera www. Z kolei, jeśli okres ważności będzie za długi,
to będziemy odwiedzać nieaktualną stronę. Optymalnym rozwiązaniem byłaby taka konfiguracja serwera
www, gdzie dla konkretnych elementów strony sami moglibyśmy ustalić czas ważności cache. Apache2
daje nam taką możliwość przez ustawienie nagłówków HTTP &lt;code&gt;Cache-Control&lt;/code&gt; , &lt;code&gt;Expires&lt;/code&gt; , &lt;code&gt;ETag&lt;/code&gt; oraz
&lt;code&gt;Last-Modified&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>&#34;Internal dummy connection&#34; w logu Apache2 (mpm_prefork)</title>
      <link>https://morfikov.github.io/post/internal-dummy-connection-apache2-mpm_prefork/</link>
      <pubDate>Sat, 30 Jul 2016 20:00:28 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/internal-dummy-connection-apache2-mpm_prefork/</guid>
      <description>&lt;p&gt;Od czasu do czasu przeglądam sobie logi Apache2 w poszukiwaniu pewnych nieprawidłowości. Na dobrą
sprawę, to nie ma tutaj zbytnio dużo roboty, przynajmniej póki co. Niemniej jednak, w pliku
&lt;code&gt;/var/log/apache2/access.log&lt;/code&gt; co jakiś czas pojawiają się komunikaty zawierające &amp;quot;internal dummy
connection&amp;quot;. Za co one odpowiadają i czy można je w zupełności zignorować bez stwarzania zagrożenia
bezpieczeństwa dla serwera www?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Certyfikat Let&#39;s Encrypt dla bloga WordPress (certbot)</title>
      <link>https://morfikov.github.io/post/certyfikat-letsencrypt-dla-bloga-certbot/</link>
      <pubDate>Sat, 23 Jul 2016 12:00:28 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/certyfikat-letsencrypt-dla-bloga-certbot/</guid>
      <description>&lt;p&gt;Jeszcze nie tak dawno temu, rzadko który serwis internetowy wykorzystywał certyfikaty SSL/TLS do
zabezpieczenia komunikacji między serwerem, a łączącymi się do niego klientami. W dalszym ciągu
jednak notuje się strony bez &amp;quot;zielonej kłódki&amp;quot; ale na szczęście jest ich coraz mniej w naszym
otoczeniu. Liczbę tych stron można by z powodzeniem ograniczyć jeszcze bardziej, gdyby takie
certyfikaty były za free, łatwe do zaimplementowania i dostępne praktycznie dla każdego od tak. No i
na dobrą sprawę są, tylko ludzie jeszcze nie zdają sobie z tego sprawy. Istnieje bowiem &lt;a href=&#34;https://letsencrypt.org/&#34;&gt;projekt
Let&#39;s Encrypt&lt;/a&gt;, który umożliwia stosunkowo bardzo proste wdrożenie
certyfikatu na serwerze www opartym, np. o oprogramowanie Apache2. W tym wpisie zobaczymy jak ta
cała procedura implementacji certyfikatu SSL/TLS przebiega.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zablokować hotlink&#39;i w Apache2</title>
      <link>https://morfikov.github.io/post/zablokowac-hotlink-apache2/</link>
      <pubDate>Wed, 20 Jul 2016 18:55:21 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zablokowac-hotlink-apache2/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Hotlink&#34;&gt;Hotlink lub hotlinking&lt;/a&gt; to proceder wykorzystywania zasobów
(plików) jednej strony www przez inny serwis internetowy. Chodzi generalnie o to, że materiały,
które pojawiają się w obcych serwisach, fizycznie w dalszym ciągu są hostowane, np. na naszym
serwerze. W taki sposób osoba, która linkuje do naszych plików &lt;code&gt;.jpg&lt;/code&gt; , &lt;code&gt;.png&lt;/code&gt; , &lt;code&gt;.mp3&lt;/code&gt; czy nawet
&lt;code&gt;.css&lt;/code&gt; i tworzy swój serwis w oparciu o nie, nie ponosi przy tym praktycznie żadnego obciążenia ze
swojej strony. Cały ten ciężar jest spychany na nasz serwer, co zjada nam transfer i zapychając
łącze. W tym krótkim wpisie postaramy się zablokować możliwość hotlink&#39;owania przez inne serwisy
www w Apache2.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>HTTP Strict Transport Security (HSTS) w Apache2</title>
      <link>https://morfikov.github.io/post/http-strict-transport-security-hsts-apache2/</link>
      <pubDate>Tue, 19 Jul 2016 19:08:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/http-strict-transport-security-hsts-apache2/</guid>
      <description>&lt;p&gt;Ostatnio na niebezpieczniku czytałem &lt;a href=&#34;https://niebezpiecznik.pl/post/podroze-kosztuja/&#34;&gt;taki oto post&lt;/a&gt;. Historia jak historia, nieco długa ale
mniej więcej w połowie pojawiła się informacja na temat nagłówków HSTS (&lt;a href=&#34;https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security&#34;&gt;HTTP Strict Transport
Security&lt;/a&gt;), który jest przesyłany w zapytaniach HTTP/HTTPS. Postanowiłem nieco się zainteresować
tym tematem i zbadać czym są te nagłówki HSTS i w jaki sposób są one w stanie poprawić
bezpieczeństwo protokołów SSL/TLS wykorzystywanych podczas szyfrowania zawartości stron
internetowych.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Certyfikat chroniący wp-login.php i wp-admin/</title>
      <link>https://morfikov.github.io/post/certyfikat-chroniacy-wp-login-php-wp-admin/</link>
      <pubDate>Tue, 19 Jul 2016 14:07:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/certyfikat-chroniacy-wp-login-php-wp-admin/</guid>
      <description>&lt;p&gt;Jednym z bardziej wyrafinowanych sposobów ochrony zasobów (katalogów) na serwerze www opartym o
oprogramowanie Apache2 jest wykorzystanie certyfikatów klienckich. Tego typu zabezpieczenie można
jednak zastosować tylko i wyłącznie w przypadku stron, które korzystają z szyfrowania SSL/TLS. Dla
przykładu weźmy sobie blog WordPress&#39;a, gdzie mamy katalog &lt;code&gt;wp-admin/&lt;/code&gt; i plik &lt;code&gt;wp-login.php&lt;/code&gt; .
Formularz logowania oraz panel admina zwykle są szyfrowane. Zatem każdy taki blog powinien robić już
użytek z tunelu SSL/TLS w mniejszym lub większym stopniu. Jeśli teraz mamy dość niestandardową
instalację WordPress&#39;a, to przy pomocy certyfikatów możemy weryfikować użytkowników, którzy chcą
uzyskać dostęp do tych w/w lokalizacji. Jest to nieco inne podejście w stosunku do tego, które
zostało opisane w artykule o &lt;a href=&#34;https://morfikov.github.io/post/wordpress-ukrycie-wp-login-php-oraz-wp-admin/&#34;&gt;ukrywaniu wp-login.php oraz
wp-admin&lt;/a&gt;, gdzie był
wykorzystywany moduł &lt;code&gt;mod_rewrite&lt;/code&gt; oraz dyrektywy &lt;code&gt;Files&lt;/code&gt; i &lt;code&gt;MatchFiles&lt;/code&gt; . Takie certyfikaty
klienckie dają nam jednak większe pole manewru, bo identyfikują konkretnego użytkownika chcącego
uzyskać dostęp do zasobów serwera. Ten wpis ma na celu pokazanie w jaki sposób zaimplementować
obsługę certyfikatów klienckich w Apache2.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Tworzenie repozytorium przy pomocy reprepro</title>
      <link>https://morfikov.github.io/post/tworzenie-repozytorium-przy-pomocy-reprepro/</link>
      <pubDate>Wed, 07 Oct 2015 17:37:20 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/tworzenie-repozytorium-przy-pomocy-reprepro/</guid>
      <description>&lt;p&gt;Ten kto tworzył kiedyś paczki &lt;code&gt;.deb&lt;/code&gt; wie, że cały proces może w końcu człowieka nieco przytłoczyć.
Paczka, jak to paczka, budowana jest ze źródeł i konfigurowana przez jej opiekuna. Z reguły ludzie
instalują kompilowane programy via &lt;code&gt;make install&lt;/code&gt; . Niektórzy idą o krok dalej i używają do tego
celu narzędzi typu &lt;code&gt;checkinstall&lt;/code&gt; . I wszystko jest w miarę w porządku, przynajmniej jeśli chodzi o
utrzymywanie jednej paczki. Przeprowadzamy kompilację tylko raz, po czym instalujemy dany pakiet i
zapominamy o nim. Niemniej jednak, tego typu postępowanie może doprowadzić nasz system na skraj
niestabilności. W tym poście nie będziemy zajmować się zbytnio sposobem w jaki powinno się tworzyć
paczki &lt;code&gt;.deb&lt;/code&gt; , a jedynie tym jak je przechowywać. Do tego celu potrzebne jest nam repozytorium,
które zbudujemy w oparciu o oprogramowanie &lt;code&gt;reprepro&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Moduł ssl w Apache2</title>
      <link>https://morfikov.github.io/post/modul-ssl-w-apache/</link>
      <pubDate>Sat, 05 Sep 2015 18:10:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/modul-ssl-w-apache/</guid>
      <description>&lt;p&gt;Przy okazji uszczelniania serwera Apache2, przypomniał mi się &lt;a href=&#34;https://morfikov.github.io/post/logjam-czyli-nowa-podatnosc-w-ssltls/&#34;&gt;atak
logjam&lt;/a&gt; , przez który to było niemałe
zamieszanie. Pamiętam, że w tamtym czasie próbowałem zabezpieczyć swój serwer testowy, by był na tę
formę ataku odporny. Niemniej jednak, wersja Apache2, która w tamtym czasie była u mnie
zainstalowana, nie do końca dawała taką możliwość. Dziś podszedłem do tej kwestii jeszcze raz i w
oparciu &lt;a href=&#34;https://weakdh.org/sysadmin.html&#34;&gt;o ten link&lt;/a&gt; udało mi się poprawnie skonfigurować mój
serwer www.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Migracja certyfikatów OpenSSL z SHA-1</title>
      <link>https://morfikov.github.io/post/migracja-certyfikatow-openssl-z-sha-1/</link>
      <pubDate>Sat, 05 Sep 2015 17:15:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/migracja-certyfikatow-openssl-z-sha-1/</guid>
      <description>&lt;p&gt;Szukając co by tutaj jeszcze poprawić w moim środowisku testowym, w którym działa między innymi
apache, natrafiłem na komunikat w firefoxie, który oznajmił mi, że certyfikat mojego serwera
korzysta z przestarzałego już algorytmu mieszającego (hash). W tym przypadku jest to SHA-1. &lt;a href=&#34;https://blog.mozilla.org/security/2014/09/23/phasing-out-certificates-with-sha-1-based-signature-algorithms/&#34;&gt;Jak
można przeczytać na blogu
mozilli&lt;/a&gt;,
algorytm SHA-1 wypadł z łask jakiś czas temu i obecnie nie zaleca się jego używania ze względów
bezpieczeństwa. Postanowiłem zatem poprawić tę lukę.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>WordPress: Ukrycie wp-login.php oraz wp-admin/</title>
      <link>https://morfikov.github.io/post/wordpress-ukrycie-wp-login-php-oraz-wp-admin/</link>
      <pubDate>Sun, 31 May 2015 16:19:13 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wordpress-ukrycie-wp-login-php-oraz-wp-admin/</guid>
      <description>&lt;p&gt;By dokonywać jakichkolwiek zmian w WordPressie (i mowa tu nie tylko o dodawaniu treści ale także
zmianie jego plików źródłowych), to musimy uzyskać dostęp do panelu administracyjnego, a tu z kolei
możemy się dostać tylko za pośrednictwem formularza logowania. Panel admina możemy wywołać przez
dopisanie do adresu strony &lt;code&gt;wp-admin/&lt;/code&gt; , z tym, że jeśli nie jesteśmy zalogowani, to automatycznie
zostaniemy przekierowani na &lt;code&gt;wp-login.php&lt;/code&gt; . Nie oznacza to bynajmniej, że nie możemy wykonać
zapytania do plików znajdujących się w katalogu &lt;code&gt;wp-admin/&lt;/code&gt; . Obie te powyższe lokalizacje muszą być
traktowane ze szczególną ostrożnością, a dostęp do nich limitowany i bardzo restrykcyjny.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Problemy wynikające z używania pliku .htaccess</title>
      <link>https://morfikov.github.io/post/problemy-wynikajace-z-uzywania-pliku-htaccess/</link>
      <pubDate>Tue, 26 May 2015 13:25:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/problemy-wynikajace-z-uzywania-pliku-htaccess/</guid>
      <description>&lt;p&gt;Na stronie Apache jest &lt;a href=&#34;http://httpd.apache.org/docs/2.0/howto/htaccess.html#when&#34;&gt;kawałek ciekawego
artykułu&lt;/a&gt; na temat zagrożeń jakie niesie
ze sobą stosowanie pliku &lt;code&gt;.htaccess&lt;/code&gt; w katalogach stron trzymanych na serwerze wwww. Oczywiście, w
pewnych sytuacjach, takich jak np. hostingi, nie będziemy mieć innego wyboru jak zdać się na ten
plik ale jeśli mamy bezpośredni dostęp do konfiguracji Apache, możemy przenieść wszystkie te wpisy z
pliku &lt;code&gt;.htaccess&lt;/code&gt; i poprawić tym bezpieczeństwo witryny jak i po części wydajność samego serwera
www.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wymuszenie SSL/TLS przy pomocy vhost&#39;ów w Apache2</title>
      <link>https://morfikov.github.io/post/wymuszenie-ssl-tls-przy-pomocy-vhostow-apache2/</link>
      <pubDate>Tue, 26 May 2015 11:24:13 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wymuszenie-ssl-tls-przy-pomocy-vhostow-apache2/</guid>
      <description>&lt;p&gt;Mając na stronie www formularze logowania czy rejestracji (ewentualnie panele administracyjne),
rozmyślnym krokiem jest implementacja protokołu SSL/TLS. Jeśli mamy potrzebę, możemy także pokusić
się o zaszyfrowanie całego ruchu w obrębie naszej witryny. Problem w tym, że odwiedzający naszą
stronę użytkownicy mogą korzystać z linków, czy wpisywać adresy, które nie rozpoczynają się od
&lt;code&gt;https://&lt;/code&gt; , a jedynie od &lt;code&gt;http://&lt;/code&gt; . W takim przypadku, nawet jeśli szyfrujemy ruch w serwisie, to
odwiedzenie tego typu adresu zwróci nam stronę kanałem nieszyfrowanym, co może godzić w
bezpieczeństwo samej strony jak i również w naszą/czyjąś prywatność. W tym krótki artykule
spróbujemy tak skonfigurować serwer Apache2, by przekierował tego typu zapytania i słał je
szyfrowanym tunelem.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
