<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>moduły-kernela on Morfitronik</title>
    <link>https://morfikov.github.io/tags/modu%C5%82y-kernela/</link>
    <description>Recent content in moduły-kernela on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Tue, 28 Jul 2020 19:39:00 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/modu%C5%82y-kernela/feed.xml" rel="self" type="application/rss" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czym jest linux kernel driver binding</title>
      <link>https://morfikov.github.io/post/czym-jest-linux-kernel-driver-binding/</link>
      <pubDate>Tue, 28 Jul 2020 19:39:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czym-jest-linux-kernel-driver-binding/</guid>
      <description>&lt;p&gt;Bawiąc się ostatnio QEMU/KVM na swoim laptopie z zainstalowanym Debianem natrafiłem na ciekawe
zagadnienie związane z wirtualizacją, tj. z PCI passthrough. Nie chodzi mi tutaj o samą technikę
PCI passthrough ale o dobór sterowników do urządzeń działających pod kontrolą linux. Każdy sprzęt,
który ma działać w systemie, musi mieć załadowany w pamięci RAM stosowny moduł kernela. Te moduły
zwykle są ładowane automatycznie podczas pracy systemu, np. gdy podłączamy nowy sprzęt do komputera
(można też te moduły ładować i ręcznie via &lt;code&gt;modprobe&lt;/code&gt; ). Gdy nasz linux z jakiegoś powodu dobierze
niewłaściwy (z naszego punktu widzenia) moduł dla jakiegoś urządzenia, to możemy to urządzenie
odłączyć od komputera, a moduł bez problemu wyładować, po czym dokonać stosownych poprawek w
systemie. Problem zaczyna się w sytuacji, gdy mamy do czynienia ze sprzętem, którego nie da się od
komputera fizycznie odłączyć, np. wbudowana w płytę główną karta dźwiękowa, czy też wbudowana
grafika bezpośrednio w CPU. Podobnie sprawa wygląda w przypadku wkompilowania modułów na stałe w
kernel -- jak wyładować moduł, którego się nie da wyładować? By w takich sytuacjach zmienić
przypisany urządzeniu sterownik trzeba dodać parę plików w katalogach &lt;code&gt;/etc/modules-load.d/&lt;/code&gt; /
&lt;code&gt;/etc/modprobe.d/&lt;/code&gt; oraz zrestartować maszynę, tak by podczas fazy boot kernel dobrał sprzętowi
pożądane przez nas moduły i ich konfigurację. Niemniej jednak, istnieje prostszy sposób na zmianę
sterownika działającego w systemie sprzętu i to bez potrzeby fizycznego restartowania maszyny.
Chodzi o mechanizm ręcznego przypisywania urządzeń do konkretnych sterowników (&lt;a href=&#34;https://lwn.net/Articles/143397/&#34;&gt;manual driver
binding and unbinding&lt;/a&gt;).&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Moduł LKRG (Linux Kernel Runtime Guard)</title>
      <link>https://morfikov.github.io/post/modul-lkrg-linux-kernel-runtime-guard/</link>
      <pubDate>Tue, 09 Jun 2020 20:56:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/modul-lkrg-linux-kernel-runtime-guard/</guid>
      <description>&lt;p&gt;Jakiś czas temu opisywałem &lt;a href=&#34;https://morfikov.github.io
/post/modul-tpe-trusted-path-execution-dla-kernela-linux/&#34;&gt;moduł TPE&lt;/a&gt; (Trusted Path Execution) dla kernela linux, który jest w
stanie dość znacznie poprawić bezpieczeństwo naszego systemu. Ostatnio jednak natknąłem się na
&lt;a href=&#34;https://www.openwall.com/lkrg/&#34;&gt;moduł LKRG&lt;/a&gt; (Linux Kernel Runtime Guard), którego to zadaniem jest stać na straży samego jądra
operacyjnego i chronić je w czasie rzeczywistym przed różnego rodzaju zagrożeniami poprzez
wykrywanie eksploitów wykorzystujących luki w jego mechanizmach bezpieczeństwa. Jako, że ja
bardzo lubię zbroić swojego Debiana, to postanowiłem się przyjrzeć nieco bliżej temu całemu LKRG i
sprawdzić jego użyteczność. Trzeba jednak wiedzieć, że LKRG jest dostarczany w formie osobnego
modułu zamiast łaty na kernel, przez co trzeba będzie także postarać się o automatyzację pewnych
rzeczy, m.in. procesu budowania modułu przy aktualizacji kernela via DKMS.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Moduł TPE (Trusted Path Execution) dla kernela linux</title>
      <link>https://morfikov.github.io/post/modul-tpe-trusted-path-execution-dla-kernela-linux/</link>
      <pubDate>Fri, 22 Mar 2019 20:10:11 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/modul-tpe-trusted-path-execution-dla-kernela-linux/</guid>
      <description>&lt;p&gt;Użytkownicy linux&#39;a są zwykle chronieni przez mechanizmy bezpieczeństwa, które ten system jest w
stanie zaoferować. Oczywiście deweloperzy różnych dystrybucji, np. Debiana, dokładają wszelkich
możliwych starań, by system jako całość był wstępnie skonfigurowany tak, by końcowy użytkownik nie
musiał za wiele majstrować przy zabezpieczeniach i mógł się czuć i być (przynajmniej względnie)
bezpieczny. No i faktycznie złowrogie oprogramowanie ma czasem spore problemy dostać się do maszyny,
którą operuje linux. Niemniej jednak, gdy już taki syf się do systemu dostanie, to zwykle niewiele
dzieli go od przejęcia kontroli nad komputerem. Może i część zabezpieczeń linux&#39;a zadziała i sprawi,
że taki wirus/trojan czy nawet zwykły skrypt będzie miał ograniczone pole manewru, to i tak będzie
on mógł przeprowadzić te akcje, które zwyczajny użytkownik systemu (nie root) jest zwykle w stanie
poczynić, np. odebrać dźwięk i video ze stosownych urządzeń i przesłać te dane przez sieć. My z
kolei możemy nawet tego faktu nie być świadomi. Jasne, że powinno się zwracać uwagę na to jakie
pliki się pobiera z internetu i nie uruchamiać wszystkiego lekkomyślnie ale też trzeba mieć na
uwadze fakt, że często jedna maszyna jest współdzielona, np. z członkami rodziny i oni już
niekoniecznie muszą władać zaawansowaną wiedza z zakresu IT, by przewidzieć wszystkie możliwe
zagrożenia czyhające na nich w sieci. Można za to postarać się, by uczynić naszą maszynę nieco
bardziej odporną na niezbyt przemyślane zachowania użytkowników jej systemu operacyjnego. Jednym z
kroków, które możemy podjąć, jest wdrożenie mechanizmu Trusted Path Execution (TPE), który póki co
jest dostępny jedynie w &lt;a href=&#34;https://patchwork.kernel.org/patch/9773791/&#34;&gt;formie patch&#39;a&lt;/a&gt; na kernel
linux&#39;a lub też jako jego &lt;a href=&#34;https://github.com/cormander/tpe-lkm&#34;&gt;osobny moduł&lt;/a&gt; oferujący sporo
więcej możliwości w stosunku do wspomnianej wcześniej łaty. W niniejszym artykule rzucimy sobie
okiem na ten cały mechanizm TPE i zobaczymy jak jest on w stanie uchronić nasz OS przed niezbyt
zaawansowaną ludzką inteligencją.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ręcznie zweryfikować sygnaturę modułu kernela linux</title>
      <link>https://morfikov.github.io/post/jak-recznie-zweryfikowac-sygnature-modulu-kernela-linux/</link>
      <pubDate>Sat, 26 Jan 2019 10:10:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-recznie-zweryfikowac-sygnature-modulu-kernela-linux/</guid>
      <description>&lt;p&gt;Bawiąc się ostatnio kernelem linux na dystrybucji Debian i opcjami mającymi poprawić jego
bezpieczeństwo, włączyłem
sobie &lt;a href=&#34;https://morfikov.github.io
/post/automatyczne-podpisywanie-modulow-kernela-przez-dkms/&#34;&gt;mechanizm podpisywania modułów&lt;/a&gt;.
W ten sposób żaden zewnętrzny moduł nie zostanie załadowany przez jądro operacyjne, no chyba, że
taki moduł będzie podpisany przez ten sam klucz co i kernel. Zdziwiłem się odrobinę, gdy moim
oczom pokazał się hash &lt;code&gt;md4&lt;/code&gt; w wyjściu polecenia &lt;code&gt;modinfo&lt;/code&gt; . Jak się okazało później, to niezbyt
dokładne zinterpretowanie wiadomości PKCS#7 przez &lt;code&gt;kmod&lt;/code&gt; było (i nadal jest) wynikiem &lt;a href=&#34;https://bugzilla.redhat.com/show_bug.cgi?id=1320921&#34;&gt;błędu
obecnego w tym pakiecie od już paru lat&lt;/a&gt;. W
efekcie &lt;code&gt;modinfo&lt;/code&gt; nie jest w stanie zweryfikować tej sygnatury, a w moim umyśle zaistniało pytanie:
czy istnieje w ogóle możliwość manualnego sprawdzenia czy ta sygnatura jest w porządku? Kernel co
prawda ten cały zabieg przeprowadza automatycznie ale przydałoby się ręcznie zweryfikować
poprawność sygnatury modułu i przy okazji obadać sobie co tak naprawdę się dzieje podczas tego
procesu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Automatyczne podpisywanie modułów kernela przez DKMS</title>
      <link>https://morfikov.github.io/post/automatyczne-podpisywanie-modulow-kernela-przez-dkms/</link>
      <pubDate>Sat, 05 Jan 2019 04:10:10 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/automatyczne-podpisywanie-modulow-kernela-przez-dkms/</guid>
      <description>&lt;p&gt;Budując kernel linux&#39;a trzeba zastanowić się nad kwestią modułów, które nie są wbudowane
bezpośrednio w samo jądro operacyjne. Nie chodzi tutaj bezpośrednio o funkcjonalność kernela,
którą można zbudować jako moduł w procesie jego kompilacji ale raczej o wszystkie zewnętrzne
moduły, które przez zespół kernela są traktowane jako &lt;code&gt;out-of-tree&lt;/code&gt; . By poprawić nieco
bezpieczeństwo związane z takimi modułami, można wdrożyć podpisy cyfrowe, które takie moduły
muszą okazać podczas próby załadowania ich w systemie. Gdy moduł nie został podpisany, to kernel
go nie załaduje zwracając przy tym błąd &lt;code&gt;modprobe: ERROR: could not insert &#39;module&#39;: Required key not available&lt;/code&gt; . W ten sposób można ochronić się przed częścią ataków, w których moduły pochodzenia
trzeciego mogą zostać załadowane i poczynić nam ogromne spustoszenie w systemie. Problem w tym, że
w dystrybucji Debian wykorzystywany jest mechanizm DKMS (Dynamic Kernel Module Support). Może i
mamy dzięki niemu możliwość instalacji w systemie całej masy dodatkowych modułów ale ich również
nie będzie można załadować, bo nie zostały podpisane kluczem, którego certyfikat został zaszyty
w kernelu. Można jednak zmusić mechanizm DKMS, by wskazane przez nas moduły podpisywał
automatycznie przy ich instalacji i aktualizacji.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Sterowniki dla karty WiFi Archer T1U (mt7610u_sta)</title>
      <link>https://morfikov.github.io/post/sterowniki-karta-wifi-archer-t1u-mt7610u_sta/</link>
      <pubDate>Thu, 18 Aug 2016 14:35:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/sterowniki-karta-wifi-archer-t1u-mt7610u_sta/</guid>
      <description>&lt;p&gt;Dziś postanowiłem się wziąć za ostatnią kartę WiFi, którą podesłał mi TP-LINK. Jest to nano adapter
Archer T1U V1 na &lt;a href=&#34;https://wikidevi.com/wiki/TP-LINK_TL-WDN5200&#34;&gt;czipie MediaTek MT7610U&lt;/a&gt;
identyfikowany w systemie jako &lt;code&gt;idVendor=2357&lt;/code&gt; , &lt;code&gt;idProduct=0105&lt;/code&gt; . Na opakowaniu pisało, że ta
karta działa na linux&#39;ach ale oczywiście w przypadku mojego Debiana, ten adapter nie został w ogóle
wykryty. Winą są zbyt stare sterowniki, które nie zostały zaktualizowane przez MediaTek od 2013
roku. TP-Link może i ma u siebie na stronie &lt;a href=&#34;http://www.tp-link.com/en/download/Archer-T1U.html#Driver&#34;&gt;nieco nowszą wersję
sterowników&lt;/a&gt;, bo z 2015 roku ale nie
udało mi się za ich sprawą zbudować poprawnie modułu &lt;code&gt;mt7610u_sta&lt;/code&gt; na kernelu 4.6 . Na szczęście
mamy jedną alternatywę, która pomoże nam jako tako wybrnąć z tej sytuacji.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Sterowniki do karty TP-LINK TL-WN823N (8192eu)</title>
      <link>https://morfikov.github.io/post/sterowniki-tp-link-tl-wn823n-8192eu/</link>
      <pubDate>Fri, 12 Aug 2016 20:50:39 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/sterowniki-tp-link-tl-wn823n-8192eu/</guid>
      <description>&lt;p&gt;Systemy operacyjne nie są w stanie wejść w interakcję ze sprzętem, do którego nie posiadają
sterowników. Linux już od dość dawna żyje sobie wśród nas i coraz bardziej pcha się na desktopy.
Niemniej jednak producenci tych wszystkich urządzeń niechętnie wypuszczają sterowniki dla
alternatywnych systemów. Ostatnio próbowałem uruchomić &lt;a href=&#34;http://www.tp-link.com.pl/products/details/TL-WN823N.html&#34;&gt;adapter TL-WN823N
V2&lt;/a&gt; od firmy TP-LINK. Na opakowaniu
widnieje napis sugerujący, że ta karta działa pod linux&#39;em. Rzeczywistość jednak okazała się
zupełnie inna. Mianowicie, mój Debian w ogóle nie rozpoznał tej karty. Jedyne informacje jakie mi
zwrócił to nazwę producenta czipu, którym okazał się być &lt;code&gt;Realtek&lt;/code&gt; , oraz &lt;code&gt;idVendor=2357&lt;/code&gt; i
&lt;code&gt;idProduct=0109&lt;/code&gt; . &lt;a href=&#34;http://www.tp-link.com/en/download/TL-WN823N.html#Driver&#34;&gt;Sterowników dostępnych na stronie
TP-LINK&#39;a&lt;/a&gt; nie szło zbudować na obecnym
kernelu 4.6 . Trzeba było zatem poszukać innej alternatywy. Na szczęście udało się znaleźć moduł
8192eu (rtl8192eu), który się skompilował i zainstalował bez problemu. Karta TL-WN823N V2 została
wykryta i działa. W tym wpisie zostanie pokazany proces kompilacji tego modułu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak wyłączyć systemowy &#34;beep&#34;</title>
      <link>https://morfikov.github.io/post/jak-wylaczyc-glosnik-sprzetowy-w-komputerze/</link>
      <pubDate>Mon, 25 Jan 2016 21:56:20 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wylaczyc-glosnik-sprzetowy-w-komputerze/</guid>
      <description>&lt;p&gt;Zgodnie z tym co można wyczytać na &lt;a href=&#34;https://wiki.archlinux.org/index.php/Disable_PC_speaker_beep&#34;&gt;wiki
Archlinux&#39;a&lt;/a&gt;, mamy kilka źródeł
generowania dźwięków, które trafiają do wbudowanego głośnika naszego komputera (case speaker). Te
dźwięki określane mianem &amp;quot;beep&amp;quot; mogą powstać za sprawą BIOS&#39;u płyty głównej, systemu operacyjnego,
środowiska graficznego lub też różnych programów użytkowych. Najbardziej uporczywe są dźwięki
generowane przez BIOS. Na dobrą sprawę, jeśli w BIOS&#39;ie nie ma żadnych opcji dotyczących
konfiguracji tego głośnika, to raczej niewiele jesteśmy w stanie zrobić w tej kwestii. Możemy zawsze
ten głośnik odłączyć fizycznie. Choć nie jest to zalecane, bo na podstawie wydawanych przez niego
dźwięków, jesteśmy w stanie określić czy z naszym komputerem jest wszystko w porządku. Niemniej
jednak, w tych pozostałych trzech w/w punkach mamy większe pole manewru, gdzie możemy dostosować
sobie szereg parametrów i o tym właśnie będzie ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak skonfigurować bonding w Debian linux (eth0&#43;wlan0)</title>
      <link>https://morfikov.github.io/post/konfiguracja-interfejsow-bond-bonding/</link>
      <pubDate>Sat, 02 Jan 2016 15:07:13 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-interfejsow-bond-bonding/</guid>
      <description>&lt;p&gt;W artykule poświęconym &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-polaczenia-wifi-pod-debianem/&#34;&gt;konfiguracji sieci WiFi na Debianie z wykorzystaniem narzędzia
wpa_supplicant&lt;/a&gt; wspomniałem parę słów na temat &lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/marcelo/linux-2.4/Documentation/networking/bonding.txt&#34;&gt;interfejsu bond&lt;/a&gt;. Bonding na linux
wykorzystywany jest w zasadzie do spięcia kilku interfejsów sieciowych, w tym przewodowych
( &lt;code&gt;eth0&lt;/code&gt; ) i bezprzewodowych ( &lt;code&gt;wlan0&lt;/code&gt; ) w jeden (zwykle &lt;code&gt;bond0&lt;/code&gt; ). Takie rozwiązanie sprawia, że
w przypadku awarii któregoś z podpiętych interfejsów, my nie tracimy połączenia z siecią i nie
musimy nic nigdzie przełączać, by to połączenie przywrócić. To rozwiązanie jest o tyle użyteczne,
że w przypadku, gdy podepniemy przewód do gniazda RJ-45 w naszym laptopie, to komunikacja będzie
odbywać się po kablu. Natomiast jeśli przewód zostanie odłączony, to system automatycznie przejdzie
na komunikację bezprzewodową. W tym wpisie spróbujemy zaprojektować sobie właśnie tego typu
mechanizm zarówno za sprawą pakietu &lt;code&gt;ifupdown&lt;/code&gt; , gdzie konfiguracja interfejsów sieciowych jest
zarządzana przez plik &lt;code&gt;/etc/network/interfaces&lt;/code&gt; , jak i przy pomocy natywnego rozwiązania jakie
oferuje systemd/networkd.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja interfejsów IFB w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/konfiguracja-interfejsow-ifb-w-linuxie/</link>
      <pubDate>Wed, 16 Dec 2015 14:46:50 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-interfejsow-ifb-w-linuxie/</guid>
      <description>&lt;p&gt;Ten wpis również będzie poświęcony tematyce
&lt;a href=&#34;http://linux-ip.net/articles/Traffic-Control-HOWTO/index.html&#34;&gt;kontroli&lt;/a&gt; i
&lt;a href=&#34;https://lukasz.bromirski.net/docs/translations/lartc-pl.html&#34;&gt;kształtowania&lt;/a&gt; ruchu sieciowego w
linux&#39;ie, z tym, że ograniczymy się tutaj do konfiguracji interfejsów IFB. Działają one na podobnej
zasadzie co &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-interfejsow-imq-w-linuxie/&#34;&gt;interfejsy IMQ&lt;/a&gt;.
Niewątpliwą zaletą interfejsów IFB jest fakt, że są one natywnie wspierane przez kernel linux&#39;a,
przez co ich obsługa jest dziecinnie prosta. Wadą jest z kolei to, że nie do końca damy radę
kształtować ruch przychodzący do naszej maszyny. Tak czy inaczej, postaramy się skonfigurować te
interfejsy i zobaczymy co z nich idzie wycisnąć.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja interfejsów IMQ w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/konfiguracja-interfejsow-imq-w-linuxie/</link>
      <pubDate>Tue, 15 Dec 2015 14:38:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-interfejsow-imq-w-linuxie/</guid>
      <description>&lt;p&gt;W linux&#39;ie, kształtowanie przychodzącego ruchu sieciowego stwarza dość poważne problemy. Na dobrą
sprawę, obecnie w kernelu nie ma żadnego mechanizmu, który byłby w stanie to zadanie realizować.
Istnieją, co prawda, &lt;a href=&#34;https://wiki.linuxfoundation.org/networking/ifb&#34;&gt;interfejsy IFB&lt;/a&gt; ale za ich pomocą jesteśmy w stanie z powodzeniem
kształtować jedynie ruch wychodzący. W przypadku pakietów napływających, możemy jedynie ograniczyć
im przepustowość. W tym powyższym linku jest wzmianka, że te interfejsy IFB są następcą
&lt;a href=&#34;https://github.com/imq/linuximq/wiki/WhatIs&#34;&gt;interfejsów IMQ&lt;/a&gt;. Niemniej jednak, ten drugi projekt zdaje się działać, choć nie jest obecnie
wspierany przez kernel linux&#39;a. W tym wpisie postaramy się skonfigurować działające interfejsy IMQ,
tak, by za ich pomocą skutecznie kształtować ruch przychodzący.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Moduł kernela i wartości jego parametrów</title>
      <link>https://morfikov.github.io/post/modul-kernela-i-wartosci-jego-parametrow/</link>
      <pubDate>Fri, 23 Oct 2015 19:35:57 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/modul-kernela-i-wartosci-jego-parametrow/</guid>
      <description>&lt;p&gt;Raczej na pewno spotkaliśmy się już z modułami kernela w linux&#39;ie. Generalnie rzecz biorąc, taki
moduł może być ładowany dynamicznie i w sporej części przypadków niezależnie, choć z zwykle jest
pociągany przy zdarzeniach udev&#39;a. Czasem jednak, dany moduł nie działa jak należy i może to być
wynikiem, np. problemów w samym module, lub też jego niewłaściwej konfiguracji, która konfliktuje z
podzespołami naszego komputera. Ten wpis będzie dotyczył tego jak ustalić parametry modułów i ich
domyślne wartości, tak by móc je sobie zmienić w późniejszym czasie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Karta dźwiękowa w trybie powersave</title>
      <link>https://morfikov.github.io/post/karta-dzwiekowa-w-trybie-powersave/</link>
      <pubDate>Tue, 06 Oct 2015 10:47:38 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/karta-dzwiekowa-w-trybie-powersave/</guid>
      <description>&lt;p&gt;Kilka dni temu, &lt;a href=&#34;https://forum.dug.net.pl/viewtopic.php?pid=291349&#34;&gt;na forum DUG&#39;a&lt;/a&gt;, jeden z
użytkowników miał problem z dźwiękiem. Udało się tę niedogodność wprawdzie poprawić ale został tam
poruszony temat trybu powersave, czyli oszczędzania energii, jaki może posiadać karta dźwiękowa. Na
dobrą sprawę, nigdy mi nawet do głowy nie przyszło, by te karty mogły przełączać sobie stan i zjadać
mniej prądu, tak jak to robią, np. karty WiFi. Oczywiście, postanowiłem zgłębić to zagadnienie i
ustalić na ile przydatna jest ta funkcja i czy da radę bez problemów słuchać muzyki lub oglądać
filmy po jej aktywowaniu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Aplikowanie zmiennych sysctl przy pomocy udev&#39;a</title>
      <link>https://morfikov.github.io/post/aplikowanie-zmiennych-sysctl-przy-pomocy-udeva/</link>
      <pubDate>Sun, 06 Sep 2015 11:08:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/aplikowanie-zmiennych-sysctl-przy-pomocy-udeva/</guid>
      <description>&lt;p&gt;Kernele linux&#39;owe mają dość sporo opcji, które możemy zmienić przy pomocy pliku &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; .
Niby nic nadzwyczajnego ale co w przypadku tych zmiennych, które muszą być ustawione, z tym, że
moduł, który stworzy odpowiednie ścieżki w katalogu &lt;code&gt;/proc/sys/&lt;/code&gt; , nie został załadowany z jakichś
względów przy starcie systemu? Zmienne te nie zostaną ustawione, a w logu pojawi się komunikat
informujący nas o nieodnalezieniu określonego pliku. Okazuje się, że jesteśmy w stanie aplikować
określone ustawienia sysctl w momencie ładowania określonych modułów i temu mechanizmowi się
przyjrzymy bliżej w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Autosuspend i zasilanie portów USB na linux</title>
      <link>https://morfikov.github.io/post/autosuspend-i-zasilanie-portow-usb/</link>
      <pubDate>Tue, 23 Jun 2015 15:34:50 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/autosuspend-i-zasilanie-portow-usb/</guid>
      <description>&lt;p&gt;Kernel w linux&#39;ie odcina zasilanie urządzeniom podpiętym do portów USB jeśli sterownik wspiera tego
typu możliwość oraz samo urządzenie nie jest używane przez pewien okres czasu. W taki oto sposób,
jeśli podłączymy, np. zewnętrzną klawiaturę USB do laptopa, możemy zaobserwować, że przy pisaniu
tekstu gubiony jest zwykle pierwszy znak. Może i klawiatura po przyciśnięciu klawisza wyszła ze
stanu bezczynności ale system nie zareagował na tyle szybko by złapać sygnał przycisku. Na necie
ludzie piszą, że jest to problem niekompatybilności urządzeń i tego typu sytuacja nie powinna się
zdarzać. Jeśli jednak natrafiliśmy na klawiaturę czy myszę, która cierpi z powodu automatycznego
zawieszania jej zasilania, możemy wyłączyć ten ficzer zupełnie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Sterowniki do karty TP-LINK Archer T4U (8812au)</title>
      <link>https://morfikov.github.io/post/sterowniki-karty-tp-link-archer-t4u-8812au/</link>
      <pubDate>Tue, 23 Jun 2015 11:45:07 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/sterowniki-karty-tp-link-archer-t4u-8812au/</guid>
      <description>&lt;p&gt;Póki co, w kernelu linux&#39;a (4.5) nie ma odpowiednich sterowników do &lt;a href=&#34;http://www.tp-link.com.pl/products/details/cat-11_Archer-T4U.html&#34;&gt;adaptera WiFi Archer
T4U&lt;/a&gt; i trzeba je sobie
skompilować ręcznie. Trochę to dziwne, bo przecie kod sterownika jest na licencji GPLv2 i dostępny
już szmat czasu na &lt;a href=&#34;https://github.com/abperiasamy/rtl8812AU_8821AU_linux&#34;&gt;github&#39;ie&lt;/a&gt;. W każdym
razie, jeśli zakupiliśmy w/w kartę i nie jest ona wykrywana po wsadzeniu jej do portu USB, to czeka
nas proces kompilacji modułu &lt;code&gt;8812au&lt;/code&gt; i jego automatyzacja przy pomocy &lt;a href=&#34;https://morfikov.github.io
/post/dkms-czyli-automatycznie-budowane-moduly/&#34;&gt;mechanizmu
DKMS&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Obsługa wielu partycji w module loop</title>
      <link>https://morfikov.github.io/post/obsluga-wielu-partycji-w-module-loop/</link>
      <pubDate>Sun, 14 Jun 2015 16:37:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/obsluga-wielu-partycji-w-module-loop/</guid>
      <description>&lt;p&gt;Wszelkie obrazy &lt;code&gt;.iso&lt;/code&gt; płyt cd/dvd czy nawet pliki &lt;code&gt;.img&lt;/code&gt; zawierające strukturę obrazów live możemy
zamontować lokalnie na komputerze uzyskując tym samym dostęp do ich systemu plików. W większości
przypadków, każdy taki obraz zawiera tylko jedną partycję, czasem lekko przesuniętą względem
początku ale generalnie nie ma większych problemów z zamontowaniem tego typu plików. Najwyżej
trzeba podać jeden dodatkowy parametr, tj. &lt;code&gt;offset&lt;/code&gt; . A co w przypadku obrazów dysków, które zwykle
mają więcej niż jedną partycję? Gdybyśmy spróbowali zamontować taki plik w systemie, to zostanie nam
zwrócony błąd, no bo przecież kernel nie wie za bardzo jak taki plik ma odczytać. Możemy za to
skorzystać z urządzeń &lt;code&gt;loop&lt;/code&gt; , które po odpowiedniej konfiguracji, są w stanie nam takie obrazy z
powodzeniem zamontować na naszym linux&#39;ie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>DKMS, czyli automatycznie budowane moduły</title>
      <link>https://morfikov.github.io/post/dkms-czyli-automatycznie-budowane-moduly/</link>
      <pubDate>Sat, 30 May 2015 21:05:27 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dkms-czyli-automatycznie-budowane-moduly/</guid>
      <description>&lt;p&gt;Jeśli zamierzamy kupić sprzęt, który dopiero co trafił na półki w sklepach, to prawdopodobnie zaraz
po podłączeniu go do naszego komputera okaże się, że to urządzenie nie jest nawet wykrywane przez
system operacyjny. W przypadku gdy jego producent zapewnia w miarę przyzwoity support, to być może
problemy, których doświadczamy, zostaną rozwiązane wraz z instalacją najnowszego kernela. Co jednak
w przypadku gdy nawet po aktualizacji kernela nie jesteśmy w stanie odpalić, np. nowo zakupionej
karty WiFi? Jako, że te wszystkie sprzęty działają w oparciu określone moduły, wystarczy taki moduł
pozyskać, skompilować i załadować w systemie. Problem w tym, że z każdą nową wersją jądra
operacyjnego, która trafi do repo debiana, będziemy musieli ręcznie budować moduł na nowo i właśnie
w tym artykule opiszę jak nauczyć system, by sam przeprowadzał tę mozolną czynność bez naszego
udziału.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Skryptowa nakładka na kernelowski moduł ZRAM</title>
      <link>https://morfikov.github.io/post/skryptowa-nakladka-na-kernelowski-modul-zram/</link>
      <pubDate>Sun, 17 May 2015 21:01:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/skryptowa-nakladka-na-kernelowski-modul-zram/</guid>
      <description>&lt;p&gt;ZRAM to moduł kernela, który tworzy wirtualne urządzenia w pamięci operacyjnej komputera, a te z
kolei można wykorzystać pod system plików lub też i pod przestrzeń wymiany SWAP. Dane w takim
urządzeniu są kompresowane, dzięki czemu mamy do dyspozycji więcej miejsca w pamięci. Jeśli mamy
niepierwszej jakości dysk twardy, lub też wykorzystujemy szyfrowanie i nie mamy przy tym procka ze
wsparciem dla AES, to operacje zapisu/odczytu mogą zająć wieki. Możemy w dość znacznym stopniu
odciążyć dysk przenosząc pliki do pamięci RAM, który jest o wiele szybszy, no i dane w nim nie
podlegają szyfrowaniu. Jeśli mamy dużo pamięci operacyjnej, to ZRAM raczej będzie zbędny i tylko
podniesie nam rachunek za prąd. Natomiast jeśli nasz komputer nie szasta zbytnio pamięcią, możemy
rozszerzyć ją 2-3 krotnie.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
