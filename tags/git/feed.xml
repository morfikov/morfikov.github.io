<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>git on Morfitronik</title>
    <link>https://morfikov.github.io/tags/git/</link>
    <description>Recent content in git on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Wed, 27 Mar 2019 05:23:42 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/git/feed.xml" rel="self" type="application/rss+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Format źródeł 3.0 (git) przy budowaniu paczek Debiana</title>
      <link>https://morfikov.github.io/post/format-zrodel-git-przy-budowaniu-paczek-debiana/</link>
      <pubDate>Wed, 27 Mar 2019 05:23:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/format-zrodel-git-przy-budowaniu-paczek-debiana/</guid>
      <description>&lt;p&gt;Pisząc jakiś czas
temu &lt;a href=&#34;https://morfikov.github.io/post/poradnik-maintainera-czyli-jak-zrobic-pakiet-deb/&#34;&gt;poradnik na temat budowania paczek .deb&lt;/a&gt;
dla dystrybucji linux&#39;a Debian, poruszyłem w nim kwestię związaną z aktualizacją paczki, która
zawierała projekt utrzymywany w systemie kontroli wersji (CVS), np. git. Rozchodzi się tutaj o
format źródeł. Do niedawna myślałem, że są w zasadzie dwa formaty (tych, z których się zwykle
korzysta): &lt;code&gt;3.0 (native)&lt;/code&gt; oraz &lt;code&gt;3.0 (quilt)&lt;/code&gt; . Wszystkie moje pakiety budowane do tej pory miały
ten drugi format. Podglądając ostatnio kilka paczek &lt;code&gt;.deb&lt;/code&gt; , natrafiłem w jednej z nich na format
źródeł &lt;code&gt;3.0 (git)&lt;/code&gt; . Okazuje się, że ten format jest w stanie bardzo łatwo ogarnąć projekty
hostowane w takich serwisach jak GitHub, czy GitLab i można za jego sprawą nieco ułatwić sobie
życie. Wypadałoby zatem rzucić na niego okiem i ocenić go pod kątem przydatności przy budowaniu
pakietów dla Debiana.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak sklonować duże repozytorium git na niestabilnym łączu sieciowym</title>
      <link>https://morfikov.github.io/post/jak-sklonowac-duze-repozytorium-git-na-niestabilnym-laczu-sieciowym/</link>
      <pubDate>Sat, 16 Feb 2019 05:29:25 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-sklonowac-duze-repozytorium-git-na-niestabilnym-laczu-sieciowym/</guid>
      <description>&lt;p&gt;Połączenie z internetem, z którego ostatnio przyszło mi korzystać, nie należało zbytnio do tych
najbardziej wydajnych pod względem prędkości przesyłu danych. O ile szybkość transferu można by
jeszcze przemilczeć, to owe łącze nie należało też do tych najstabilniejszych i czasem kontakt
ze światem był zwyczajnie zrywany. Krótko rzecz ujmując, ten net nadawał się chyba jedynie do
przeglądania stron WWW. Pech jednak chciał, że potrzebowałem zassać na takim
połączeniu &lt;a href=&#34;https://salsa.debian.org/kernel-team/linux&#34;&gt;repozytorium git&#39;a z patch&#39;ami Debiana&lt;/a&gt;
nakładanymi na kernel linux&#39;a. To repozytorium nie należy do największych ale też do małych ono
się nie zalicza -- waży około 2 GiB. Oczywiście można by zrobić jedynie płytki klon takiego repo za
sprawą &lt;code&gt;git clone --depth=1&lt;/code&gt; , co skutkowałoby pobraniem plików w wersji z ostatniego commit&#39;a, co
z kolei zredukowałoby w znacznym stopniu wielkość pobieranych danych (parę-paręnaście MiB). Co
jednak zrobić w przypadku, gdy musimy sklonować sporych rozmiarów repozytorium git, a dysponujemy
przy tym dość wolnym połączeniem sieciowym? Czy jest to w ogóle możliwe, bo przecież git nie ma
zaimplementowanej opcji wznawiania przerwanej synchronizacji i każde zakłócenie tego procesu
skutkować będzie tym, że całe repozytorium trzeba będzie pobrać jeszcze raz i to bez względu na to,
czy proces się zawiesi zaraz na początku, czy też pod koniec operacji.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Implementacja kluczy GPG na github&#39;ie</title>
      <link>https://morfikov.github.io/post/implementacja-kluczy-gpg-githubie/</link>
      <pubDate>Sun, 03 Jul 2016 15:30:22 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/implementacja-kluczy-gpg-githubie/</guid>
      <description>&lt;p&gt;Github to serwis, w którym użytkownicy mogą pracować wspólnie nad różnymi projektami utrzymywanymi w
systemie kontroli wersji GIT. Konto w w/w serwisie może być łakomym kąskiem dla przestępców,
zwłaszcza gdy uczestniczymy w dość rozbudowanych projektach i przyczyniamy się do ich tworzenia w
dużym stopniu. Z tego powodu github implementuje rozwiązania, które mają na celu poprawić
bezpieczeństwo naszej pracy. Mamy już uwierzytelnianie dwuetapowe, &lt;a href=&#34;https://morfikov.github.io/post/github-z-obsluga-kluczy-ssh/&#34;&gt;obsługę kluczy
SSH&lt;/a&gt; ale nadal brakowało odpornego systemu,
który by uwierzytelnił osoby współdziałające z nami. Chodzi o to, że wszelkie zmiany w repozytorium
GIT muszą być przez kogoś poczynione. Każdy commit ma zatem swojego właściciela ale my nigdy nie
mamy pewności co do tego, kto tak naprawdę tej zmiany dokonał. Dlatego też &lt;a href=&#34;https://github.com/blog/2144-gpg-signature-verification&#34;&gt;github umożliwił
ostatnio podpisywanie tagów i commit&#39;ów przy pomocy kluczy
GPG&lt;/a&gt;. To właśnie temu tematowi będzie
poświęcony niniejszy wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Tworzenie repozytorium git na GitHub</title>
      <link>https://morfikov.github.io/post/tworzenie-repozytorium-git-na-githubie/</link>
      <pubDate>Tue, 19 Apr 2016 17:08:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/tworzenie-repozytorium-git-na-githubie/</guid>
      <description>&lt;p&gt;Po eksperymentah z repozytorium git na github&#39;ie postanowiłem zrobić drobną ściągawkę na temat
obsługi tego mechanizmu z poziomu linii poleceń. Oczywiście, tutaj będą przedstawione jedynie
podstawy, tj. jak zacząć tworzyć takie repozytorium. Bardziej zaawansowane rzeczy, np.
&lt;a href=&#34;https://morfikov.github.io/post/github-z-obsluga-kluczy-ssh/&#34;&gt;implementacja kluczy SSH na github&#39;ie&lt;/a&gt;, czy
też &lt;a href=&#34;https://morfikov.github.io/post/implementacja-kluczy-gpg-repozytorium-git/&#34;&gt;podpisywanie swojej pracy przy pomocy kluczy
GPG&lt;/a&gt; zostały opisane w osobnych
wpisach, bo lekko wykraczają poza tematykę tego artykułu. Oczywiście te dwie rzeczy nie są wymagane
do pracy z git&#39;em ale trzeba rozważyć ich wdrożenie jeśli faktycznie zamierzamy zacząć korzystać z
tego VCS&#39;a. W każdym razie, tutaj zajmę się podstawowymi operacjami, które człowiek zwykle
przeprowadza, gdy przychodzi mu korzystać z git&#39;a. Zdaję sobie sprawę, że są różne nakładki
graficzne na narzędzie &lt;code&gt;git&lt;/code&gt; ale, jak się okaże po przeczytaniu tego wpisu, operowanie na tekstowym
&lt;code&gt;git&lt;/code&gt; nie jest takie straszne, choć sama dokumentacja może przerazić, bo jest tego dość sporo i
raczej wszystkiego od razu nie ogarniemy.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb</title>
      <link>https://morfikov.github.io/post/poradnik-maintainera-czyli-jak-zrobic-pakiet-deb/</link>
      <pubDate>Mon, 07 Dec 2015 20:26:45 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/poradnik-maintainera-czyli-jak-zrobic-pakiet-deb/</guid>
      <description>&lt;p&gt;Debian posiada bardzo rozbudowany system robienia pakietów. Generalnie rzecz biorąc, to wszystkie z
nich musiały przejść przez ten proces zanim trafiły do głównego repozytorium dystrybucji. Dzięki
takiemu stanu rzeczy, nie musimy ręcznie powielać pracy szeregu innych osób i odpada nam
własnoręczna kompilacja pakietów, a wszyscy wiemy, że zajmuje ona cenny czas i zasoby. Paczki
&lt;code&gt;.deb&lt;/code&gt; są tworzone ze źródeł i instalowane przy pomocy menadżera pakietów &lt;code&gt;aptitude&lt;/code&gt;/&lt;code&gt;apt&lt;/code&gt;/&lt;code&gt;dpkg&lt;/code&gt; .
Nic jednak nie stoi na przeszkodzie by daną aplikację skompilować sobie ręcznie i zainstalować ją
przy pomocy &lt;code&gt;make install&lt;/code&gt; . Problem w tym, że w taki sposób robi się śmietnik w naszym systemie i
śledzenie wszystkich zainstalowanych w ten sposób pakietów w pewnym momencie stanie się wręcz
niemożliwe. Dlatego też przydałby nam się mechanizm, który ułatwiłby nam nieco to zadanie. Debian
udostępnia szereg narzędzi, które są w stanie w pełni zautomatyzować cały ten proces budowy
pakietów. Ten poradnik zaś ma na celu zebranie wszystkich istotniejszych informacji związanych z
obsługą narzędzi takich jak &lt;code&gt;dh_make&lt;/code&gt; , &lt;code&gt;dpkg-buildpackage&lt;/code&gt; , &lt;code&gt;pbuilder&lt;/code&gt; , &lt;code&gt;quilt&lt;/code&gt; czy &lt;code&gt;lintian&lt;/code&gt; ,
tak by tworzyć pakiety w prosty sposób i przy tym równając do najwyższych standardów debiana.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Implementacja kluczy GPG w repozytorium GIT</title>
      <link>https://morfikov.github.io/post/implementacja-kluczy-gpg-repozytorium-git/</link>
      <pubDate>Sun, 17 May 2015 21:11:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/implementacja-kluczy-gpg-repozytorium-git/</guid>
      <description>&lt;p&gt;W tym artykule zostanie przedstawiony sposób na wykorzystanie kluczy GPG w przypadku
przeprowadzanych działań w repozytorium GIT. Będziemy w ten sposób w stanie podpisać swoje commit&#39;y
czy tagi, by było wiadomo, że zmiany, które zostały poczynione pochodzą naprawdę od konkretnego
użytkownika. Oczywiście to może się wydać przesadą dla wielu ludzi ale skoro mamy udostępnioną
możliwość wykorzystania kluczy GPG, to czemu z tej opcji nie skorzystać? Potrzebne będą nam tylko
&lt;a href=&#34;https://morfikov.github.io/post/bezpieczny-klucz-gpg/&#34;&gt;klucze GPG&lt;/a&gt;. Sposób ich tworzenia jak i &lt;a href=&#34;https://morfikov.github.io/post/konfiguracja-gpg-w-pliku-gpg-conf/&#34;&gt;konfiguracja
zdefiniowana w pliku gpg.conf&lt;/a&gt; nie
zostaną tutaj opisane. Zamiast tego skupimy się jedynie na implementacji samych kluczy GPG.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>GitHub z obsługą kluczy SSH</title>
      <link>https://morfikov.github.io/post/github-z-obsluga-kluczy-ssh/</link>
      <pubDate>Sun, 17 May 2015 21:06:05 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/github-z-obsluga-kluczy-ssh/</guid>
      <description>&lt;p&gt;W końcu przyszedł czas na eksperymenty z serwisem GitHub. Jakby nie patrzeć, do tej pory jedyne co
potrafiłem zrobić w przypadku samego gita, to wydać jedno polecenie, którym było &lt;code&gt;git clone&lt;/code&gt; .
Wszelkie inne rzeczy, choć nie było ich wcale tak dużo, robiłem via panel www, co trochę było
upierdliwe. Postanowiłem nauczyć się obsługi gita i nieco uprościć sobie życie. Jeśli chodzi o samą
naukę, to tutaj jest dostępny &lt;a href=&#34;https://git-scm.com/book/en/v2&#34;&gt;dość obszerny pdf&lt;/a&gt; (prawie 500
stron). Nie będę tutaj przerabiał wyżej podlinkowanej książki, bo w sumie jeszcze jej nie
przeczytałem, tylko zajmę się ciekawym tematem jakim jest implementacja kluczy SSH, tak by operować
na gicie bez zbędnych haseł.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
