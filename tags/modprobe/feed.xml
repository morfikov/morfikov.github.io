<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Modprobe on Morfitronik</title>
    <link>https://morfikov.github.io/tags/modprobe/</link>
    <description>Recent content in Modprobe on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Tue, 13 Dec 2022 13:03:00 +0100</lastBuildDate><atom:link href="https://morfikov.github.io/tags/modprobe/feed.xml" rel="self" type="application/rss+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zablokowanie możliwości ładowania modułów kernela na Debian linux</title>
      <link>https://morfikov.github.io/post/zablokowanie-mozliwosci-ladowania-modulow-kernela-na-debian-linux/</link>
      <pubDate>Tue, 13 Dec 2022 13:03:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/zablokowanie-mozliwosci-ladowania-modulow-kernela-na-debian-linux/</guid>
      <description>&lt;p&gt;Kernele oferowane przez różne dystrybucje linux&#39;a, np. Debian czy Ubuntu, są tak budowane by
możliwie jak największa ilość sprzętu na takim jądrze operacyjnym nam zadziałała bez zbędnego
przerabiania systemu. Takie podejście sprawia, że nowo nabyty przez nas sprzęt możemy od razu
podłączyć do komputera, a stosowne moduły po rozpoznaniu urządzenia zostaną załadowane do pamięci
operacyjnej, przez co my będziemy mogli wejść w interakcję z takim kawałkiem elektroniki. Problem w
tym, że kernel ma bardzo dużo tych modłów. Dużo modułów, to więcej kodu, a więcej kodu to więcej
błędów, które na poziomie jądra mogą być bardzo opłakane w skutkach. Z zagrożeniem, jakie niosą
moduły zewnętrzne (te spoza drzewa kernela linux), można sobie poradzić &lt;a href=&#34;https://morfikov.github.io/post/jak-dodac-wlasne-klucze-dla-secure-boot-do-firmware-efi-uefi-pod-linux/#podpisywanie-kernela&#34;&gt;podpisując kernel kluczami
od firmware EFI/UEFI&lt;/a&gt;. W takim przypadku załadowanie niepodpisanego modułu już się nie powiedzie.
Niemniej jednak, dystrybucyjne kernele mają całą masę modułów do różnorakiego sprzętu, które na
etapie budowania kernela są podpisywane, co otwiera im drogę do bycia załadowanymi w naszym
systemie nawet jeśli nie posiadamy urządzeń, które by użytek z tych modułów robiły. Przydałoby się
zatem zabezpieczyć możliwość ładowania modułów kernela w taki sposób, by jedynie administrator
systemu miał możliwość określenia jakie moduły i na którym etapie pracy systemu mogą one zostać
załadowane.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
