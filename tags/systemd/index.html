<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>systemd | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
	<meta name="robots" content="noindex, follow" />
		<meta property="og:title" content="systemd" />
<meta property="og:description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://morfikov.github.io/tags/systemd/" />

		<meta itemprop="name" content="systemd">
<meta itemprop="description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)">
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="systemd"/>
<meta name="twitter:description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT/LEDE i Android)"/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="alternate" type="application/rss+xml" href="https://morfikov.github.io/tags/systemd/feed.xml" title="Morfitronik">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/tags/">Tags</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">systemd</li>
	</ol>
</nav>
		<div class="page block">
			<h1 class="page__title">systemd</h1>
			
		</div>
		<div class="cards">
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/uwierzytelnianie-odpowiedzi-z-serwerow-czasu-ntp-przy-pomocy-nts/">Uwierzytelnianie odpowiedzi z serwerów czasu NTP przy pomocy NTS</a></h1>
	<div class="entry__content"><p>Przepisując ostatnio stare artykuły dotyczące <a href="https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/">zabezpieczenia zapytań DNS za sprawą wdrożenia na
linux dnsmasq i dnscrypt-proxy</a>, natknąłem się <a href="https://blog.cloudflare.com/secure-time/">na informację</a>, że nie tylko komunikacja DNS
w obecnych czasach w sporej mierze nie jest zaszyfrowana. W zasadzie każda maszyna podłączona do
internetu potrzebuje dysponować w miarę dokładnym czasem. By ten czas był dokładny, wymyślono
mechanizm synchronizacji czasu przez wysyłanie zapytań do serwerów NTP (<a href="https://pl.wikipedia.org/wiki/Network_Time_Protocol">Network Time Protocol</a>).
Niemniej jednak, odpowiedzi z tych serwerów czasu nie są w żaden sposób zabezpieczone i praktycznie
każdy na drodze tych pakietów może nam zmienić ustawienia czasu w systemie (MITM). W taki sposób
możemy zostać cofnięci w czasie, co z kolei może oznaczać, że system zaakceptuje certyfikaty SSL/TLS
czy też <a href="https://trimstray.github.io/posts/2019-07-21-nginx-optymalizacja_sesji_ssl-tls/#ssl_session_tickets">klucze/bilety sesji</a> (używane do wznawiania sesji TLS), które już dawno temu wygasły
lub/i zostały w jakiś sposób skompromitowane. Pchnięcie nas do przodu w czasie również oznacza
problemy, bo możemy zaakceptować certyfikat, który jeszcze nie zaczął być ważny. To z kolei otwiera
drogę do odszyfrowania połączeń z serwisami WWW, a przecie nie po to szyfrujemy ruch, by go ktoś bez
większego problemu odszyfrował. Dlatego też powinniśmy zadbać o to, by informacje o aktualnym czasie
otrzymywane z sieci docierały do nas z wiarygodnego źródła i były w jakiś sposób uwierzytelnione.
Na Debianie standardowo do synchronizacji czasu wykorzystywany jest <code>systemd-timesyncd</code> ale <a href="https://github.com/systemd/systemd/issues/9481">nie
wspiera on póki co protokołu NTS</a>. Trzeba będzie zatem się go pozbyć i zastąpić go demonem <code>ntpd</code>
z pakietu <code>ntpsec</code> .</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-09-27T12:29:00&#43;02:00">Opublikowano: 27/09/2020</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-zalogowac-bledy-podczas-zamykania-systemu-debian-linux/">Jak zalogować błędy podczas zamykania systemu Debian Linux</a></h1>
	<div class="entry__content"><p>By wyłączyć komputer, jego system operacyjny musi pierw zatrzymać (lub też ubić siłowo) wszystkie
działające usługi za wyjątkiem tego mającego PID z numerkiem 1. Zwykle proces zamykania się systemu
Debian Linux nie trwa więcej niż parę sekund ale czasami pojawiają się dziwne problemy, które mogą
to zadanie utrudnić lub też całkowicie uniemożliwić. Nawet jeśli system będzie się w stanie
zresetować, to zanim to nastąpi, to na konsoli mogą pojawić się komunikaty mogące pomóc nam w
zdiagnozowaniu dolegliwości, która doskwiera naszej maszynie. Problem w tym, że część tych
wiadomości nie zostanie nigdy zalogowana do pliku, gdzie moglibyśmy ich poszukać. Dzieje się tak
dlatego, że w pewnym określonym momencie zamykania się systemu trzeba wyłączyć usługę logowania, co
zwykle widać w logu jako <code>systemd-journald[]: Journal stopped</code> . Gdy dziennik zostanie zatrzymany,
żadna wiadomość, która od tego momentu pojawi się na ekranie, nie zostanie już zalogowana do pliku.
Jeśli teraz pojawią nam się ostrzeżenia lub błędy, a po chwili komputer się zresetuje, to możemy
mieć nie lada problem z ustaleniem przyczyny mimo, że system nam ją zgłasza. Przydałoby się zapisać
te komunikaty, tylko jak to zrobić, skoro usługa logowania jest już nieaktywna?</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2019-02-02T06:12:18Z">Opublikowano: 02/02/2019</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/konfiguracja-ddns-dla-opendns/">Konfiguracja DDNS dla OpenDNS</a></h1>
	<div class="entry__content"><p>Ludzkość w dalszym ciągu siedzi na przestarzałym już od prawie 20 lat protokole IPv4. Nie widać, też
by w najbliższym czasie coś miało się w tej kwestii zmienić. Można, co prawda, wykupić sobie stały
adres IP ale to kosztuje, no i płacimy za coś co powinniśmy mieć w standardzie, gdyby ludzie w końcu
zaczęli korzystać z IPv6. Niemniej jednak, by te wszystkie nasze maszyny podłączyć jakoś do sieci,
potrzebne nam są prywatne adresy IP + NAT lub też dynamicznie zmieniające się adresy publiczne.
Bywają też przypadki, że mamy przydzielane dynamicznie adresy z puli prywatnej, np. w wyniku dbania
o prywatność w sieciach WiFi przez <a href="https://morfikov.github.io/post/jak-przypisac-losowy-adres-mac-interfejsu/">generowanie sobie przy każdym połączeniu losowego adresu
MAC</a>. Zwykle w takiej sytuacji
zmienia nam się adres zewnętrzny (publiczny), który wskazuje na jeden z adresów naszego ISP. Taki
zmieniający się adres powoduje problemy przy konfiguracji poszczególnych usług sieciowych, np. gdy w
grę wchodzi konfiguracja filtra DNS, który jest zapewniany przez OpenDNS. By tego typu niedogodności
rozwiązać, możemy posłużyć się <a href="https://pl.wikipedia.org/wiki/DDNS">DDNS (dynamic DNS)</a>. Za każdym
razem, gdy adres IP ulega zmianie, klient DDNS informuje o tym fakcie skonfigurowane usługi. W tym
artykule przyjrzymy się nieco bliżej temu mechanizmowi.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2016-05-23T20:09:42Z">Opublikowano: 23/05/2016</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/mechanizm-inhibitor-lock-w-systemd/">Mechanizm inhibitor lock w systemd</a></h1>
	<div class="entry__content"><p>Hibernacja w przypadku komputerów, zwłaszcza laptopów, to bardzo użyteczny wynalazek. Na linux'ach
wymaga ona czasem lekkiej konfiguracji ale generalnie można powiedzieć, że działa OOTB. Po migracji
szeregu dystrybucji na systemd, proces hibernacji zdaje się przebiegać nieco inaczej niż to miało
miejsce w przeszłości. Bardzo często możemy się spotkać z sytuacjami, gdzie przy próbie
zahibernowania czy wyłączenia systemu, ten zwyczajnie ignoruje nasze żądanie i pracuje dalej jak
gdyby nigdy nic. W tym przypadku nie mamy do czynienia z bug'iem ale ficzerem. Okazuje się bowiem,
że systemd dysponuje mechanizmem zwanym <a href="https://www.freedesktop.org/wiki/Software/systemd/inhibit/">inhibitor
lock</a>, który ma na celu powstrzymanie
systemu od dokonania hibernacji, uśpienia lub wyłączenia w pewnych określonych sytuacjach. W tym
wpisie przyjrzymy się nieco bliżej temu mechanizmowi.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2016-02-04T23:36:24Z">Opublikowano: 04/02/2016</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/konfiguracja-jasnosci-ekranu-w-laptopie-backlight/">Konfiguracja jasności ekranu w laptopie (backlight)</a></h1>
	<div class="entry__content"><p>Linux nigdy nie był popularnym systemem operacyjnym na stacjach klienckich. Może i cieszy się sporym
wzięciem wśród środowisk serwerowych ale jego niezbyt prosta obsługa nie przemawia do przeciętnego
użytkownika komputera. Wraz z rozwojem technologi, zmienił się też rodzaj urządzeń na jakich
obecnie pracujemy. W dzisiejszych czasach liczy się przede wszystkim mobilność i praktycznie każdy z
nas miał już prawdopodobnie do czynienia z laptopami. Producenci tych urządzeń lubią nam wciskać
windowsa z dopiskiem, że ten laptop bez niego nie będzie w ogóle nam działał. Już od dość dawna
szereg laptopów jest w stanie pracować pod linux'em ale, jakby nie patrzeć, sporo rzeczy w nich nie
działa OOTB i trzeba poświęcić trochę czasu, by tę maszynę doprowadzić do porządku. W tym wpisie
zajmiemy się zagadnieniem podświetlania matrycy (backlight), tak by system był w stanie bez problemu
zapisać ustawienia jasności ekranu przy wyłączaniu komputera oraz, by potrafił je także wczytać
podczas fazy rozruchu.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2016-01-05T21:52:41Z">Opublikowano: 05/01/2016</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/temperatura-dysku-twardego-hddtemp/">Temperatura dysku twardego (hddtemp)</a></h1>
	<div class="entry__content"><p>Obecnie dyski twarde nie są potrzebne do prawidłowego działania komputera. Mając sporo pamięci
operacyjnej oraz <a href="https://pl.wikipedia.org/wiki/Live_CD">system live</a>, możemy bez problemu korzystać z takiego sprzętu. Niemniej jednak,
systemy live są nieco ograniczone. Najdotkliwszą ich wadą jest brak zapisywania wprowadzanych zmian.
W pewnych przypadkach ta cecha może być bardzo pożądana ale jeśli chodzi o przeciętnego użytkownika,
to chciałby on raczej mieć możliwość zapisu swojej pracy. Dlatego też zewnętrzny magazyn danych w
postaci dysku twardego nie prędko wyjdzie z użytku. Te urządzenia, jak i większość tych, które
podłączamy do naszego komputera, wydzielają ciepło. Temperatura jest wrogiem numer 1 w przypadku
maszyn i musi stale być monitorowana, tak by czasem nie doszło do przegrzania sprzętu.
<a href="https://pl.wikipedia.org/wiki/Dysk_twardy">Dyski HDD</a> mają ten problem, że im wyższa jest temperatura, tym obszar magnetyczny się bardziej
rozszerza, a to powoduje błędy odczytu i zapisu. Podobnie jest ze zbyt niską temperaturą, gdzie
ścieżki i sektory ulegają skurczeniu. Taki dysk musi pracować w odpowiednich warunkach termalnych.
W tym wpisie postaramy się ustalić aktualną temperaturę dysku oraz spróbujemy ją monitorować, tak
by wiedzieć czy czynnik temperaturowy nie zagraża czasem dyskom podpiętym do naszego PC.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2016-01-03T16:24:45Z">Opublikowano: 03/01/2016</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/konfiguracja-interfejsow-bond-bonding/">Jak skonfigurować bonding w Debian linux (eth0&#43;wlan0)</a></h1>
	<div class="entry__content"><p>W artykule poświęconym <a href="https://morfikov.github.io/post/konfiguracja-polaczenia-wifi-pod-debianem/">konfiguracji sieci WiFi na Debianie z wykorzystaniem narzędzia
wpa_supplicant</a> wspomniałem parę słów na temat <a href="https://www.kernel.org/pub/linux/kernel/people/marcelo/linux-2.4/Documentation/networking/bonding.txt">interfejsu bond</a>. Bonding na linux
wykorzystywany jest w zasadzie do spięcia kilku interfejsów sieciowych, w tym przewodowych
( <code>eth0</code> ) i bezprzewodowych ( <code>wlan0</code> ) w jeden (zwykle <code>bond0</code> ). Takie rozwiązanie sprawia, że
w przypadku awarii któregoś z podpiętych interfejsów, my nie tracimy połączenia z siecią i nie
musimy nic nigdzie przełączać, by to połączenie przywrócić. To rozwiązanie jest o tyle użyteczne,
że w przypadku, gdy podepniemy przewód do gniazda RJ-45 w naszym laptopie, to komunikacja będzie
odbywać się po kablu. Natomiast jeśli przewód zostanie odłączony, to system automatycznie przejdzie
na komunikację bezprzewodową. W tym wpisie spróbujemy zaprojektować sobie właśnie tego typu
mechanizm zarówno za sprawą pakietu <code>ifupdown</code> , gdzie konfiguracja interfejsów sieciowych jest
zarządzana przez plik <code>/etc/network/interfaces</code> , jak i przy pomocy natywnego rozwiązania jakie
oferuje systemd/networkd.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2016-01-02T15:07:13Z">Opublikowano: 02/01/2016</time>
	<time class="entry__meta-lastmod meta-lastmod" datetime="2020-03-29T16:20:00&#43;01:00">Zaktualizowano: 29/03/2020</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/">Odszyfrowanie kontenerów LUKS w systemd</a></h1>
	<div class="entry__content"><p>Osoby, które wykorzystują pełne szyfrowanie dysku, wiedzą, że nie zawsze da radę tak skonfigurować
swój system, by upchnąć go na jednej partycji. Nawet jeśli korzystamy z LVM wewnątrz kontenera LUKS,
to i tak zwykle możemy posiadać inne zaszyfrowane partycje, które są odrębną całością i montowane
osobno przy starcie systemu. W takim przypadku zwykle jesteśmy zmuszeni do podawania hasła do
każdego z tych dysków z osobna, co zajmuje czas. Ten problem opisałem po części przy okazji
<a href="https://morfikov.github.io/post/dropbox-i-kontener-luks/">implementacji kontenera LUKS na potrzeby
Dropbox'a</a>, jak i we wpisie poświęconym <a href="https://morfikov.github.io/post/przejscie-z-truecrypt-na-luks/">przejściu
z kontenerów TrueCrypt'a na te linux'owe, które są wspierane natywnie przez sam
kernel</a>. Niemniej jednak, tamto rozwiązanie
było oparte głównie o starszy init (sysvinit), co wymagało dodatkowej konfiguracji, tak by system
otworzył się po podaniu tylko jednego hasła. W tym wpisie postaramy się wdrożyć mechanizm, który
jest oferowany przez systemd.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2016-01-01T17:18:03Z">Opublikowano: 01/01/2016</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/ksztaltowanie-ruchu-sieciowego-traffic-control/">Kształtowanie ruchu sieciowego (Traffic Control)</a></h1>
	<div class="entry__content"><p>Każdy z nas chciałby, aby jego sieć działała możliwie szybko i bezproblemowo. W przypadku, gdy łącze
nie jest zbytnio obciążone, a my jesteśmy jedynym użytkownikiem internetu, to nie doświadczymy
raczej żadnych problemów z połączeniem. Rzecz w tym, że im więcej użytkowników ma nasza sieć, tym
większe prawdopodobieństwo, że zostanie ona przeciążona, tj. będziemy chcieli przesyłać więcej
danych niż sieć jest w stanie obsłużyć. W ten sposób zaczną pojawiać się kolejki pakietów na
interfejsach, których obsługa zajmuje trochę czasu. Rosą zatem opóźnienia, które są bardzo
odczuwalne w momencie, gdy ktoś lubi sobie pograć w różnego rodzaju gry online. Innym problemem może
być sieć P2P, gdzie pojedynczy host z naszej sieci może nawiązywać dziesiątki czy nawet setki
połączeń i tym samym zapychać łącze nie dając szansy innym użytkownikom na komfortowe korzystanie
z internetu. W obu przypadkach może nam pomóc <a href="http://lartc.org/lartc.html">kształtowanie ruchu
sieciowego</a> (Traffic Control), która jest w stanie nadać pakietom
odpowiedni priorytet, tak by część z nich nie musiała czekać zbyt długo w kolejce. W tym wpisie
przyjrzymy się bliżej temu mechanizmowi.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-12-15T20:40:52Z">Opublikowano: 15/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/ograniczanie-zasobow-procesom-przez-cgroups/">Ograniczanie zasobów procesom przez cgroups</a></h1>
	<div class="entry__content"><p>Nasze komputery obecnie mają dość pokaźne zasoby obliczeniowe. Jeszcze nie tak dawno temu
wyposażenie maszyny w 32 GiB pamięci RAM, czy też 8 rdzeni było czystą abstrakcją. Wydawałoby się,
że te powyższe parametry zaspokoją każdego. Niemniej jednak, nie ważne jak szybki i rozbudowany
będzie nasz PC, to nam zawsze będzie mało. Mamy dwa rdzenie, to chcemy cztery. Mamy cztery, to
chcemy osiem, itd. Poza tym, szereg aplikacji realizuje co raz więcej zadań i staje się bardziej
wymagająca z każdym mijającym rokiem. Jeśli nie przeprowadzamy modernizacji sprzętu, to może się
okazać, że w niedługim czasie zabraknie nam pamięci albo pewne operacje będą wykonywane bardzo
wolno. W sporej części przypadków nie obędzie się bez wymiany podzespołów ale nawet w przypadku, gdy
mamy spory zapas zasobów systemowych, to poszczególne procesy rywalizują o nie ze sobą. Często bywa
tak, że chcielibyśmy, aby konkretny proces wykonał się szybciej, a to pociąga za sobą, np. zmianę
priorytetów w dostępie do rdzeni procesora. W linux'ie jest mechanizm zwany
<a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a>, który potrafi ograniczyć zasoby całym aplikacjom
bez względu na to ile ona by miała procesów. W tym wpisie postaramy się przebrnąć przez proces
konfiguracji tego mechanizmu i spróbujemy wyprofilować sobie nasz system.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2015-12-08T21:21:53Z">Opublikowano: 08/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
</article>
				</div>
			
		</div>
	</main>
	
<div class="pagination block">
				<span class="pagination__item pagination__item--active" data-total="3">1</span>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/tags/systemd/page/2/">2</a>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/tags/systemd/page/3/">3</a>
</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2023 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
const images = Array.from(document.querySelectorAll(".entry__content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null,  
    background: 'rgba(0, 0, 0, 0.8)'
  });
});
</script>
</body>
</html>
