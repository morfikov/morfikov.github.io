<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>systemd on Morfitronik</title>
    <link>https://morfikov.github.io/tags/systemd/</link>
    <description>Recent content in systemd on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sat, 02 Feb 2019 06:12:18 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/systemd/feed.xml" rel="self" type="application/rss" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zalogować błędy podczas zamykania systemu Debian Linux</title>
      <link>https://morfikov.github.io/post/jak-zalogowac-bledy-podczas-zamykania-systemu-debian-linux/</link>
      <pubDate>Sat, 02 Feb 2019 06:12:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zalogowac-bledy-podczas-zamykania-systemu-debian-linux/</guid>
      <description>&lt;p&gt;By wyłączyć komputer, jego system operacyjny musi pierw zatrzymać (lub też ubić siłowo) wszystkie
działające usługi za wyjątkiem tego mającego PID z numerkiem 1. Zwykle proces zamykania się systemu
Debian Linux nie trwa więcej niż parę sekund ale czasami pojawiają się dziwne problemy, które mogą
to zadanie utrudnić lub też całkowicie uniemożliwić. Nawet jeśli system będzie się w stanie
zresetować, to zanim to nastąpi, to na konsoli mogą pojawić się komunikaty mogące pomóc nam w
zdiagnozowaniu dolegliwości, która doskwiera naszej maszynie. Problem w tym, że część tych
wiadomości nie zostanie nigdy zalogowana do pliku, gdzie moglibyśmy ich poszukać. Dzieje się tak
dlatego, że w pewnym określonym momencie zamykania się systemu trzeba wyłączyć usługę logowania, co
zwykle widać w logu jako &lt;code&gt;systemd-journald[]: Journal stopped&lt;/code&gt; . Gdy dziennik zostanie zatrzymany,
żadna wiadomość, która od tego momentu pojawi się na ekranie, nie zostanie już zalogowana do pliku.
Jeśli teraz pojawią nam się ostrzeżenia lub błędy, a po chwili komputer się zresetuje, to możemy
mieć nie lada problem z ustaleniem przyczyny mimo, że system nam ją zgłasza. Przydałoby się zapisać
te komunikaty, tylko jak to zrobić, skoro usługa logowania jest już nieaktywna?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja DDNS dla OpenDNS</title>
      <link>https://morfikov.github.io/post/konfiguracja-ddns-dla-opendns/</link>
      <pubDate>Mon, 23 May 2016 20:09:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-ddns-dla-opendns/</guid>
      <description>&lt;p&gt;Ludzkość w dalszym ciągu siedzi na przestarzałym już od prawie 20 lat protokole IPv4. Nie widać, też
by w najbliższym czasie coś miało się w tej kwestii zmienić. Można, co prawda, wykupić sobie stały
adres IP ale to kosztuje, no i płacimy za coś co powinniśmy mieć w standardzie, gdyby ludzie w końcu
zaczęli korzystać z IPv6. Niemniej jednak, by te wszystkie nasze maszyny podłączyć jakoś do sieci,
potrzebne nam są prywatne adresy IP + NAT lub też dynamicznie zmieniające się adresy publiczne.
Bywają też przypadki, że mamy przydzielane dynamicznie adresy z puli prywatnej, np. w wyniku dbania
o prywatność w sieciach WiFi przez &lt;a href=&#34;https://morfikov.github.io
/post/jak-przypisac-losowy-adres-mac-interfejsu/&#34;&gt;generowanie sobie przy każdym połączeniu losowego adresu
MAC&lt;/a&gt;. Zwykle w takiej sytuacji
zmienia nam się adres zewnętrzny (publiczny), który wskazuje na jeden z adresów naszego ISP. Taki
zmieniający się adres powoduje problemy przy konfiguracji poszczególnych usług sieciowych, np. gdy w
grę wchodzi konfiguracja filtra DNS, który jest zapewniany przez OpenDNS. By tego typu niedogodności
rozwiązać, możemy posłużyć się &lt;a href=&#34;https://pl.wikipedia.org/wiki/DDNS&#34;&gt;DDNS (dynamic DNS)&lt;/a&gt;. Za każdym
razem, gdy adres IP ulega zmianie, klient DDNS informuje o tym fakcie skonfigurowane usługi. W tym
artykule przyjrzymy się nieco bliżej temu mechanizmowi.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Mechanizm inhibitor lock w systemd</title>
      <link>https://morfikov.github.io/post/mechanizm-inhibitor-lock-w-systemd/</link>
      <pubDate>Thu, 04 Feb 2016 23:36:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/mechanizm-inhibitor-lock-w-systemd/</guid>
      <description>&lt;p&gt;Hibernacja w przypadku komputerów, zwłaszcza laptopów, to bardzo użyteczny wynalazek. Na linux&#39;ach
wymaga ona czasem lekkiej konfiguracji ale generalnie można powiedzieć, że działa OOTB. Po migracji
szeregu dystrybucji na systemd, proces hibernacji zdaje się przebiegać nieco inaczej niż to miało
miejsce w przeszłości. Bardzo często możemy się spotkać z sytuacjami, gdzie przy próbie
zahibernowania czy wyłączenia systemu, ten zwyczajnie ignoruje nasze żądanie i pracuje dalej jak
gdyby nigdy nic. W tym przypadku nie mamy do czynienia z bug&#39;iem ale ficzerem. Okazuje się bowiem,
że systemd dysponuje mechanizmem zwanym &lt;a href=&#34;https://www.freedesktop.org/wiki/Software/systemd/inhibit/&#34;&gt;inhibitor
lock&lt;/a&gt;, który ma na celu powstrzymanie
systemu od dokonania hibernacji, uśpienia lub wyłączenia w pewnych określonych sytuacjach. W tym
wpisie przyjrzymy się nieco bliżej temu mechanizmowi.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja jasności ekranu w laptopie (backlight)</title>
      <link>https://morfikov.github.io/post/konfiguracja-jasnosci-ekranu-w-laptopie-backlight/</link>
      <pubDate>Tue, 05 Jan 2016 21:52:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-jasnosci-ekranu-w-laptopie-backlight/</guid>
      <description>&lt;p&gt;Linux nigdy nie był popularnym systemem operacyjnym na stacjach klienckich. Może i cieszy się sporym
wzięciem wśród środowisk serwerowych ale jego niezbyt prosta obsługa nie przemawia do przeciętnego
użytkownika komputera. Wraz z rozwojem technologi, zmienił się też rodzaj urządzeń na jakich
obecnie pracujemy. W dzisiejszych czasach liczy się przede wszystkim mobilność i praktycznie każdy z
nas miał już prawdopodobnie do czynienia z laptopami. Producenci tych urządzeń lubią nam wciskać
windowsa z dopiskiem, że ten laptop bez niego nie będzie w ogóle nam działał. Już od dość dawna
szereg laptopów jest w stanie pracować pod linux&#39;em ale, jakby nie patrzeć, sporo rzeczy w nich nie
działa OOTB i trzeba poświęcić trochę czasu, by tę maszynę doprowadzić do porządku. W tym wpisie
zajmiemy się zagadnieniem podświetlania matrycy (backlight), tak by system był w stanie bez problemu
zapisać ustawienia jasności ekranu przy wyłączaniu komputera oraz, by potrafił je także wczytać
podczas fazy rozruchu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Temperatura dysku twardego (hddtemp)</title>
      <link>https://morfikov.github.io/post/temperatura-dysku-twardego-hddtemp/</link>
      <pubDate>Sun, 03 Jan 2016 16:24:45 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/temperatura-dysku-twardego-hddtemp/</guid>
      <description>&lt;p&gt;Obecnie dyski twarde nie są potrzebne do prawidłowego działania komputera. Mając sporo pamięci
operacyjnej oraz &lt;a href=&#34;https://pl.wikipedia.org/wiki/Live_CD&#34;&gt;system live&lt;/a&gt;, możemy bez problemu korzystać
z takiego sprzętu. Niemniej jednak, systemy live są nieco ograniczone. Najdotkliwszą ich wadą jest
brak zapisywania wprowadzanych zmian. W pewnych przypadkach ta cecha może być bardzo pożądana ale
jeśli chodzi o przeciętnego użytkownika, to chciałby on raczej mieć możliwość zapisu swojej pracy.
Dlatego też zewnętrzny magazyn danych w postaci dysku twardego nie prędko wyjdzie z użytku. Te
urządzenia, jak i większość tych, które podłączamy do naszego komputera, wydzielają ciepło.
Temperatura jest wrogiem numer 1 w przypadku maszyn i musi stale być monitorowana, tak by czasem nie
doszło do przegrzania sprzętu. &lt;a href=&#34;https://pl.wikipedia.org/wiki/Dysk_twardy&#34;&gt;Dyski HDD&lt;/a&gt; mają ten
problem, że im wyższa jest temperatura, tym obszar magnetyczny się bardziej rozszerza, a to powoduje
błędy odczytu i zapisu. Podobnie jest ze zbyt niską temperaturą, gdzie ścieżki i sektory ulegają
skurczeniu. Taki dysk musi pracować w odpowiednich warunkach termalnych. W tym wpisie postaramy się
ustalić aktualną temperaturę dysku oraz spróbujemy ją monitorować, tak by wiedzieć czy czynnik
temperaturowy nie zagraża czasem dyskom podpiętym do naszego PC.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak skonfigurować bonding w Debian linux (eth0&#43;wlan0)</title>
      <link>https://morfikov.github.io/post/konfiguracja-interfejsow-bond-bonding/</link>
      <pubDate>Sat, 02 Jan 2016 15:07:13 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-interfejsow-bond-bonding/</guid>
      <description>&lt;p&gt;W artykule poświęconym &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-polaczenia-wifi-pod-debianem/&#34;&gt;konfiguracji sieci WiFi na Debianie z wykorzystaniem narzędzia
wpa_supplicant&lt;/a&gt; wspomniałem parę słów na temat &lt;a href=&#34;https://www.kernel.org/pub/linux/kernel/people/marcelo/linux-2.4/Documentation/networking/bonding.txt&#34;&gt;interfejsu bond&lt;/a&gt;. Bonding na linux
wykorzystywany jest w zasadzie do spięcia kilku interfejsów sieciowych, w tym przewodowych
( &lt;code&gt;eth0&lt;/code&gt; ) i bezprzewodowych ( &lt;code&gt;wlan0&lt;/code&gt; ) w jeden (zwykle &lt;code&gt;bond0&lt;/code&gt; ). Takie rozwiązanie sprawia, że
w przypadku awarii któregoś z podpiętych interfejsów, my nie tracimy połączenia z siecią i nie
musimy nic nigdzie przełączać, by to połączenie przywrócić. To rozwiązanie jest o tyle użyteczne,
że w przypadku, gdy podepniemy przewód do gniazda RJ-45 w naszym laptopie, to komunikacja będzie
odbywać się po kablu. Natomiast jeśli przewód zostanie odłączony, to system automatycznie przejdzie
na komunikację bezprzewodową. W tym wpisie spróbujemy zaprojektować sobie właśnie tego typu
mechanizm zarówno za sprawą pakietu &lt;code&gt;ifupdown&lt;/code&gt; , gdzie konfiguracja interfejsów sieciowych jest
zarządzana przez plik &lt;code&gt;/etc/network/interfaces&lt;/code&gt; , jak i przy pomocy natywnego rozwiązania jakie
oferuje systemd/networkd.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Odszyfrowanie kontenerów LUKS w systemd</title>
      <link>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</link>
      <pubDate>Fri, 01 Jan 2016 17:18:03 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</guid>
      <description>&lt;p&gt;Osoby, które wykorzystują pełne szyfrowanie dysku, wiedzą, że nie zawsze da radę tak skonfigurować
swój system, by upchnąć go na jednej partycji. Nawet jeśli korzystamy z LVM wewnątrz kontenera LUKS,
to i tak zwykle możemy posiadać inne zaszyfrowane partycje, które są odrębną całością i montowane
osobno przy starcie systemu. W takim przypadku zwykle jesteśmy zmuszeni do podawania hasła do
każdego z tych dysków z osobna, co zajmuje czas. Ten problem opisałem po części przy okazji
&lt;a href=&#34;https://morfikov.github.io
/post/dropbox-i-kontener-luks/&#34;&gt;implementacji kontenera LUKS na potrzeby
Dropbox&#39;a&lt;/a&gt;, jak i we wpisie poświęconym &lt;a href=&#34;https://morfikov.github.io
/post/przejscie-z-truecrypt-na-luks/&#34;&gt;przejściu
z kontenerów TrueCrypt&#39;a na te linux&#39;owe, które są wspierane natywnie przez sam
kernel&lt;/a&gt;. Niemniej jednak, tamto rozwiązanie
było oparte głównie o starszy init (sysvinit), co wymagało dodatkowej konfiguracji, tak by system
otworzył się po podaniu tylko jednego hasła. W tym wpisie postaramy się wdrożyć mechanizm, który
jest oferowany przez systemd.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kształtowanie ruchu sieciowego (Traffic Control)</title>
      <link>https://morfikov.github.io/post/ksztaltowanie-ruchu-sieciowego-traffic-control/</link>
      <pubDate>Tue, 15 Dec 2015 20:40:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ksztaltowanie-ruchu-sieciowego-traffic-control/</guid>
      <description>&lt;p&gt;Każdy z nas chciałby, aby jego sieć działała możliwie szybko i bezproblemowo. W przypadku, gdy łącze
nie jest zbytnio obciążone, a my jesteśmy jedynym użytkownikiem internetu, to nie doświadczymy
raczej żadnych problemów z połączeniem. Rzecz w tym, że im więcej użytkowników ma nasza sieć, tym
większe prawdopodobieństwo, że zostanie ona przeciążona, tj. będziemy chcieli przesyłać więcej
danych niż sieć jest w stanie obsłużyć. W ten sposób zaczną pojawiać się kolejki pakietów na
interfejsach, których obsługa zajmuje trochę czasu. Rosą zatem opóźnienia, które są bardzo
odczuwalne w momencie, gdy ktoś lubi sobie pograć w różnego rodzaju gry online. Innym problemem może
być sieć P2P, gdzie pojedynczy host z naszej sieci może nawiązywać dziesiątki czy nawet setki
połączeń i tym samym zapychać łącze nie dając szansy innym użytkownikom na komfortowe korzystanie
z internetu. W obu przypadkach może nam pomóc &lt;a href=&#34;http://lartc.org/lartc.html&#34;&gt;kształtowanie ruchu
sieciowego&lt;/a&gt; (Traffic Control), która jest w stanie nadać pakietom
odpowiedni priorytet, tak by część z nich nie musiała czekać zbyt długo w kolejce. W tym wpisie
przyjrzymy się bliżej temu mechanizmowi.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Ograniczanie zasobów procesom przez cgroups</title>
      <link>https://morfikov.github.io/post/ograniczanie-zasobow-procesom-przez-cgroups/</link>
      <pubDate>Tue, 08 Dec 2015 21:21:53 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ograniczanie-zasobow-procesom-przez-cgroups/</guid>
      <description>&lt;p&gt;Nasze komputery obecnie mają dość pokaźne zasoby obliczeniowe. Jeszcze nie tak dawno temu
wyposażenie maszyny w 32 GiB pamięci RAM, czy też 8 rdzeni było czystą abstrakcją. Wydawałoby się,
że te powyższe parametry zaspokoją każdego. Niemniej jednak, nie ważne jak szybki i rozbudowany
będzie nasz PC, to nam zawsze będzie mało. Mamy dwa rdzenie, to chcemy cztery. Mamy cztery, to
chcemy osiem, itd. Poza tym, szereg aplikacji realizuje co raz więcej zadań i staje się bardziej
wymagająca z każdym mijającym rokiem. Jeśli nie przeprowadzamy modernizacji sprzętu, to może się
okazać, że w niedługim czasie zabraknie nam pamięci albo pewne operacje będą wykonywane bardzo
wolno. W sporej części przypadków nie obędzie się bez wymiany podzespołów ale nawet w przypadku, gdy
mamy spory zapas zasobów systemowych, to poszczególne procesy rywalizują o nie ze sobą. Często bywa
tak, że chcielibyśmy, aby konkretny proces wykonał się szybciej, a to pociąga za sobą, np. zmianę
priorytetów w dostępie do rdzeni procesora. W linux&#39;ie jest mechanizm zwany
&lt;a href=&#34;https://en.wikipedia.org/wiki/Cgroups&#34;&gt;cgroups&lt;/a&gt;, który potrafi ograniczyć zasoby całym aplikacjom
bez względu na to ile ona by miała procesów. W tym wpisie postaramy się przebrnąć przez proces
konfiguracji tego mechanizmu i spróbujemy wyprofilować sobie nasz system.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak wymusić sprawdzenie systemu plików w systemd</title>
      <link>https://morfikov.github.io/post/jak-wymusic-sprawdzenie-systemu-plikow-w-systemd/</link>
      <pubDate>Fri, 04 Dec 2015 20:11:46 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wymusic-sprawdzenie-systemu-plikow-w-systemd/</guid>
      <description>&lt;p&gt;Jakiś czas temu opisywałem jak w systemach linux&#39;owych przeprowadzić &lt;a href=&#34;https://morfikov.github.io
/post/sprawdzanie-bledow-systemu-plikow-ext4/&#34;&gt;sprawdzenie systemu plików pod
kątem ewentualnych błędów&lt;/a&gt;. Był tam
poświęcony kawałek na temat ręcznego wymuszenia takiego skanowania. Ten sposób, który został opisany
w tamtym wpisie działa wyśmienicie w przypadku sysvinit. Natomiast przy systemd mogą pojawić się
pewne problemy, w efekcie czego nie będziemy w stanie wymusić skanowania pewnych partycji.
Generalnie to rozchodzi się o tę główną, na której znajduje się system plików &lt;code&gt;/&lt;/code&gt; . Postanowiłem się
przyjrzeć nieco temu mechanizmowi i sprawdzić czy faktycznie nic nie da się zrobić i czy musimy
czekać pełną ilość cykli startu systemu, by ten system plików został przez niego przeskanowany
automatycznie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Przewidywalne nazwy interfejsów sieciowych</title>
      <link>https://morfikov.github.io/post/przewidywalne-nazwy-interfejsow-sieciowych/</link>
      <pubDate>Sun, 22 Nov 2015 21:44:11 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/przewidywalne-nazwy-interfejsow-sieciowych/</guid>
      <description>&lt;p&gt;Podczas jednej z aktualizacji systemu został mi zwrócony pewien komunikat. Oświadczał on bowiem, że
od jakiegoś czasu nazewnictwo interfejsów sieciowych w systemie uległo zmianie, oraz, że w wersji 10
debiana, ten obecny system nazw nie będzie już wspierany. Rozchodzi się o coś co nazywa się
&lt;a href=&#34;https://www.freedesktop.org/wiki/Software/systemd/PredictableNetworkInterfaceNames/&#34;&gt;Predictable Network Interface
Names&lt;/a&gt;, czyli
przewidywalne nazwy interfejsów sieciowych. Jako, że aktualne wydanie stabilnego debiana ma numerek
8 i w niedalekiej przyszłości zostanie wydana 9, to przydałoby się już zacząć migrować na ten nowy
system nazw. W tym wpisie dokonamy takiej migracji i zobaczymy jakie zmiany musimy poczynić, by nie
doświadczyć problemów związanych z tą migracją nazw.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Cache DNS, czyli włączenie buforowania zapytań</title>
      <link>https://morfikov.github.io/post/cache-dns-buforowania-zapytan/</link>
      <pubDate>Mon, 16 Nov 2015 20:13:06 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/cache-dns-buforowania-zapytan/</guid>
      <description>&lt;p&gt;Większość z nas wie, że standardowe instalacje systemu linux nie buforują żadnych zapytań do
serwerów DNS. Dzieje się tak dlatego, że te systemy domyślnie nie mają zainstalowanego żadnego
oprogramowania, które by im to umożliwiało. Niesie to ze sobą zwiększenie opóźnień transakcji
krótkoterminowych, np. tych w protokole http czy https. Za każdym razem gdy odwiedzamy jakiś serwis
www, musimy wykonać szereg zapytań DNS, by rozwiązać nazwy domen na adresy IP. W przypadku gdybyśmy
mieli cache DNS, to te nazwy nie musiałyby być za każdym każdym razem rozwiązywane na nowo,
przynajmniej nie przez odpytywanie zdalnego serwera DNS, do którego RTT wynosi jakieś 20-40ms.
Przydałoby się zatem nieco poprawić wydajność stron www i w tym wpisie postaramy się zaimplementować
prosty cache DNS z wykorzystaniem &lt;a href=&#34;http://www.thekelleys.org.uk/dnsmasq/doc.html&#34;&gt;narzędzia dnsmasq&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czyszczenie konsoli TTY w systemd</title>
      <link>https://morfikov.github.io/post/czyszczenie-konsoli-tty-w-systemd/</link>
      <pubDate>Sat, 07 Nov 2015 11:48:02 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czyszczenie-konsoli-tty-w-systemd/</guid>
      <description>&lt;p&gt;Podczas uruchamiania się systemu, na ekranie zwykle widzimy szereg komunikatów. Informują nas one o
tym jakie usługi są aktywowane oraz czy wystąpiły jakieś błędy. Po tym jak faza boot dobiegnie
końca, wszystkie te informacje dalej są wyświetlane na konsoli TTY i możemy je podejrzeć po
przyciśnięciu klawiszy Ctrl-Alt-F1 . W pewnych sytuacjach może to stwarzać zagrożenie
bezpieczeństwa, bo są tam zawarte informacje o tym jakie usługi zostały uruchomione. Przydałoby się
zatem wyczyścić tę konsolę TTY po załadowaniu się systemu i o tym będzie poniższy wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Skrót Ctrl-Alt-Del w systemd</title>
      <link>https://morfikov.github.io/post/skrot-ctrl-alt-del-w-systemd/</link>
      <pubDate>Sat, 07 Nov 2015 10:12:15 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/skrot-ctrl-alt-del-w-systemd/</guid>
      <description>&lt;p&gt;Po przesiadce z sysvinit na systemd okazało się, że system inaczej się zachowuje po przyciśnięciu
kombinacji klawiszy Ctrl-Alt-Del . Niby za wiele nie zmieniałem w konfiguracji systemu ale w żaden
sposób przy pomocy plików konfiguracyjnych nie szło zmienić zachowania tego powyższego skrótu.
Okazuje się bowiem, że w systemd, akcję pod ten skrót przypisuje się w nieco innym miejscu niż to
było robione w sysvinit. W tym wpisie postaramy się zmienić domyślne zachowanie tego skrótu, tak by
po jego przyciśnięciu wyłączyć komputer.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Brak dźwięku przy nieaktywnej sesji logowania</title>
      <link>https://morfikov.github.io/post/brak-dzwieku-przy-nieaktywnej-sesji-logowania/</link>
      <pubDate>Thu, 15 Oct 2015 20:52:50 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/brak-dzwieku-przy-nieaktywnej-sesji-logowania/</guid>
      <description>&lt;p&gt;Jeśli korzystamy z &lt;a href=&#34;https://www.freedesktop.org/wiki/Software/PulseAudio/&#34;&gt;serwera dźwięku
PulseAudio&lt;/a&gt; na swoim linux&#39;ie, prawdopodobnie
zdarzyła nam się już sytuacja, w której chcieliśmy zablokować lub wygasić ekran monitora mając
jednocześnie odpalony jakiś odtwarzacz muzyki. Gdy tylko ekran zostanie zablokowany, możemy
odnotować brak dźwięku, bo ten zwyczajnie natychmiast zamiera. Za to po odblokowaniu ekranu, dźwięk
wraca. Podobnie sprawa ma się przy przejściu z trybu graficznego (Xorg) na jedną z konsol TTY.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wyłączenie WOL w karcie sieciowej</title>
      <link>https://morfikov.github.io/post/wylaczenie-wol-w-karcie-sieciowej/</link>
      <pubDate>Sun, 04 Oct 2015 16:36:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wylaczenie-wol-w-karcie-sieciowej/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://pl.wikipedia.org/wiki/Wake_on_LAN&#34;&gt;WOL&lt;/a&gt; (Wake On LAN) to taki ficzer, który umożliwia
włączenie komputera przez sieć. By tego typu sytuacja miała miejsce, zarówno karta sieciowa oraz
płyta główna komputera musi wspierać WOL. Dodatkowo, BIOS maszyny musi mieć aktywowaną odpowiednią
opcję. Obecnie WOL jest implementowany praktycznie w każdej płycie głównej i karcie sieciowej, także
raczej możemy przyjąć, że nasz komputer może zostać wybudzony za pomocą kabla sieciowego. Stwarza to
oczywiście zagrożenie bezpieczeństwa ale poza tym, w grę wchodzi także większy pobór energii. Jeśli
nie korzystamy z WOL, to jest on dla nas zbędny i należałoby go wyłączyć.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Aplikowanie zmiennych sysctl przy pomocy udev&#39;a</title>
      <link>https://morfikov.github.io/post/aplikowanie-zmiennych-sysctl-przy-pomocy-udeva/</link>
      <pubDate>Sun, 06 Sep 2015 11:08:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/aplikowanie-zmiennych-sysctl-przy-pomocy-udeva/</guid>
      <description>&lt;p&gt;Kernele linux&#39;owe mają dość sporo opcji, które możemy zmienić przy pomocy pliku &lt;code&gt;/etc/sysctl.conf&lt;/code&gt; .
Niby nic nadzwyczajnego ale co w przypadku tych zmiennych, które muszą być ustawione, z tym, że
moduł, który stworzy odpowiednie ścieżki w katalogu &lt;code&gt;/proc/sys/&lt;/code&gt; , nie został załadowany z jakichś
względów przy starcie systemu? Zmienne te nie zostaną ustawione, a w logu pojawi się komunikat
informujący nas o nieodnalezieniu określonego pliku. Okazuje się, że jesteśmy w stanie aplikować
określone ustawienia sysctl w momencie ładowania określonych modułów i temu mechanizmowi się
przyjrzymy bliżej w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Fragmentacja pakietu i zmiana wartości MTU</title>
      <link>https://morfikov.github.io/post/fragmentacja-pakietu-i-zmiana-wartosci-mtu/</link>
      <pubDate>Mon, 29 Jun 2015 21:35:12 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/fragmentacja-pakietu-i-zmiana-wartosci-mtu/</guid>
      <description>&lt;p&gt;MTU (Maximum Transmission Unit) to maksymalna długość pakietu jaki może zostać przesłany przez sieć.
Może ona wynosić do 64KiB ale większość punktów sieciowych, takich jak routery, wymusza o wiele
mniejsze rozmiary pakietów. Domyślna wartość MTU dla protokołu Ethernet to 1500 bajtów, oczywiście
bez nagłówka warstwy fizycznej, który ma dodatkowe 14 bajtów. Czasami te standardowe ustawienia mogą
powodować problemy w przypadku pewnych konfiguracji sieci i gdy ich doświadczamy, przydałoby się
zmienić rozmiar MTU przesyłanych pakietów.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>PeerGuardian w oparciu o ipset i iptables</title>
      <link>https://morfikov.github.io/post/peerguardian-w-oparciu-o-ipset-iptables/</link>
      <pubDate>Tue, 23 Jun 2015 22:50:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/peerguardian-w-oparciu-o-ipset-iptables/</guid>
      <description>&lt;p&gt;Wiele klientów torrenta umożliwia ładowanie zewnętrznej listy z zakresami adresów IP i ta lista ma
służyć jako swego rodzaju filtr połączeń chroniący nas przed różnego rodzaju organizacjami, które
mogą zbierać i przetwarzać informacje na temat naszego IP i tego co on porabia w sieci p2p.
Oczywiście, kwestia czy korzystać z takiego typu rozwiązania jest bardzo dyskusyjna i wiele osób
jest zdania, że to tak naprawdę w niczym nie pomoże, a wręcz nawet przyczynia się do
samounicestwienia sieci p2p. Także taki filter może czasem przynieść więcej szkody niż pożytku,
zwłaszcza gdy się go używa lekkomyślnie, czyli na zasadzie, że ten co blokuje więcej adresów musi
być lepszy. Poniżej opiszę wykorzystanie rozszerzenia &lt;code&gt;ipset&lt;/code&gt;, przy pomocy którego zostanie
zablokowany szereg klas adresów. Całość raczej nie skupia się na implementacji filtra, to tylko
przykład do czego &lt;code&gt;ipset&lt;/code&gt; może posłużyć, a że ja nie umiem teoretycznie pisać, to muszę na
przykładach.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Firewall na linux&#39;owe maszyny klienckie</title>
      <link>https://morfikov.github.io/post/firewall-na-linuxowe-maszyny-klienckie/</link>
      <pubDate>Mon, 22 Jun 2015 23:33:58 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/firewall-na-linuxowe-maszyny-klienckie/</guid>
      <description>&lt;p&gt;Prędzej czy później, każdy z nas będzie musiał zabezpieczyć dostęp do swojego komputera w sieci. Do
tego zadania na stacjach z linux&#39;em jest oddelegowane narzędzie &lt;code&gt;iptables&lt;/code&gt; wraz z szeregiem
dodatków, jak np. &lt;code&gt;ipset&lt;/code&gt; . By zbudować solidny firewall nie potrzeba zbytnio się wysilać. Niemniej
jednak, temat zapory linux&#39;owej jest &lt;a href=&#34;https://www.frozentux.net/iptables-tutorial/iptables-tutorial.html&#34;&gt;bardzo
rozległy&lt;/a&gt; i nie będziemy tutaj
opisywać wszystkich możliwych scenariuszy jej zastosowania. Zamiast tego skupimy się jedynie na
bazowym skrypcie, który można rozbudować bez przeszkód i dostosować go zarówno pod maszyny klienckie
jak i te serwerowe.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
