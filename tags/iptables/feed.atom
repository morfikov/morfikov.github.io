<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>iptables on Morfitronik</title>
    <link>https://morfikov.github.io/tags/iptables/</link>
    <description>Recent content in iptables on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Fri, 15 Mar 2019 18:02:21 +0000</lastBuildDate><atom:link href="https://morfikov.github.io/tags/iptables/feed.atom" rel="self" type="application/atom+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czy linux&#39;owy firewall powinien blokować pakiety not-syn w stanie NEW</title>
      <link>https://morfikov.github.io/post/czy-linuxowy-firewall-powinien-blokowac-pakiety-not-syn-w-stanie-new/</link>
      <pubDate>Fri, 15 Mar 2019 18:02:21 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-linuxowy-firewall-powinien-blokowac-pakiety-not-syn-w-stanie-new/</guid>
      <description>&lt;p&gt;Od czasu do czasu w logu systemowym mojego Debiana można zanotować szereg pakietów przychodzących,
które są zrzucane przez linux&#39;owy firewall (&lt;code&gt;nftables&lt;/code&gt;/&lt;code&gt;iptables&lt;/code&gt; ). Po krótkiej analizie okazało
się, że są to pakiety protokołu TCP mające stan &lt;code&gt;NEW&lt;/code&gt; (czyli są to nowe połączenia) ale
niezawierające przy tym flagi &lt;code&gt;SYN&lt;/code&gt; . Mój laptop nie ma aktualnie przydzielonego zewnętrznego
routowalnego adresu IPv4/IPv6, więc nasunęło się pytanie o przyczynę takiego stanu
rzeczy -- przecie będąc za NAT, nikt spoza sieci nie powinien być w stanie nawiązać połączenia z
moją maszyną, a ewidentnie co się do jej bram dobija i to nie z adresu lokalnego. Niby mam też
odfiltrowane pakiety w stanie &lt;code&gt;INVALID&lt;/code&gt; (np. te mające niepoprawny zestaw flag) ale widać te
pakiety, o których mowa, nie zaliczają się do tego stanu, więc wygląda na to, że wszystko z nimi
jest w porządku. Czy tego typu pakiety TCP w stanie &lt;code&gt;NEW&lt;/code&gt; niemające ustawionej flagi &lt;code&gt;SYN&lt;/code&gt;
stanowią jakieś zagrożenie dla naszego komputera? Czy powinno się je zablokować, a może przepuścić
w filtrze pakietów? A jeśli zablokować, to czy zwykły &lt;code&gt;DROP&lt;/code&gt; wystarczy czy może powinno się te
pakiety potraktować przy pomocy &lt;code&gt;REJECT&lt;/code&gt; ?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Migracja z iptables na nftables w Debianie</title>
      <link>https://morfikov.github.io/post/migracja-z-iptables-na-nftables-w-debianie/</link>
      <pubDate>Sat, 16 Feb 2019 11:05:40 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/migracja-z-iptables-na-nftables-w-debianie/</guid>
      <description>&lt;p&gt;Zgodnie z &lt;a href=&#34;http://ral-arturo.org/2018/06/16/nfws2018.html&#34;&gt;informacją&lt;/a&gt;, która pojawiła się już ponad pół roku temu, dystrybucje linux&#39;a powoli
zaczynają odchodzić od &lt;code&gt;iptables&lt;/code&gt; . Prawdopodobnie w niedługim czasie &lt;code&gt;iptables&lt;/code&gt; zostanie już
całkowicie wyparty i zastąpiony przez &lt;code&gt;nftables&lt;/code&gt; , przynajmniej jeśli chodzi o desktopy. Nawet
&lt;a href=&#34;https://wiki.debian.org/nftables#Current_status&#34;&gt;Debian zakomunikował&lt;/a&gt;, że następne wydanie stabilne tej dystrybucji (Buster) będzie domyślnie
wykorzystywało &lt;code&gt;nftables&lt;/code&gt; . Wypadałoby zatem się przenieść na ten nowy framework i przygotować
sobie kilka podstawowych reguł firewall&#39;a, które zabezpieczoną naszą maszynę przed nieautoryzowanym
dostępem z sieci.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Czy brak wsparcia dla SYNPROXY w nftables jest problemem</title>
      <link>https://morfikov.github.io/post/czy-brak-wsparcia-dla-synproxy-w-nftables-jest-problemem/</link>
      <pubDate>Sat, 16 Feb 2019 10:20:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/czy-brak-wsparcia-dla-synproxy-w-nftables-jest-problemem/</guid>
      <description>&lt;p&gt;Przenosząc swoje reguły z &lt;code&gt;iptables&lt;/code&gt; na &lt;code&gt;nftables&lt;/code&gt; zauważyłem, że jedna z nich (gdyby tylko jedna)
nie została przetłumaczona przez ten dedykowany translator do reguł. Chodzi
o &lt;a href=&#34;/post/unikanie-atakow-ddos-z-synproxy/&#34;&gt;mechanizm SYNPROXY&lt;/a&gt;, który jest zwykle wykorzystywany do ograniczenia skali ataków DDOS z
wykorzystaniem pakietów SYN. Co by nie mówić, to ochrona jaką daje SYNPROXY jest jak najbardziej
pożądana z perspektywy serwerów. Dlaczego zatem, gdy się zajrzy na stronę
&lt;a href=&#34;https://wiki.nftables.org/wiki-nftables/index.php/Supported_features_compared_to_xtables&#34;&gt;wspieranych rzeczy w nftables&lt;/a&gt;, to przy SYNPROXY widnieje bliżej nieokreślone sformułowanie
&lt;code&gt;consider native interface&lt;/code&gt; ? Po rozmowach z deweloperami udało się ustalić, że ten zapis oznacza
brak wsparcia dla SYNPROXY w &lt;code&gt;nftables&lt;/code&gt; . Jeśli zatem ktoś wykorzystuje ten mechanizm mając dodane
stosowne reguły w &lt;code&gt;iptables&lt;/code&gt; , to czy powinien się on obawiać przejścia na &lt;code&gt;nftables&lt;/code&gt; ?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ustalić nazwę procesu korzystającego z sieci</title>
      <link>https://morfikov.github.io/post/jak-ustalic-nazwe-procesu-korzystajacego-z-sieci/</link>
      <pubDate>Fri, 08 Feb 2019 20:10:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ustalic-nazwe-procesu-korzystajacego-z-sieci/</guid>
      <description>&lt;p&gt;Konfigurując filtr pakietów &lt;code&gt;iptables&lt;/code&gt;/&lt;code&gt;nftables&lt;/code&gt; na Debianie zwykle nie przykładamy większej wagi
do procesów, które chcą nawiązać połączenia wychodzące z naszego linux&#39;owego hosta. Mamy przecież
&amp;quot;skonfigurowany&amp;quot; firewall w łańcuchach &lt;code&gt;INPUT&lt;/code&gt; i &lt;code&gt;FORWARD&lt;/code&gt; i wszelkie zagrożenia z sieci nie
powinny nas dotyczyć. Problem w tym, że jeśli jakiś złowrogi proces zostanie uruchomiony w naszym
systemie, to jest on w stanie komunikować się ze światem zewnętrznym praktycznie bez żadnych
ograniczeń za sprawą braku jakichkolwiek reguł w łańcuchu &lt;code&gt;OUTPUT&lt;/code&gt; . Można oczywiście temu zaradzić
budując zaporę sieciową na bazie &lt;code&gt;cgroups&lt;/code&gt; , gdzie każda aplikacja będzie miała oznaczone pakiety,
przez co będzie można je rozróżnić i zablokować albo przepuścić przez filter. W tym wpisie jednak
nie będziemy się zajmować konstrukcją tego typu FW, tylko spróbujemy sobie odpowiedzieć na pytanie
jak namierzyć proces, który komunikuje się z siecią (lub też próbuje), posiadając jedynie log
&lt;code&gt;iptables&lt;/code&gt;/&lt;code&gt;nftables&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Apache2: Moduł evasive, ipset i iptables (anty DOS/DDOS)</title>
      <link>https://morfikov.github.io/post/apache2-modul-evasive-ipset-iptables/</link>
      <pubDate>Sat, 06 Aug 2016 09:13:20 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/apache2-modul-evasive-ipset-iptables/</guid>
      <description>&lt;p&gt;Apache2 ma kilka ciekawych modułów, które mogą uchronić nasz serwer www przed atakami DOS i DDOS.
Jednym z nich jest moduł &lt;code&gt;evasive&lt;/code&gt; . Nie jest on jednak oficjalnym modułem i brak o nim
jakiejkolwiek wzmianki w oficjalnej dokumentacji na stronie Apache2. Niemniej jednak, jest to bardzo
prosty moduł składający się dosłownie z kilku dyrektyw, które są w stanie zablokować zapytania o
zasoby serwera w przypadku, gdy zostanie przekroczony pewien ustalony przez nas limit. Dodatkowo,
ten moduł może współgrać z filtrem &lt;code&gt;iptables&lt;/code&gt; oraz &lt;code&gt;ipset&lt;/code&gt; , dając nam możliwość wygodnego
blokowania uporczywych klientów na poziomie pakietów sieciowych.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>nf_conntrack: automatic helper assignment is deprecated</title>
      <link>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</link>
      <pubDate>Sat, 16 Jul 2016 18:59:19 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/nf_conntrack-automatic-helper-assignment-deprecated/</guid>
      <description>&lt;p&gt;Jeśli ktoś uważnie śledzi logi systemowe, to od czasu do czasu można w nich znaleźć komunikat,
którzy brzmi mniej więcej tak: &lt;code&gt;nf_conntrack: automatic helper assignment is deprecated and it will be removed soon. Use the iptables CT target to attach helpers instead&lt;/code&gt; . Ta wiadomość odnosi się do
jednego z modułów linux&#39;owego filtra pakietów &lt;code&gt;iptables&lt;/code&gt; . Moduł, o którym mowa to &lt;code&gt;nf_conntrack&lt;/code&gt; ,
który odpowiada za śledzenie połączeń nawiązywanych przez system. Sam komunikat zaś dotyczy
mechanizmów pomocniczych, których sposób aktywacji jest już nieco przestarzały i zostanie wkrótce
usunięty. Co to oznacza dla przeciętnego użytkownika linux&#39;a i czym są w istocie te mechanizmy
pomocnicze, które znajdują zastosowane na zaporze sieciowej?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak wyczyścić tablicę conntrack&#39;a w debianie</title>
      <link>https://morfikov.github.io/post/jak-wyczyscic-tablice-conntrack-w-debianie/</link>
      <pubDate>Sun, 05 Jun 2016 12:34:55 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wyczyscic-tablice-conntrack-w-debianie/</guid>
      <description>&lt;p&gt;Sporo użytkowników lunux&#39;a, zwłaszcza dystrybucji debian, korzysta z własnych skryptów firewall&#39;a
aplikujących reguły &lt;code&gt;iptables&lt;/code&gt; . Tego typu rozwiązanie ma jednak swoje wady i zalety. Niewątpliwie
do zalet można zaliczyć brak dodatkowego oprogramowania obsługującego zaporę sieciową. Jeśli chodzi
zaś o wady, to niestety cały skrypt trzeba sobie dobrze przemyśleć przed zaaplikowaniem. Ludzie
często zapominają tutaj o śledzeniu połączeń przez kernel. To właśnie na podstawie wpisów w
&lt;code&gt;/proc/net/ip_conntrack&lt;/code&gt; lub &lt;code&gt;/proc/net/nf_conntrack&lt;/code&gt; system wie, które pakiety należy na zaporze
przepuścić, a które zablokować. Jeśli teraz dodajemy reguły do filtra &lt;code&gt;iptables&lt;/code&gt; , to nowa polityka
zapory nie będzie odnosić się do tych nawiązanych już połączeń, które są określone w tablicy
conntrack&#39;a. By się upewnić, że tego typu scenariusz nigdy nas nie spotka, musimy tę tablicę
opróżnić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Równoważenie ruchu łącz kilku ISP (load balancing)</title>
      <link>https://morfikov.github.io/post/rownowazenie-ruchu-lacz-kilku-isp-load-balancing/</link>
      <pubDate>Sun, 22 May 2016 13:40:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/rownowazenie-ruchu-lacz-kilku-isp-load-balancing/</guid>
      <description>&lt;p&gt;Podłączenie pojedynczego komputera do sieci raczej nie stanowi żadnego problemu dla przeciętnego
użytkownika linux&#39;a. Wystarczy jedynie skonfigurować kilka parametrów i możemy oglądać swoje
ulubione serwisy www. Co jednak w przypadku, gdy mamy do dyspozycji kilka łącz internetowych? Jedną
z opcji jest używanie łącza tego ISP, które jest lepsze gabarytowo, a pozostałe łącza trzymać na
wypadek awarii tego pierwszego. Nie jest to zbytnio satysfakcjonujące rozwiązanie, zwłaszcza w
przypadku, gdy tym providerom płacimy za świadczone nam usługi. W taki sposób płacimy, np. za dwa
łącza, a korzystamy z jednego w danej chwili. W linux&#39;ie obsługa wielu łącz różnych ISP jest dość
skomplikowana. By taki mechanizm zaimplementować sobie, trzeba stworzyć kilka tablic routingu.
Następnie ruch sieciowy musi zostać oznaczony w &lt;code&gt;iptables&lt;/code&gt; i przekierowany do tych tablic przez
kernel. Przy odrobienie wysiłku jesteśmy jednak w stanie zaprojektować sobie load balancer, który
będzie równoważył obciążenie łącza między kilku ISP. Dodatkowo, jeśli jedno z łączy nam nawali, to
automatycznie zostaniemy przełączeni na drugie łącze (failover). W tym artykule postaramy się
zaprojektować taki właśnie mechanizm.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Quality of Service (QoS) w OpenWRT</title>
      <link>https://morfikov.github.io/post/quality-service-qos-w-openwrt/</link>
      <pubDate>Thu, 19 May 2016 15:07:54 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/quality-service-qos-w-openwrt/</guid>
      <description>&lt;p&gt;Wszyscy spotkaliśmy się z sytuacją, w której z bliżej nieokreślonego powodu nie mogliśmy przeglądać
stron w internecie. Niby połączenie jest, mamy też dobrej klasy ISP ale net nam muli. W olbrzymiej
części przypadków winą można obarczyć sieć &lt;a href=&#34;https://pl.wikipedia.org/wiki/Peer-to-peer&#34;&gt;Peer to Peer
(P2P)&lt;/a&gt;. Przy nieodpowiedniej konfiguracji klientów tej
sieci może dojść do nawiązywania całej masy połączeń w ułamku chwili. W ten sposób nawet jeśli nic
aktualnie nie wysyłamy lub nie pobieramy, to i tak te połączenia same w sobie zapychają łącze, no bo
przecież nawet puste pakiety w protokołach TCP/UDP zawierają nagłówki, a te już swoje ważą. Gdy sami
korzystamy z łącza, to taka sytuacja nie stanowi większego problemu, bo wystarczy odpalić klienta
torrent&#39;a w wolnym czasie. Natomiast w przypadku, gdy zachodzi potrzeba wejścia na jakiś serwis www,
to możemy zwyczajnie tego klienta wyłączyć. Nie jest to jednak wygodne. Jak zatem wyeliminować
problemy związane z siecią P2P? Jeśli na routerze mamy wgrany firmware OpenWRT, to możemy
zaimplementować na nim &lt;a href=&#34;https://pl.wikipedia.org/wiki/Quality_of_service&#34;&gt;mechanizm QoS (Qality of
Service)&lt;/a&gt;. W ten sposób możemy nadać usługom
priorytety. W niniejszym wpisie postaramy się wdrożyć takie rozwiązanie w oparciu o narzędzia
&lt;code&gt;iptables&lt;/code&gt; oraz &lt;code&gt;tc&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Target MARK w iptables (sumowanie oznaczeń)</title>
      <link>https://morfikov.github.io/post/target-mark-w-iptables/</link>
      <pubDate>Wed, 18 May 2016 15:17:25 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/target-mark-w-iptables/</guid>
      <description>&lt;p&gt;Pakiety i połączenia można oznaczać w &lt;code&gt;iptables&lt;/code&gt; za pomocą target &lt;code&gt;MARK&lt;/code&gt; oraz &lt;code&gt;CONNMARK&lt;/code&gt; . Ta
właściwość tego filtra jest znana chyba większość użytkowników linux&#39;a. Z reguły nie interesujemy
się zbytnio szczegółami oznaczania pakietów/połączeń, bo zwykle jest ono przeprowadzane prawidłowo.
Niemniej jednak, są przypadki, w których markery nie będą ustawiane poprawnie. Chodzi o sytuacje,
gdzie mamy do czynienia z kilkoma mechanizmami oznaczającymi pakiety. Dla przykładu weźmy sobie
kształtowanie ruchu za pomocą narzędzia &lt;code&gt;tc&lt;/code&gt; oraz failover czy load balancing łącza w oparciu o
różne tablice routingu. W obu tych mechanizmach zwykle używa się markowania pakietów w
&lt;code&gt;iptables&lt;/code&gt; . Co się jednak dzieje z takim pakietem, gdy przechodzi przez reguły zarówno pierwszego
jak i drugiego mechanizmu? To właśnie spróbujemy ustalić w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Debugowanie reguł iptables via target TRACE</title>
      <link>https://morfikov.github.io/post/debugowanie-regul-iptables-target-trace/</link>
      <pubDate>Wed, 11 May 2016 13:20:25 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/debugowanie-regul-iptables-target-trace/</guid>
      <description>&lt;p&gt;Linux&#39;owy firewall w postaci &lt;code&gt;iptables&lt;/code&gt; może czasami mieć zdefiniowanych sporo reguł. W takim
gąszczu jest czasem ciężko się odnaleźć. Bywa zwykle tak, że dodając kolejną regułę chcemy
przyblokować szereg pakietów, a mimo to przechodzą one przez zaporę jak gdyby nigdy nic. W takim
przypadku zaczyna się mozolne przeszukiwanie reguł w &lt;code&gt;iptables&lt;/code&gt; i próba ustalenia, którą z nich
zaakceptowała interesujący nas pakiet. Nie musimy jednak głowić się aż tak, by w miarę szybko dociec
jak te reguły przez filtr przechodzą i jak są przetwarzane. Możemy skorzystać z mechanizmu śledzenia
reguł, który jest wbudowany bezpośrednio w &lt;code&gt;iptables&lt;/code&gt; . Mowa oczywiście o target &lt;code&gt;TRACE&lt;/code&gt; . W tym
artykule zobaczymy jak przy pomocy &lt;code&gt;TRACE&lt;/code&gt; ustalić, przez które reguły i łańcuchy przechodzi pakiet.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zablokować Facebook i YouTube w OpenWRT</title>
      <link>https://morfikov.github.io/post/jak-zablokowac-facebook-youtube-openwrt/</link>
      <pubDate>Tue, 10 May 2016 22:17:38 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zablokowac-facebook-youtube-openwrt/</guid>
      <description>&lt;p&gt;Serwisy społecznościowe takie jak Facebook, Twitter czy YouTube coraz bardziej dają się we znaki
przedsiębiorcom, który muszą cały czas pilnować, by ich pracownicy nie siedzieli ciągle w
internecie, przynajmniej w czasie pracy. Problem nagminnego przebywania w tych w/w portalach można
bardzo łatwo rozwiązać przez... porozmawianie z pracownikami. No może nie zawsze ale co nam szkodzi
spróbować? W przypadku, gdy upomnienia nie są w stanie zmusić ludzi w naszej firmie do pracy, a nie
możemy przy tym ich zwolnić, to możemy pójść o krok dalej i spróbować im założyć blokadę na te
powyższe serwisy. Oczywiście blokada szeregu adresów IP nie wchodzi w rachubę. Korporacje typu
Facebook czy Google mają wiele adresów IP na których świadczą swoje usługi. Nie wszystkie z nich są
uwzględniane na różnego rodzaju listach. Niemniej jednak, tak na dobrą sprawę to nie musimy nawet
znać tych adresów. Jedyne czego nam potrzeba to nazwa domeny oraz kilka pakietów standardowo
dostępnych w repozytorium OpenWRT. Mowa o &lt;code&gt;iptables&lt;/code&gt; , &lt;code&gt;dnsmasq&lt;/code&gt; oraz &lt;code&gt;ipset&lt;/code&gt; . W OpenWRT, przy
pomocy tych narzędzi możemy zaprojektować filtr, który może zablokować ludziom z naszej sieci dostęp
do praktycznie każdego serwisu www. W tym artykule zobaczymy jak taki filtr skonstruować.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Filtr pakietów sieciowych w OpenWRT (firewall)</title>
      <link>https://morfikov.github.io/post/filtr-pakietow-sieciowych-w-openwrt-firewall/</link>
      <pubDate>Mon, 09 May 2016 23:26:58 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/filtr-pakietow-sieciowych-w-openwrt-firewall/</guid>
      <description>&lt;p&gt;Router wyposażony w firmware OpenWRT posiada wbudowany firewall, który ma za zadnie stać na straży
bezpieczeństwa naszej sieci domowej. Standardowo ta zapora przepuszcza cały ruch sieciowy z obszaru
LAN do WAN, czyli z sieci lokalnej do sieci naszego ISP. W ten sposób komputery znajdujące się w
naszej sieci mają dostęp do internetu i mogą z niego korzystać bez przeszkód. Niemniej jednak, ten
mechanizm nie działa tak samo w drugą stronę, czyli z WAN do LAN. Tutaj są już blokowane wszystkie
próby nawiązania nowych połączeń (&lt;a href=&#34;/post/kompromitacja-firewalla-openwrt-za-sprawa-ping/&#34;&gt;za wyjątkiem żądań
ping&lt;/a&gt;) ale nic nie stoi na
przeszkodzie, by zastosować przekierowanie portów. Dzięki takiemu rozwiązaniu możemy przekierować
ruch, który jest kierowany na dany port w routerze, do określonego hosta w sieci lokalnej. Wszystkie
te zadania realizowane są przez &lt;code&gt;iptables&lt;/code&gt; i w tym wpisie postaramy się ogarnąć to narzędzie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>NAT Reflection oraz NAT Loopback w OpenWRT</title>
      <link>https://morfikov.github.io/post/nat-reflection-oraz-nat-loopback-w-openwrt/</link>
      <pubDate>Mon, 09 May 2016 22:09:47 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/nat-reflection-oraz-nat-loopback-w-openwrt/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Network_address_translation#NAT_loopback&#34;&gt;Mechanizm NAT Loopback&lt;/a&gt;
nazywany też NAT Reflection lub NAT Hairpinning często jest pomijany przy omawianiu tematyki
firewall&#39;a. Chodzi generalnie o możliwość uzyskiwania dostępu do zasobów w sieci lokalnej po
adresie, który jest na zewnętrznym interfejsie sieciowym routera. W taki sposób mając dwa hosty w
sieci lokalnej, jeden z nich jest w stanie uzyskać dostęp do usług znajdujących się na drugim hoście
przez wykorzystanie zewnętrznego często też publicznego adresu IP. W tym wpisie przybliżymy sobie
zasadę działania tego mechanizmu.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kompromitacja firewall&#39;a OpenWRT za sprawą ping</title>
      <link>https://morfikov.github.io/post/kompromitacja-firewalla-openwrt-za-sprawa-ping/</link>
      <pubDate>Mon, 09 May 2016 15:40:47 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kompromitacja-firewalla-openwrt-za-sprawa-ping/</guid>
      <description>&lt;p&gt;Ten standardowy firewall, który oferuje OpenWRT, ma w zamiarze blokować wszystkie nowe próby
połączeń od strony WAN. Faktycznie tak jest w istocie. Niemniej jednak, mamy tam jedną regułę,
która zezwala na wysyłanie żądań &lt;code&gt;ping&lt;/code&gt; . Niby te żądania wydają się być niepozorne ale przy takiej
konfiguracji &lt;code&gt;iptables&lt;/code&gt; jaką oferuje OpenWRT istnieje ryzyko, że ktoś z zewnątrz może utworzyć sporo
sesji bez jakiegokolwiek nadzoru. Każda z tych sesji musi być śledzona przez kernel w tablicy
conntrack&#39;a. Nie mając kontroli nad tym ile takich sesji może zostać utworzonych, łatwo może dojść
do zapełnienia tej tablicy. Jeśli do tego dojdzie, to router przestanie nawiązywać nowe połączenia.
Przydałoby się zatem jakoś ten cały &lt;code&gt;ping&lt;/code&gt; ogarnąć i to niekoniecznie blokując go po stronie WAN. W
tym wpisie zaimplementujemy sobie mechanizm ochrony przez tego typu zagrożeniem.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja diod w routerze pod OpenWRT (LED)</title>
      <link>https://morfikov.github.io/post/konfiguracja-diod-w-routerze-pod-openwrt-led/</link>
      <pubDate>Sat, 30 Apr 2016 17:11:47 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-diod-w-routerze-pod-openwrt-led/</guid>
      <description>&lt;p&gt;Praktycznie każdy router posiada szereg diod LED, które wizualizują stan pracy takiego urządzenia. W
taki sposób jesteśmy w stanie stwierdzić czy sieć WiFi jest aktualnie włączona albo czy odbywa się
wymiana danych za jej pomocą. Podobnie możemy ocenić aktywność mechanizmu WPS oraz czy połączenie
przewodowe zostało ustanowione. Routery TP-LINK&#39;a mają także w standardzie diodę &lt;code&gt;system&lt;/code&gt; , która
informuje nas czy router działa prawidłowo i nie uległ powieszeniu. W OpenWRT wszystkie te wyżej
opisane właściwości można skonfigurować, tak by dioda LED reagowała w określony sposób na pewne
zaistniałe zdarzenie. W tym wpisie przyjrzymy się bliżej konfiguracji diod routera.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja interfejsów IFB w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/konfiguracja-interfejsow-ifb-w-linuxie/</link>
      <pubDate>Wed, 16 Dec 2015 14:46:50 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-interfejsow-ifb-w-linuxie/</guid>
      <description>&lt;p&gt;Ten wpis również będzie poświęcony tematyce
&lt;a href=&#34;http://linux-ip.net/articles/Traffic-Control-HOWTO/index.html&#34;&gt;kontroli&lt;/a&gt; i
&lt;a href=&#34;https://lukasz.bromirski.net/docs/translations/lartc-pl.html&#34;&gt;kształtowania&lt;/a&gt; ruchu sieciowego w
linux&#39;ie, z tym, że ograniczymy się tutaj do konfiguracji interfejsów IFB. Działają one na podobnej
zasadzie co &lt;a href=&#34;/post/konfiguracja-interfejsow-imq-w-linuxie/&#34;&gt;interfejsy IMQ&lt;/a&gt;.
Niewątpliwą zaletą interfejsów IFB jest fakt, że są one natywnie wspierane przez kernel linux&#39;a,
przez co ich obsługa jest dziecinnie prosta. Wadą jest z kolei to, że nie do końca damy radę
kształtować ruch przychodzący do naszej maszyny. Tak czy inaczej, postaramy się skonfigurować te
interfejsy i zobaczymy co z nich idzie wycisnąć.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kształtowanie ruchu sieciowego (Traffic Control)</title>
      <link>https://morfikov.github.io/post/ksztaltowanie-ruchu-sieciowego-traffic-control/</link>
      <pubDate>Tue, 15 Dec 2015 20:40:52 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ksztaltowanie-ruchu-sieciowego-traffic-control/</guid>
      <description>&lt;p&gt;Każdy z nas chciałby, aby jego sieć działała możliwie szybko i bezproblemowo. W przypadku, gdy łącze
nie jest zbytnio obciążone, a my jesteśmy jedynym użytkownikiem internetu, to nie doświadczymy
raczej żadnych problemów z połączeniem. Rzecz w tym, że im więcej użytkowników ma nasza sieć, tym
większe prawdopodobieństwo, że zostanie ona przeciążona, tj. będziemy chcieli przesyłać więcej
danych niż sieć jest w stanie obsłużyć. W ten sposób zaczną pojawiać się kolejki pakietów na
interfejsach, których obsługa zajmuje trochę czasu. Rosą zatem opóźnienia, które są bardzo
odczuwalne w momencie, gdy ktoś lubi sobie pograć w różnego rodzaju gry online. Innym problemem może
być sieć P2P, gdzie pojedynczy host z naszej sieci może nawiązywać dziesiątki czy nawet setki
połączeń i tym samym zapychać łącze nie dając szansy innym użytkownikom na komfortowe korzystanie
z internetu. W obu przypadkach może nam pomóc &lt;a href=&#34;http://lartc.org/lartc.html&#34;&gt;kształtowanie ruchu
sieciowego&lt;/a&gt; (Traffic Control), która jest w stanie nadać pakietom
odpowiedni priorytet, tak by część z nich nie musiała czekać zbyt długo w kolejce. W tym wpisie
przyjrzymy się bliżej temu mechanizmowi.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Konfiguracja interfejsów IMQ w linux&#39;ie</title>
      <link>https://morfikov.github.io/post/konfiguracja-interfejsow-imq-w-linuxie/</link>
      <pubDate>Tue, 15 Dec 2015 14:38:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/konfiguracja-interfejsow-imq-w-linuxie/</guid>
      <description>&lt;p&gt;W linux&#39;ie, kształtowanie przychodzącego ruchu sieciowego stwarza dość poważne problemy. Na dobrą
sprawę, obecnie w kernelu nie ma żadnego mechanizmu, który byłby w stanie to zadanie realizować.
Istnieją, co prawda, &lt;a href=&#34;https://wiki.linuxfoundation.org/networking/ifb&#34;&gt;interfejsy IFB&lt;/a&gt; ale za ich pomocą jesteśmy w stanie z powodzeniem
kształtować jedynie ruch wychodzący. W przypadku pakietów napływających, możemy jedynie ograniczyć
im przepustowość. W tym powyższym linku jest wzmianka, że te interfejsy IFB są następcą
&lt;a href=&#34;https://github.com/imq/linuximq/wiki/WhatIs&#34;&gt;interfejsów IMQ&lt;/a&gt;. Niemniej jednak, ten drugi projekt zdaje się działać, choć nie jest obecnie
wspierany przez kernel linux&#39;a. W tym wpisie postaramy się skonfigurować działające interfejsy IMQ,
tak, by za ich pomocą skutecznie kształtować ruch przychodzący.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Fwknop z obsługą kuczy GPG</title>
      <link>https://morfikov.github.io/post/fwknop-z-obsluga-kuczy-gpg/</link>
      <pubDate>Thu, 05 Nov 2015 20:52:20 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/fwknop-z-obsluga-kuczy-gpg/</guid>
      <description>&lt;p&gt;Ostatnio opisywałem jak zaimplementować na swoim serwerze &lt;a href=&#34;/post/port-knocking-i-single-packet-authorization/&#34;&gt;mechanizm port
knocking&#39;u&lt;/a&gt; , który oparty był
o &lt;a href=&#34;http://www.cipherdyne.org/fwknop/docs/fwknop-tutorial.html&#34;&gt;Single Packet Authorization&lt;/a&gt;. Tamten
wpis dotyczył głównie wykorzystania szyfrów symetrycznych ale istnieje też możliwość skorzystania z
kluczy GPG. W ten sposób uwierzytelnianie oraz szyfrowanie pakietów odbywałoby się przy ich pomocy.
W tym wpisie postaramy się tak skonfigurować narzędzie &lt;code&gt;fwknop&lt;/code&gt; , tak by było ono w stanie
przepuszczać jedynie tych klientów, którzy posługują się kluczami GPG.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
