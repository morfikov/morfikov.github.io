<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>szyfrowanie on Morfitronik</title>
    <link>https://morfikov.github.io/tags/szyfrowanie/</link>
    <description>Recent content in szyfrowanie on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Mon, 10 Aug 2020 18:15:00 +0000</lastBuildDate>
    
	<atom:link href="https://morfikov.github.io/tags/szyfrowanie/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Jak włączyć w Firefox ESNI (Encrypted SNI)</title>
      <link>https://morfikov.github.io/post/jak-wlaczyc-w-firefox-esni-encrypted-sni/</link>
      <pubDate>Mon, 10 Aug 2020 18:15:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wlaczyc-w-firefox-esni-encrypted-sni/</guid>
      <description>&lt;p&gt;Obecnie szyfrowanie zapytań DNS staje się powoli normą za sprawą protokołu DoH (&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_HTTPS&#34;&gt;DNS over HTTPS&lt;/a&gt;)
lub DoT (&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_TLS&#34;&gt;DNS over TLS&lt;/a&gt;). Można by zatem pomyśleć, że wraz z implementacją szyfrowania tego
kluczowego dla działania internetu protokołu (przynajmniej z naszego ludzkiego punktu widzenia),
poprawie ulegnie również nasza prywatność w kwestii odwiedzanych przez nas stron WWW. Niemniej
jednak, w dalszym ciągu można bez problemu wyciągnąć adresy domen, które zamierzamy odwiedzić. Nie
ma przy tym żadnego znaczenia ile stron jest hostowanych na danym adresie IP, ani nawet fakt, że
ruch do serwera WWW będzie szyfrowany (w pasku adresu wpiszemy &lt;code&gt;https://&lt;/code&gt; ) z wykorzystaniem
protokołu SSL/TLS (w tym również TLS v1.3). Wszystko przez rozszerzenie SNI (&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;Server Name
Indication&lt;/a&gt;), którego to zadaniem jest umożliwienie jednemu serwerowi na prezentowanie wielu
certyfikatów hostowanych w jego obrębie domen. Dzięki takiemu rozwiązaniu, każda domena może
szyfrować ruch niezależnie od siebie na linii serwer&amp;lt;-&amp;gt;klient (używać innych kluczy szyfrujących).
Niemniej jednak, podczas nawiązywania szyfrowanego połączenia, w pakiecie ClientHello przesyłanym
do takiego serwera musi znaleźć się nazwa domeny, której to certyfikat serwer będzie musiał nam
przedstawić. Niestety ten pakiet jest przesyłany przez sieć otwartym tekstem, przez co każdy, kto
podsłuchuje naszą komunikację (w tym też nasz ISP), bez problemu może ustalić na jakie strony
internetowe wchodzimy. Ostatnimi czasy jednak pojawiły się dwa rozszerzenia ECH (&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication#Encrypted_Client_Hello&#34;&gt;Encrypted Client
Hello&lt;/a&gt;) oraz ESNI (&lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-esni-07&#34;&gt;Encrypted SNI&lt;/a&gt;), które mają zaadresować problemy związane z prywatnością
przez pełne zaszyfrowanie pakietu ClientHello lub też zaszyfrowanie jedynie pola SNI w tym pakiecie.
Póki co, prace nad tymi rozszerzeniami nie są jeszcze skończone ale Firefox w połączeniu z
CloudFlare powoli testują ESNI. Postanowiłem zatem dobrowolnie przyłączyć się do grupy testerów i
wdrożyć na swoim linux&#39;ie to rozszerzenie ESNI dla przeglądarki Firefox.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kernel crash przy szyfrowaniu smartfona lub próbie resetu ustawień do fabrycznych</title>
      <link>https://morfikov.github.io/post/kernel-crash-przy-szyfrowaniu-smartfona-lub-probie-resetu-ustawien-do-fabrycznych/</link>
      <pubDate>Sat, 22 Sep 2018 11:13:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kernel-crash-przy-szyfrowaniu-smartfona-lub-probie-resetu-ustawien-do-fabrycznych/</guid>
      <description>&lt;p&gt;Parę dni temu dowiedziałem się o &lt;a href=&#34;https://e.foundation/&#34;&gt;projekcie /e/&lt;/a&gt;. Z racji, że ten ROM jest
dostępny na mój smartfon LG G4C (jeszcze nieoficjalnie), to postanowiłem go sobie wgrać i zobaczyć
jak się będzie sprawował. Podczas testów nowego oprogramowania spróbowałem zaszyfrować partycję
&lt;code&gt;/data/&lt;/code&gt; . Problem w tym, że po automatycznym zresetowaniu się systemu, urządzenie już nie chciało
się uruchomić. Przez dłuższy czas widniało logo LG, a po chwili pojawił się czarny ekran z
informacją &amp;quot;Kernel Crash&amp;quot; lub niebieski ekran z informacją &amp;quot;Subsystem Crash&amp;quot;. Czy telefon w takiej
sytuacji nadaje się jedynie do wyrzucenia?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zmiana domyślnego hasła szyfrującego klucz główny w Neffos X1 i X1 Max</title>
      <link>https://morfikov.github.io/post/zmiana-domyslnego-hasla-szyfrujacego-klucz-glowny-w-neffos-x1-i-x1-max/</link>
      <pubDate>Wed, 16 May 2018 17:17:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-domyslnego-hasla-szyfrujacego-klucz-glowny-w-neffos-x1-i-x1-max/</guid>
      <description>&lt;p&gt;Nie bawiłem się ostatnio Neffos&#39;ami ale w końcu udało mi się doprowadzić szyfrowanie w X1 Max (i
pewnie X1 też) do ładu. Dla przypomnienia, to w tych modelach najwyraźniej system zapomniał by
pytać użytkownika o hasło podczas konfiguracji, a że partycja z danymi użytkownikami jest
zaszyfrowana w standardzie (bez możliwości zmiany), to ustawiane jest domyślne hasło tj.
&lt;code&gt;default_password&lt;/code&gt; . W ten sposób z technicznego punktu widzenia wilk jest syty i owca cała,
no bo użytkownik nie jest dręczony dodatkowym hasłem przy uruchamianiu systemu (obok hasła blokady
ekranu), no i dane są zaszyfrowane, no chyba, że ktoś wpisze ten nieszczęsny
&lt;code&gt;default_password&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie rozmów i SMS&#39;ów na smartfonie z Androidem (Signal)</title>
      <link>https://morfikov.github.io/post/szyfrowanie-rozmow-i-smsow-na-smartfonie-z-androidem-signal/</link>
      <pubDate>Sun, 26 Mar 2017 18:35:14 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-rozmow-i-smsow-na-smartfonie-z-androidem-signal/</guid>
      <description>&lt;p&gt;Każdy z nas ma już raczej w swoim posiadaniu telefon, czy jego nieco bardziej zaawansowaną wersję
określaną mianem smartfona. Te urządzenia to w zasadzie przenośne i do tego bardzo małe komputery,
które umożliwiają nam komunikowanie się z osobami na całym świecie. Wykonywanie połączeń głosowych,
przesyłanie SMS&#39;ów/MMS&#39;ów czy też korzystanie z Internetu w naszych komórkach od dawna jest już
standardem i ciężko byłoby nam się obejść bez tej technologii obecnie. Problem w tym, że nasza
komunikacja jest narażona na podsłuch. W przypadku Internetu większość połączeń jest już szyfrowana
na linii dwóch klientów (E2E, End To End). Natomiast jeśli chodzi o telefony, to tutaj sprawa kuleje
i to bardzo poważnie, bo w zasadzie nasze połączenia głosowe czy SMS&#39;y są do wglądu dla każdych
służb, które z jakiegoś powodu uznają, że mogą naruszać naszą prywatność. Jedyna opcja, która jest
w stanie zabezpieczyć nas przed tego typu praktykami, to szyfrowanie rozmów. Tak się składa, że jest
kilka aplikacji na Androida, które są w stanie realizować tego typu przedsięwzięcie. Jedną z nich
jest darmowa i otwartoźródłowa aplikacja Signal, której się przyjrzymy nieco bliżej w tym artykule.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jak zmienić hasło do zaszyfrowanego smartfona z Androidem</title>
      <link>https://morfikov.github.io/post/jak-zmienic-haslo-do-zaszyfrowanego-smartfona-z-androidem/</link>
      <pubDate>Fri, 03 Mar 2017 17:58:36 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zmienic-haslo-do-zaszyfrowanego-smartfona-z-androidem/</guid>
      <description>&lt;p&gt;Każdy nowszy smartfon z Androidem oferuje możliwość zaszyfrowania wszystkich danych użytkownika
zlokalizowanych na partycji &lt;code&gt;/data/&lt;/code&gt; . Cały proces można przeprowadzić w bardzo prosty sposób i bez
większych problemów. Raz zaszyfrowanego telefonu nie da rady cofnąć do stadium przed szyfrowaniem i
w zasadzie to zabezpieczenie można zdjąć jedynie przez przywrócenie urządzenia do ustawień
fabrycznych. My tutaj jednak nie będziemy zajmować się samym szyfrowaniem smartfona i skupimy się
bardziej na hasłach zabezpieczających mających stać na straży dostępu do naszych cennych danych,
które mamy w telefonie. Większość z nas wykorzystuje krótkie hasło do odblokowania ekranu. To samo
hasło z kolei jest wykorzystywane do zaszyfrowania klucza używanego w procesie
szyfrowania/deszyfrowania danych na flash&#39;u smartfona. W ustawieniach Androida nie ma jednak opcji
rozdzielenia tych haseł i można by pomyśleć, że wykorzystanie czterocyfrowego kodu PIN jako
zabezpieczenie mija się z celem. Na pewno w części smartfonów tak ale niekoniecznie we wszystkich
modelach. Tak się składa, że akurat leży u mnie nieużywany Neffos Y5 od TP-LINK, to postanowiłem
przyjrzeć się nieco bliżej tej kwestii haseł i sprawdzić czy jest się czego obawiać stosując krótkie
hasła w zaszyfrowanych Androidach.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Problem z zaszyfrowaniem partycji /data/ na smartfonie z Androidem</title>
      <link>https://morfikov.github.io/post/problem-z-zaszyfrowaniem-partycji-data-na-smartfonie-z-androidem/</link>
      <pubDate>Sat, 11 Feb 2017 18:59:25 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/problem-z-zaszyfrowaniem-partycji-data-na-smartfonie-z-androidem/</guid>
      <description>&lt;p&gt;Bawiąc się ostatnio trochę mechanizmami szyfrującymi w moich smartfonach Neffos podesłanych przez
TP-LINK, po raz kolejny coś nieopatrznie uszkodziłem. Tym razem sprawa wygląda nieco bardziej
poważnie, bo uwalony został cały moduł szyfrujący urządzenie. Chodzi generalnie o to, że w
Androidzie w wersji 4.4/5.0 została wprowadzona &lt;a href=&#34;https://source.android.com/security/encryption/full-disk&#34;&gt;możliwość zaszyfrowania wszystkich danych
użytkownika&lt;/a&gt;, tj. informacji
przechowywanych na partycji &lt;code&gt;/data/&lt;/code&gt; . Do odszyfrowania tej partycji potrzebny jest klucz
szyfrujący. Problem w tym, że Android musi gdzieś ten klucz trzymać i to w taki sposób, by proces
Factory Reset był w stanie ten klucz usunąć, choćby na wypadek zapomnienia hasła i próby odzyskania
w takiej sytuacji władzy nad smartfonem. Pech chciał, że akurat na moim Neffos Y5 mam wgrane TWRP
recovery i z jakiegoś powodu nie mogłem zresetować ustawień telefonu do fabrycznych przez ten tryb i
posłużyłem się narzędziem &lt;code&gt;fastboot&lt;/code&gt; . Ono najwyraźniej nieco inaczej formatuje partycję &lt;code&gt;/data/&lt;/code&gt; i
w ten sposób uwala cały mechanizm szyfrowania oferowany przez Androida. Czy da radę jakoś poprawić
ten problem, a jeśli tak to w jaki sposób?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Jak ukryć zaszyfrowany kontener LUKS pod linux</title>
      <link>https://morfikov.github.io/post/jak-ukryc-zaszyfrowany-kontener-luks-pod-linux/</link>
      <pubDate>Tue, 25 Oct 2016 19:30:23 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-zaszyfrowany-kontener-luks-pod-linux/</guid>
      <description>&lt;p&gt;Gdy w grę wchodzi poufność informacji, to przeciętny użytkownik komputera od razu zaczyna rozważać
szyfrowanie danych. Są różne narzędzia, które te kwestię realizują w mniejszym lub większym stopniu.
Kiedyś wszyscy korzystali z &lt;a href=&#34;http://truecrypt.sourceforge.net/&#34;&gt;TrueCrypt&lt;/a&gt; ale po jego dziwnych
przygodach ludzie stopniowo zaczęli od tego oprogramowania odchodzić. W jego miejscu zaczęły
pojawiać się różne forki, np. &lt;a href=&#34;https://veracrypt.codeplex.com/&#34;&gt;VeraCrypt&lt;/a&gt;. Abstrahując od tych ww.
narzędzi, w każdym linux&#39;ie mamy również dostępny &lt;a href=&#34;https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions&#34;&gt;mechanizm szyfrujący na bazie
LUKS&lt;/a&gt; i jego gołą wersję
wykorzystującą dm-crypt. Przy pomocy każdego z tych narzędzi jesteśmy w stanie zaszyfrować dysk
komputera, pendrive, czy nawet kartę SD, w taki sposób, by nikt inny nie uzyskał dostępu do danych
zgromadzonych na tych nośnikach informacji. Problem w tym, że w dalszym ciągu ktoś może nas
torturować, by wydobyć od nas hasło czy keyfile i uzyskać dostęp do tych zaszyfrowanych danych bez
większego trudu. Dlatego też pojawiło się coś nazwanego &lt;a href=&#34;https://en.wikipedia.org/wiki/Plausible_deniability&#34;&gt;Plausible
Deniability&lt;/a&gt;, gdzie wykorzystywane są tak
naprawdę dwa nośniki z czego jeden robi za przykrywkę, a na drugim mamy zgromadzone poufne pliki. W
ten sposób agresorowi podajemy hasło do trefnego kontenera i wszyscy są zadowoleni. Czy aby na
pewno?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie logów w OpenWRT (syslog-ng)</title>
      <link>https://morfikov.github.io/post/szyfrowanie-logow-w-openwrt-syslog-ng/</link>
      <pubDate>Fri, 29 Apr 2016 02:36:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-logow-w-openwrt-syslog-ng/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io
/post/logread-czyli-system-logowania-w-openwrt/&#34;&gt;We wpisie dotyczącym logread&lt;/a&gt;
została podniesiona kwestia przesłania logów przez sieć. OpenWRT jest w stanie tego typu zadanie
realizować po określeniu kilku dodatkowych opcji w pliku &lt;code&gt;/etc/config/system&lt;/code&gt; . Trzeba jednak zdawać
sobie sprawę, że tak przesyłane komunikaty nie będą w żaden sposób zabezpieczone. W sieci domowej
raczej nie musimy sobie zawracać głowy tym mankamentem. Niemniej jednak, gdy w grę wchodzi
przesyłanie logów do zdalnego serwera zlokalizowanego gdzieś w internecie, to taką komunikację
należy zabezpieczyć przed podsłuchem. Niestety OpenWRT standardowo nie wspiera takich udziwnień ale
dysponuje on pakietami, które mogą nam zapewnić taką funkcjonalność. Szyfrowanie logów możemy w
łatwy sposób wdrożyć za pomocą pakietu &lt;code&gt;syslog-ng3&lt;/code&gt; . W nim znajduje się demon &lt;code&gt;syslog-ng&lt;/code&gt; , który
jest kompatybilny w pełni z innymi linux&#39;owymi demonami logowania. Nie powinno zatem być problemów
ze skonfigurowaniem tego całego mechanizmu.&lt;/p&gt;
&lt;p&gt;W OpenWRT w wersji Chaos Calmer nie ma pakietu &lt;code&gt;syslog-ng3&lt;/code&gt; . W efekcie szyfrowanie logów routera
nie jest obecnie możliwe. Ten wpis dotyczy jedynie wydania Barrier Breaker i zostanie zaktualizowany
jak tylko wspomniany pakiet trafi do repozytorium.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Klucze szyfrujące RSA w OpenWRT (ssh)</title>
      <link>https://morfikov.github.io/post/klucze-szyfrujace-rsa-w-openwrt-ssh/</link>
      <pubDate>Sun, 24 Apr 2016 01:14:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/klucze-szyfrujace-rsa-w-openwrt-ssh/</guid>
      <description>&lt;p&gt;Klucze RSA w protokole SSH mogą być wykorzystane jako sposób identyfikacji danej osoby przy
logowaniu się do zdalnego serwera. Te klucze zawsze występują w parach. Jeden prywatny, drugi
publiczny. Pierwszy z nich jest znany tylko nam i powinien być trzymany w sekrecie i pilnie
strzeżony. Klucz publiczny z kolei zaś jest przesyłany na każdy serwer SSH, z którym chcemy się
połączyć. Gdy serwer jest w posiadaniu naszego klucza publicznego i widzi przy tym, że próbujemy
nawiązać połączenie, używa on tego klucza, by wysłać do nas zapytanie (challange). Jest ono
zakodowane i musi na nie zostać udzielona prawidłowa odpowiedź. Tej z kolei może udzielić ktoś, kto
jest w posiadaniu klucza prywatnego. Nie ma innej opcji, by rozkodować wiadomość. Dlatego też nikt
inny nie może udzielić na nią prawidłowej odpowiedzi. To rozwiązanie eliminuje wrażliwość na różne
formy podsłuchu. Ten kto nasłuchuje nie będzie w stanie przechwycić pakietów zawierających hasło, bo
ono nie jest nigdy transmitowane prze sieć. No i oczywiście jeśli chodzi o samo hasło, to odpadają
nam ataki bruteforce pod kątem jego złamania. W tym wpisie postaramy się zaimplementować na routerze
z OpenWrt system logowania oparty o klucze RSA.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Nagłówek kontenera LUKS trzymany na pendrive</title>
      <link>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</link>
      <pubDate>Fri, 15 Jan 2016 20:28:24 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</guid>
      <description>&lt;p&gt;Jeśli kiedyś rozważaliśmy &lt;a href=&#34;https://morfikov.github.io
/post/keyfile-trzymany-w-glebokim-ukryciu/&#34;&gt;umieszczenie pliku klucza (keyfile) do zaszyfrowanego kontenera LUKS na
pendrive&lt;/a&gt;, to ciekawszą alternatywą
może okazać się umieszczenie całego nagłówka takiego kontenera na zewnętrznym nośniku. Ma to tę
przewagę nad keyfile, że wszystkie informacje zapewniające dostęp do kontenera, wliczając w to klucz
główny, są oddzielone od zaszyfrowanych danych. W ten sposób nawet jeśli kontener wpadnie w
niepowołane ręce, to nie ma żadnego sposobu na to, by ten ktoś te dane odzyskał, no bo przecie nie
ma klucza szyfrującego. Przechwycenie hasła również nic to nie zmieni, no chyba, że ten ktoś
zdobędzie również pendrive z nagłówkiem kontenera. Z ludzkiego punktu widzenia, to na takim dysku
będą znajdować się jedynie losowymi dane i do tego w formie kompletnie nieczytelnej dla człowieka
(brak systemu plików). Niemniej jednak, jest kilka rzeczy, o których warto pamiętać, gdy w grę
wchodzi nagłówek LUKS i to o nich porozmawiamy sobie w tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Klucz główny kontenera LUKS i jego odzyskanie</title>
      <link>https://morfikov.github.io/post/odzyskanie-klucza-glownego-w-kontenerze-luks/</link>
      <pubDate>Fri, 15 Jan 2016 16:25:39 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/odzyskanie-klucza-glownego-w-kontenerze-luks/</guid>
      <description>&lt;p&gt;Kontenery LUKS to takie wynalazki, za których pomocą jesteśmy w stanie zaszyfrować całe dyski
twarde, a właściwie to znajdujące się na nich dane. Taki kontener składa się głównie z nagłówka,
który jest umieszczany na początku partycji. By być w stanie dokonać szyfrowania i deszyfrowania
informacji w locie, system musi posiadać klucz główny (master key). Ten klucz jest przechowywany w
nagłówku i by go wydobyć, musimy wprowadzić jedno z haseł do kontenera. Później klucz wędruje do
pamięci, a hasło jest z niej usuwane. W ten sposób system ma dostęp do klucza głównego przez cały
czas począwszy od chwili otwarcia kontenera, aż do momentu jego zamknięcia. &lt;a href=&#34;https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions&#34;&gt;Ten klucz jesteśmy w
stanie bez większego problemu
wydobyć&lt;/a&gt;, co może być
bardzo przydatne na wypadek zapomnienia hasła, czy też uszkodzenia samego nagłówka. W tym wpisie
postaramy się odzyskać klucz główny zaszyfrowanego kontenera LUKS.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Odszyfrowanie kontenerów LUKS w systemd</title>
      <link>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</link>
      <pubDate>Fri, 01 Jan 2016 17:18:03 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/odszyfrowanie-kontenerow-luks-w-systemd/</guid>
      <description>&lt;p&gt;Osoby, które wykorzystują pełne szyfrowanie dysku, wiedzą, że nie zawsze da radę tak skonfigurować
swój system, by upchnąć go na jednej partycji. Nawet jeśli korzystamy z LVM wewnątrz kontenera LUKS,
to i tak zwykle możemy posiadać inne zaszyfrowane partycje, które są odrębną całością i montowane
osobno przy starcie systemu. W takim przypadku zwykle jesteśmy zmuszeni do podawania hasła do
każdego z tych dysków z osobna, co zajmuje czas. Ten problem opisałem po części przy okazji
&lt;a href=&#34;https://morfikov.github.io
/post/dropbox-i-kontener-luks/&#34;&gt;implementacji kontenera LUKS na potrzeby
Dropbox&#39;a&lt;/a&gt;, jak i we wpisie poświęconym &lt;a href=&#34;https://morfikov.github.io
/post/przejscie-z-truecrypt-na-luks/&#34;&gt;przejściu
z kontenerów TrueCrypt&#39;a na te linux&#39;owe, które są wspierane natywnie przez sam
kernel&lt;/a&gt;. Niemniej jednak, tamto rozwiązanie
było oparte głównie o starszy init (sysvinit), co wymagało dodatkowej konfiguracji, tak by system
otworzył się po podaniu tylko jednego hasła. W tym wpisie postaramy się wdrożyć mechanizm, który
jest oferowany przez systemd.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie dźwięku przesyłanego przez sieć</title>
      <link>https://morfikov.github.io/post/szyfrowanie-dzwieku-przesylanego-przez-siec/</link>
      <pubDate>Sun, 01 Nov 2015 00:31:48 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-dzwieku-przesylanego-przez-siec/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.freedesktop.org/wiki/Software/PulseAudio/&#34;&gt;PulseAudio to serwer dźwięku&lt;/a&gt;, który jest w
stanie otrzymywać zapytania ze zdalnych lokalizacji. Wobec czego, możemy realizować &lt;a href=&#34;https://morfikov.github.io
/post/pulseaudio-i-przesylanie-dzwieku-przez-siec/&#34;&gt;przesyłanie
dźwięku przez sieć&lt;/a&gt; i usłyszeć
go tam, gdzie go sobie życzymy. Problem w tym, że taki dźwięk jest przesyłany przez sieć w formie
niezaszyfrowanej. Dlatego też jesteśmy narażeni na podsłuchanie wszystkiego co mówimy do mikrofonu
lub też tego co pojawia się w naszych głośnikach. Możemy jednak zabezpieczyć komunikację między
klientem i serwerem dźwięku wykorzystując do tego połączenie SSH. W ten sposób cały sygnał
dźwiękowy, jaki jest generowany przez danego hosta w sieci, zostanie wrzucony w szyfrowany kanał
TLS i nikt nie będzie w stanie go zinterpretować. Ten wpis ma na celu przedstawienie sposobu na
zaszyfrowanie dźwięku, bez którego większość z nas nie wyobraża sobie pacy przy komputerze.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie ruchu do Xserver&#39;a przy pomocy SSH</title>
      <link>https://morfikov.github.io/post/szyfrowanie-ruchu-do-xservera-przy-pomocy-ssh/</link>
      <pubDate>Sat, 31 Oct 2015 16:47:10 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-ruchu-do-xservera-przy-pomocy-ssh/</guid>
      <description>&lt;p&gt;W przypadku zaufanych sieci lokalnych, czy też &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-kontenerow-lxc/&#34;&gt;kontenerów
LXC&lt;/a&gt;, nie musimy zbytnio się troszczyć o
bezpieczeństwo przesyłanych danych. Nikt nam przecież nie założy tutaj podsłuchu. Dlatego też we
wpisie poświęconym konfiguracji Wine nie szyfrowaliśmy praktycznie żadnego ruchu sieciowego. Gdyby
jednak zaszła potrzeba przesłania pakietów do zdalnego Xserver&#39;a przez internet, to takie
rozwiązanie naraziłoby nas na przechwycenie wszystkich danych. By zabezpieczyć się przed tego typu
scenariuszem możemy zaszyfrować ruch do Xserver&#39;a &lt;a href=&#34;https://help.ubuntu.com/community/SSH/OpenSSH/PortForwarding&#34;&gt;forward&#39;ując wszystkie zapytania przy pomocy
szyfrowanego tunelu TLS&lt;/a&gt;. Możemy to
zrobić przy pomocy SSH i w tym wpisie postaramy się skonfigurować ten mechanizm.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Reinstalacja kernela i bootloader&#39;a</title>
      <link>https://morfikov.github.io/post/reinstalacja-kernela-bootloadera/</link>
      <pubDate>Thu, 22 Oct 2015 18:41:06 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/reinstalacja-kernela-bootloadera/</guid>
      <description>&lt;p&gt;Wykorzystywanie pełnego szyfrowania dysku twardego ma jedną zasadniczą wadę. O ile nasze dane są
należycie zabezpieczone, o tyle trzeba zwracać uwagę na to komu zezwalamy na dostęp do naszego
komputera. Nie chodzi tutaj o to, kto będzie używał samego systemu operacyjnego, choć to też jest
ważne, ale przede wszystkim chodzi o te osoby, które mają dostęp fizyczny do naszej maszyny. Czasem
możemy nabrać podejrzenia, że ktoś mógł nam jakąś pluskwę podłożyć. Wykrycie takiego robala, np. w
postaci sprzętowego keylogger&#39;a, nie powinno sprawić problemów. Z kolei już manipulacja boot
sektorem dysku twardego, lub też zmiany w initramfs, który znajduje się na niezaszyfrowanej partycji
&lt;code&gt;/boot/&lt;/code&gt; mogą przejść niezauważone. Jak zatem odratować system, co do którego mamy jakieś
zastrzeżenia?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Dropbox i kontener LUKS</title>
      <link>https://morfikov.github.io/post/dropbox-i-kontener-luks/</link>
      <pubDate>Wed, 21 Oct 2015 20:34:42 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dropbox-i-kontener-luks/</guid>
      <description>&lt;p&gt;Ogarnęliśmy już szyfrowanie plików na dropbox&#39;ie przy pomocy
&lt;a href=&#34;https://morfikov.github.io
/post/implementacja-encfs-na-dropboxie/&#34;&gt;encfs&lt;/a&gt; oraz &lt;a href=&#34;https://morfikov.github.io
/post/kontener-truecrypt-trzymany-na-dropboxie/&#34;&gt;kontenerów
TrueCrypt&lt;/a&gt;. Każda z w/w operacji
drastycznie poprawiła prywatność naszych plików, które przechowujemy w chmurze. Poniższy wpis będzie
w podobnym klimacie, tj. spróbujemy umieścić na dropbox&#39;ie &lt;a href=&#34;https://pl.wikipedia.org/wiki/Linux_Unified_Key_Setup&#34;&gt;kontener
LUKS&lt;/a&gt;, co niesie ze sobą sporo udogodnień i
czyni korzystanie z zaszyfrowanego dropbox&#39;a praktycznie transparentnym.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Kontener TrueCrypt trzymany na dropbox&#39;ie</title>
      <link>https://morfikov.github.io/post/kontener-truecrypt-trzymany-na-dropboxie/</link>
      <pubDate>Tue, 20 Oct 2015 18:27:46 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/kontener-truecrypt-trzymany-na-dropboxie/</guid>
      <description>&lt;p&gt;Żyjemy w czasach, w których mobilność jest tak samo ważna albo może i ważniejsza (dla niektórych
ludzi na pewno) jak i bezpieczeństwo i poufność danych. Użyteczność zwykle nie idzie w patrze z
bezpieczeństwem, bo im prostszy jest dla nas dostęp do danych, tym bardziej zagraża ich
bezpieczeństwu. W tym przypadku chcielibyśmy mieć możliwość dostępu do plików, np. naszego domowego
PC, z dowolnego miejsca na ziemi. Czy można w prosty i w miarę bezpieczny sposób coś takiego
osiągnąć? &lt;a href=&#34;https://morfikov.github.io
/post/implementacja-encfs-na-dropboxie/&#34;&gt;Jakiś czas temu opisywałem implementację encfs na
dropbox&#39;ie&lt;/a&gt;, w tym artykule zostanie zaś
opisane sprzęgnięcie dropbox&#39;a z kontenerem TrueCrypt.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Przejście z Truecrypt na LUKS</title>
      <link>https://morfikov.github.io/post/przejscie-z-truecrypt-na-luks/</link>
      <pubDate>Tue, 20 Oct 2015 09:58:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/przejscie-z-truecrypt-na-luks/</guid>
      <description>&lt;p&gt;Jakiś czas temu, można było usłyszeć, że TrueCrypt nie dba wcale o bezpieczeństwo danych
zaszyfrowanych za jego pomocą. &lt;a href=&#34;http://istruecryptauditedyet.com/&#34;&gt;Audyt bezpieczeństwa&lt;/a&gt; jednak nie
wykazał większych podatności w tym oprogramowaniu. &lt;a href=&#34;https://madiba.encs.concordia.ca/~x_decarn/truecrypt-binaries-analysis/&#34;&gt;Analiza
binarek&lt;/a&gt; dostępnych na
stronie TrueCrypt&#39;a pod kątem &lt;a href=&#34;https://wiki.debian.org/ReproducibleBuilds&#34;&gt;Reproducible Builds&lt;/a&gt;
również nie wykazała większych odchyłów w stosunku do binarek generowanych prosto z kodu
źródłowego. Problematyczne może być jednak to, że tak naprawdę nie wiadomo kto stoi za tym całym
projektem, przynajmniej gdy był jeszcze rozwijany. Cała sytuacja zamknięcia TrueCrypt&#39;a z sieci była
też co najmniej dziwna. W obliczu takich niewiadomych, powinniśmy rozważyć przejście na natywne
rozwiązania linux&#39;owe, które są jawnie rozwijane, wiadomo kto za nimi stoi i, co najważniejsze, mają
wsparcie w samym kernelu.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Implementacja encfs na dropbox&#39;ie</title>
      <link>https://morfikov.github.io/post/implementacja-encfs-na-dropboxie/</link>
      <pubDate>Mon, 19 Oct 2015 23:11:22 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/implementacja-encfs-na-dropboxie/</guid>
      <description>&lt;p&gt;Jako, że ostatnio &lt;a href=&#34;https://morfikov.github.io
/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/&#34;&gt;zaszyfrowaliśmy katalog domowy przy pomocy
encfs&lt;/a&gt; , to nie sposób sobie
nie zadać pytania czy tego typu mechanizm może działać w oparciu o serwisy online takie jak, np.
&lt;a href=&#34;https://www.dropbox.com/&#34;&gt;dropbox&lt;/a&gt;. Chodzi o to, że dropbox umożliwia synchronizację plików w
czasie rzeczywistym, co może być problematyczne, gdy w grę wchodzi szyfrowanie danych. Wszelkie inne
rozwiązania na bazie &lt;a href=&#34;https://pl.wikipedia.org/wiki/Linux_Unified_Key_Setup&#34;&gt;LUKS&lt;/a&gt; są mało
praktyczne w tym przypadku. Natomiast synchronizowanie pojedynczych plików zaszyfrowanych przy
pomocy &lt;code&gt;encfs&lt;/code&gt; zapowiada się obiecująco.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zaszyfrowana przestrzeń wymiany SWAP</title>
      <link>https://morfikov.github.io/post/zaszyfrowana-przestrzen-wymiany-swap/</link>
      <pubDate>Mon, 19 Oct 2015 22:32:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zaszyfrowana-przestrzen-wymiany-swap/</guid>
      <description>&lt;p&gt;Opisując mechanizm szyfrowania katalogu domowego przy pomocy &lt;a href=&#34;https://morfikov.github.io
/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/&#34;&gt;narzędzia
encfs&lt;/a&gt; , wspomniałem o
problemie jaki powstaje przy jednoczesnym braku szyfrowania przestrzeni wymiany SWAP. Oczywiście,
jeśli posiadamy w systemie dużą ilość pamięci RAM, to raczej nie potrzebna nam jest przestrzeń
wymiany. Podobnie sprawa ma się w przypadku, gdy nie korzystamy z hibernacji. Natomiast, jeśli jedna
z naszych partycji jest sformatowana jako SWAP i aktywnie z niej korzystamy, to niepełne szyfrowanie
dysku, jakie zapewnia &lt;code&gt;encfs&lt;/code&gt; może doprowadzić do skompromitowania zaszyfrowanych danych.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie katalogu /home/ przy pomocy encfs</title>
      <link>https://morfikov.github.io/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/</link>
      <pubDate>Mon, 19 Oct 2015 21:54:02 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-katalogu-home-przy-pomocy-encfs/</guid>
      <description>&lt;p&gt;Wielu ludzi uważa, że szyfrowanie całego dysku jest zbędne i pozbawione większego sensu, no bo
przecie &amp;quot;system nie zawiera żadnych wrażliwych danych, które by wymagały szyfrowania&amp;quot;. Nie będę się
tutaj spierał co do tego punktu widzenia, bo raczej wszyscy znają moje zdanie na temat &amp;quot;danych
wymagających szyfrowania&amp;quot; i skupię się tu raczej na tym jak troszeczkę podratować niepełne
szyfrowanie, które ludzie, nie wiedząc czemu, są bardziej skłonni stosować, niż cały ten full disk
encryption.&lt;/p&gt;
&lt;p&gt;Narzędzie &lt;code&gt;encfs&lt;/code&gt; nie przeszło pomyślnie &lt;a href=&#34;https://defuse.ca/audits/encfs.htm&#34;&gt;audytu bezpieczeństwa&lt;/a&gt;
, a to z takiego powodu, że projekt nie był rozwijany przez szereg lat. &lt;a href=&#34;https://github.com/vgough/encfs&#34;&gt;Obecnie jest on w rekach
społeczności&lt;/a&gt; i to od niej będzie zależeć czy te wykryte błędy
zostaną poprawione.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Serwer kluczy GPG i kwestia prywatności</title>
      <link>https://morfikov.github.io/post/serwer-kluczy-gpg-i-kwestia-prywatnosci/</link>
      <pubDate>Fri, 16 Oct 2015 18:59:04 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/serwer-kluczy-gpg-i-kwestia-prywatnosci/</guid>
      <description>&lt;p&gt;Czytając sobie artykuł na temat &lt;a href=&#34;https://trac.torproject.org/projects/tor/wiki/doc/TorifyHOWTO/GnuPG&#34;&gt;TORyfikacji zapytań do serwerów kluczy
GPG&lt;/a&gt;, pomyślałem, że w sumie
mógłbym zreprodukować przedstawione tam kroki dotyczące implementacji tego rozwiązania na windowsie
i wdrożyć je na linux&#39;ie. Chodzi generalnie o to, by serwer kluczy GPG nie był odpytywany
bezpośrednio przy szukaniu/przesyłaniu kluczy przez sieć, bo to może identyfikować nas, jak i grupę
ludzi, która się z nami komunikuje. Jakby nie patrzeć, klucze GPG składają się z dość newralgicznych
informacji, typu imię, nazwisko czy adres email, a serwer kluczy GPG tych danych w żaden sposób nie
zabezpiecza i są one zwykle przesyłane otwartym tekstem przez sieć.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>WPA/WPA2 Enterprise i serwer freeradius</title>
      <link>https://morfikov.github.io/post/wpa2-enterprise-serwer-freeradius/</link>
      <pubDate>Tue, 13 Oct 2015 18:42:28 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/wpa2-enterprise-serwer-freeradius/</guid>
      <description>&lt;p&gt;Poniższy wpis ma na celu stworzenie infrastruktury WiFi w oparciu o oprogramowanie freeradius
zainstalowane na debianowym serwerze. Projekt zakłada wykorzystanie osobnego urządzenia NAS (AP), w
tym przypadku jest to router &lt;a href=&#34;http://wiki.openwrt.org/toh/tp-link/tl-wr1043nd&#34;&gt;TP-Link TL-WR1043N/ND
v2&lt;/a&gt;, na którym jest zainstalowane oprogramowanie
OpenWRT. W oparciu o te dwie maszyny spróbujemy skonfigurować protokół WPA2 Enterprise z obsługą
trzech metod uwierzytelniania, tj. EAP-TLS, EAP-TTLS oraz PEAP (v0) . Będziemy również potrzebować
kilku certyfikatów (w tym CA), bez których to pewne mechanizmy mogą nie działać.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generowanie certyfikatów przy pomocy easy-rsa</title>
      <link>https://morfikov.github.io/post/generowanie-certyfikatow-przy-pomocy-easy-rsa/</link>
      <pubDate>Thu, 08 Oct 2015 14:29:34 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/generowanie-certyfikatow-przy-pomocy-easy-rsa/</guid>
      <description>&lt;p&gt;Jakiś czas temu przedstawiłem &lt;a href=&#34;https://morfikov.github.io
/post/generowanie-certyfikatow/&#34;&gt;manualny sposób na generowanie
certyfikatów&lt;/a&gt;, które można z powodzeniem
wykorzystać przy ssl, openvpn czy freeradius. Nie było tego znowu aż tak dużo ale jakby nie patrzeć
trochę parametrów trzeba znać, a najlepiej mieć przygotowane odpowiednie linijki, by sam proces
generowania certyfikatów przebiegł dość sprawnie. Jednak wychodzi na to, że nie trzeba się znowu aż
tak wysilać, bo istnieją dedykowane narzędzia, które wygenerują nam wszystkie potrzebne pliki. Mowa
o &lt;code&gt;easy-rsa&lt;/code&gt; i to niego będzie dotyczył ten wpis.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Zaszyfrowane logi w rsyslog i syslog-ng</title>
      <link>https://morfikov.github.io/post/zaszyfrowane-logi-w-rsyslog-i-syslog-ng/</link>
      <pubDate>Thu, 08 Oct 2015 13:53:38 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/zaszyfrowane-logi-w-rsyslog-i-syslog-ng/</guid>
      <description>&lt;p&gt;Jakiś czas temu, na forum DUG&#39;a wyczytałem coś o przesyłaniu logów systemowych przez sieć. W sumie,
to nigdy mi to do głowy nie przyszło ale jeśli by się nad tym głębiej zastanowić, tego typu
mechanizm może okazać się całkiem użyteczny. Na dobrą sprawę nie wiem jak to jest rozwiązane w
debianie opartym o systemd, natomiast jeśli chodzi o inne init&#39;y (openrc i sysvinit), to tego typu
funkcjonalność można zaimplementować wykorzystując narzędzie &lt;code&gt;rsyslog&lt;/code&gt; lub &lt;code&gt;syslog-ng&lt;/code&gt; . W tym
wpisie zostanie opisana konfiguracja debianowego serwera, na którym będzie nasłuchiwał daemon
&lt;code&gt;rsyslog&lt;/code&gt; . Dodatkowo, zostanie przedstawiona konfiguracja dwóch klientów, z których jeden będzie
miał zainstalowanego &lt;code&gt;syslog-ng&lt;/code&gt; , a drugi &lt;code&gt;rsyslog&lt;/code&gt; . Z klientów logi zostaną przesłane do serwera.
Dodatkowo, postaramy się &lt;a href=&#34;http://www.rsyslog.com/doc/v8-stable/tutorials/tls_cert_summary.html&#34;&gt;zaszyfrować ruch przy pomocy kanału
TLS&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Generowanie certyfikatów</title>
      <link>https://morfikov.github.io/post/generowanie-certyfikatow/</link>
      <pubDate>Sun, 04 Oct 2015 18:11:50 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/generowanie-certyfikatow/</guid>
      <description>&lt;p&gt;Certyfikaty mogą zostać wykorzystane wszędzie tam, gdzie mamy do czynienia z protokołami
szyfrującymi ruch. Zwykle są to serwisy hostujące strony www ale też mogą to być i inne usługi, np.
OpenVPN. Można je także spotkać w sieciach bezprzewodowych gdzie wykorzystywany jest protokół
WPA2-Enterprise. Jeśli operujemy na linux&#39;ie, to prawdopodobnie spotkaliśmy się już z
oprogramowaniem, które wykorzystuje certyfikaty, np. serwer &lt;code&gt;apache2&lt;/code&gt; . Dobrze jest sobie zatem
przyswoić wiedzę na temat generowania certyfikatów.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>ECryptfs jako alternatywa dla encfs</title>
      <link>https://morfikov.github.io/post/ecryptfs-jako-alternatywa-dla-encfs/</link>
      <pubDate>Mon, 22 Jun 2015 18:58:18 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/ecryptfs-jako-alternatywa-dla-encfs/</guid>
      <description>&lt;p&gt;Dnia 2014-10-07 w Debianie była aktualizacja pakietu &lt;code&gt;encfs&lt;/code&gt; , która to zawierała informację na
temat &lt;a href=&#34;https://defuse.ca/audits/encfs.htm&#34;&gt;audytu bezpieczeństwa&lt;/a&gt; jaki się dokonał parę miesięcy wstecz. Wyniki niezbyt dobrze
wypadły, a nawet można powiedzieć, że wręcz katastrofalnie. Generalnie cały test został skwitowany
słowami, że jeśli szyfrujemy pliki przy pomocy tego narzędzia, to jesteśmy relatywnie bezpieczni,
nawet w przypadku jeśli ktoś te pliki przechwyci. Natomiast jeśli zaczniemy zmieniać/dodawać pliki
i ten ktoś ponownie przechwyci nasz zaszyfrowany katalog, wtedy może on bez problemu odszyfrować
całą jego zawartość. Jeśli wykorzystujemy &lt;code&gt;encfs&lt;/code&gt; lokalnie, to być może nam nic nie grozi, nawet w
przypadku raidu NSA na naszą chałupę. Problem w tym, że ogromna rzesza ludzi wykorzystuje &lt;code&gt;encfs&lt;/code&gt;
do zaszyfrowania plików w chmurze, np. na Dropbox&#39;ie czy MEGA, a jak wiadomo, przy każdej
synchronizacji, zmiany w danym katalogu są przesyłane do chmury i wszelkie zabezpieczenie jakie
daje &lt;code&gt;encfs&lt;/code&gt; diabli biorą. Może najwyższy czas zainteresować się &lt;code&gt;ecryptfs&lt;/code&gt;?&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Riseup VPN na straży prywatności</title>
      <link>https://morfikov.github.io/post/riseup-vpn-na-strazy-prywatnosci/</link>
      <pubDate>Sun, 21 Jun 2015 17:05:45 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/riseup-vpn-na-strazy-prywatnosci/</guid>
      <description>&lt;p&gt;W dobie NSA, podsłuchów rządowych i wszelkiego rodzaju pogwałcenia prawa do prywatności, ludzie
wymyślili &lt;a href=&#34;https://pl.wikipedia.org/wiki/Virtual_Private_Network&#34;&gt;VPN&lt;/a&gt;. VPN to nic innego jak tunel
łączący dwie odległe od siebie maszyny, które chcą wymieniać ze sobą dane w sposób uniemożliwiający
osobom trzecim podejrzenie całej tej komunikacji. Zalety korzystania z takiego dobrodziejstwa natury
są oczywiste. Można obejść cenzorów, gdyż cały ruch z naszej maszyny jest przesyłany do serwera w
postaci szyfrowanej, a dopiero z tego serwera sygnał idzie dalej w świat. Jest wiele komercyjnych
usług, które za drobną opłatą mogą zapewnić nam tego tupu usługi ale ja nie będę tutaj się o nich
rozpisywał. Bez problemu można je znaleźć w góglu. My tutaj za to zajmiemy się VPN jaki zapewnia
&lt;a href=&#34;https://riseup.net/&#34;&gt;riseup&lt;/a&gt;. By móc korzystać z ich usług, trzeba założyć na ich stronie konto, a
to z kolei jest przyznawane tym, którzy w jakiś sposób działają na rzecz szeroko pojętej wolności.
Ja wysłałem zgłoszenie i konto zostało mi przyznane. Dlatego też opiszę jak wygląda konfiguracja VPN
na ich przykładzie.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Szyfrowanie poczty przy pomocy enigmail</title>
      <link>https://morfikov.github.io/post/szyfrowanie-poczty-przy-pomocy-enigmail/</link>
      <pubDate>Sun, 21 Jun 2015 15:55:30 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-poczty-przy-pomocy-enigmail/</guid>
      <description>&lt;p&gt;Szyfrowanie wiadomości email można uznać za paranoiczne podejście do kwestii wymiany informacji, bo
zwykły człowiek mówi sobie: &amp;quot;ja przecie za pomocą poczty nie wysyłam nic ważnego, nawet swoich
nagich fotek, a nawet jeśli już, to są one od pasa w dół. Poza tym, gmail jest szyfrowany, bo używa
SSL/TLS&amp;quot;. SSL/TLS, co prawda, jest ale ogranicza się do szyfrowania tego co robimy na gmailu. Same
wiadomości natomiast są przesyłane między różnymi serwerami i niekoniecznie są szyfrowane. Poza tym
google kiedyś wspominał, że w przypadku gdy policja będzie żądała dostępu do naszej skrzynki
pocztowej, to nie dość, że on im to umożliwi, to jeszcze wyciągnie wszelkie maile jakie przez tę
skrzynkę zostały przepuszczone -- zarówno te odebrane jak i wysłane.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>DNScrypt-proxy, czyli szyfrowanie zapytań DNS</title>
      <link>https://morfikov.github.io/post/dnscrypt-proxy-czyli-szyfrowanie-zapytan-dns/</link>
      <pubDate>Thu, 18 Jun 2015 20:00:54 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/dnscrypt-proxy-czyli-szyfrowanie-zapytan-dns/</guid>
      <description>&lt;p&gt;Do protokołów SSL/TLS w serwisach www chyba wszyscy już przywykli. Obecnie praktycznie na każdej
stronie, gdzie jest okienko logowania, mamy do czynienia z szyfrowaniem danych przesyłanych w
różnego rodzaju formularzach. Co prawda, klucze nie są zbyt długie (512-2048 bitów) ale zawsze to
lepsze niż nic. O ile dane służące do logowania czy też wszelkie operacje dokonywane w panelach
administracyjnych da radę ukryć bez większego problemu, o tyle zapytania DNS są przesyłane otwartym
tekstem i każdy może je sobie podejrzeć. Pytanie tylko, po co szyfrować ruch DNS? Czy są tam
przesyłane jakieś ważne informacje? Jeśli przyjrzymy się jak działa system DNS, możemy dojść do
wniosku, że szyfrowanie zapytań jest pozbawione sensu, bo z reguły nazwa domeny oznacza konkretny
adres IP. Znając adres IP, możemy ustalić kto na jakie strony wchodzi. Nie do końca jest to prawdą,
poza tym istnieją jeszcze inne czynniki, które sprawiają, że ukrycie zapytań DNS ma jak najbardziej
sens. W tym wpisie zaimplementujemy sobie na naszych linux&#39;ach szyfrowanie zapytań DNS przy
wykorzystaniu &lt;a href=&#34;https://dnscrypt.org/&#34;&gt;narzędzia dnscrypt-proxy&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Bezpieczny klucz GPG</title>
      <link>https://morfikov.github.io/post/bezpieczny-klucz-gpg/</link>
      <pubDate>Sun, 14 Jun 2015 11:55:26 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/bezpieczny-klucz-gpg/</guid>
      <description>&lt;p&gt;W poprzednim wpisie przygotowywaliśmy sobie &lt;a href=&#34;https://morfikov.github.io
/post/konfiguracja-gpg-w-pliku-gpg-conf/&#34;&gt;plik
gpg.conf&lt;/a&gt;. Opcje w nim ustawione są
niezbędne do wygenerowania dobrego pod względem bezpieczeństwa klucza GPG. Taki klucz GPG nie
powinien być krótszy niż 4096 bitów. Dodatkowo, nie powinno się ustawiać daty ważności dłuższej niż
2 lata, a to z tego powodu, że zawszę tę datę można zmienić i to nawet w przypadku gdy klucz straci
ważność. Chodzi generalnie o ustawienie jakiegoś mechanizmu zabezpieczającego na wypadek gdyby nasz
klucz GPG wpadł w niepowołane ręce i stracilibyśmy nad nim panowanie. Wtedy po jakimś czasie
automatycznie się on unieważni i nie będziemy musieli się martwić czy ktoś może przez przypadek go
używać. Jest również szereg innych rzecz, o które powinniśmy się zatroszczyć i tej tematyce będzie
poświęcony ten wpis, który w dużej mierze powstał w oparciu o te
&lt;a href=&#34;https://www.gnupg.org/gph/en/manual/book1.html&#34;&gt;dwa&lt;/a&gt;
&lt;a href=&#34;https://riseup.net/security/message-security/openpgp/best-practices&#34;&gt;linki&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Uwierzytelniające klucze SSH</title>
      <link>https://morfikov.github.io/post/uwierzytelniajace-klucze-ssh/</link>
      <pubDate>Tue, 02 Jun 2015 15:35:53 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/uwierzytelniajace-klucze-ssh/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://wiki.archlinux.org/index.php/SSH_keys&#34;&gt;Klucze SSH&lt;/a&gt; mogą być wykorzystane jako sposób
identyfikacji danej osoby przy logowaniu się do zdalnego serwera SSH. Te klucze zawsze występują w
parach -- jeden prywatny, drugi publiczny. Pierwszy z nich jest znany tylko nam i powinien być
trzymany w sekrecie i pilnie strzeżony. Klucz publiczny z kolei zaś jest przesyłany na każdy serwer
SSH, z którym chcemy się połączyć. Gdy serwer jest w posiadaniu naszego klucza publicznego i widzi
przy tym, że próbujemy nawiązać połączenie, używa on tego klucza by wysłać do nas zapytanie
(challange) -- jest ono zakodowane i musi na nie zostać udzielona odpowiednia odpowiedź, a tej może
dokonać ktoś, kto jest w posiadaniu klucza prywatnego. Nie ma innej opcji by rozkodować wiadomość,
dlatego też nikt inny nie może udzielić na nią prawidłowej odpowiedzi. To rozwiązanie eliminuje
wrażliwość na różne formy podsłuchu -- ten kto nasłuchuje nie będzie w stanie przechwycić pakietów
zawierających hasło, bo ono nie jest nigdy transmitowane prze sieć. No i oczywiście jeśli chodzi o
samo hasło -- odpadają nam ataki typu Brute Force pod kątem jego złamania.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>