<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Szyfrowanie on Morfitronik</title>
    <link>https://morfikov.github.io/tags/szyfrowanie/</link>
    <description>Recent content in Szyfrowanie on Morfitronik</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>pl-PL</language>
    <lastBuildDate>Sat, 13 Nov 2021 13:26:00 +0100</lastBuildDate><atom:link href="https://morfikov.github.io/tags/szyfrowanie/feed.xml" rel="self" type="application/rss+xml" />
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wsparcie dla WiFi w initramfs/initrd by odszyfrować LUKS przez SSH bezprzewodowo</title>
      <link>https://morfikov.github.io/post/wsparcie-dla-wifi-w-initramfs-initrd-by-odszyfrowac-luks-przez-ssh-bezprzewodowo/</link>
      <pubDate>Sat, 13 Nov 2021 13:26:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/wsparcie-dla-wifi-w-initramfs-initrd-by-odszyfrowac-luks-przez-ssh-bezprzewodowo/</guid>
      <description>&lt;p&gt;W poprzednim artykule, który traktował o &lt;a href=&#34;https://morfikov.github.io/post/odszyfrowanie-luks-przez-ssh-z-poziomu-initramfs-initrd-na-raspberry-pi/&#34;&gt;odszyfrowaniu kontenera LUKS przez SSH z poziomu
initramfs/initrd na Raspberry Pi&lt;/a&gt;, została poruszona kwestia adresacji IP, która w opisanym tam
rozwiązaniu miała pewne ograniczenia. Chodziło o to, że połączenie SSH do RPI mogło być realizowane
jedynie przez przewodowy interfejs sieciowy &lt;code&gt;eth0&lt;/code&gt; . Trzeba było zatem się zastanowić nad
rozwiązaniem, które umożliwiłoby korzystanie również z bezprzewodowego interfejsu WiFi, tj.
&lt;code&gt;wlan0&lt;/code&gt; . Celem niniejszego wpisu jest pokazanie w jaki sposób można dorobić wsparcie dla
połączeń WiFi w naszej malinie, tak by szło odszyfrować kontener LUKS przez SSH, w sytuacji gdy z
jakiegoś powodu nie chcemy lub też nie możemy korzystać z przewodowego interfejsu sieciowego tego
minikomputera z zainstalowanym system RasPiOS/Raspbian.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Odszyfrowanie LUKS przez SSH z poziomu initramfs/initrd na Raspberry Pi</title>
      <link>https://morfikov.github.io/post/odszyfrowanie-luks-przez-ssh-z-poziomu-initramfs-initrd-na-raspberry-pi/</link>
      <pubDate>Fri, 12 Nov 2021 23:13:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/odszyfrowanie-luks-przez-ssh-z-poziomu-initramfs-initrd-na-raspberry-pi/</guid>
      <description>&lt;p&gt;Od paru dni bawię się swoim Raspberry Pi w kontekście zaszyfrowania jego systemu RasPiOS/Raspbian.
O ile samo &lt;a href=&#34;https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/&#34;&gt;zaszyfrowanie tego minikomputera przy pomocy mechanizmu LUKS&lt;/a&gt; nie było jakoś
specjalnie trudne, to trzeba było pomyśleć nad rozwiązaniami mającymi ułatwić otworzenie takiego
zaszyfrowanego kontenera przy starcie systemu. Póki co udało się wypracować w miarę zadowalające
&lt;a href=&#34;https://morfikov.github.io/post/wykorzystanie-nosnika-usb-jako-klucz-do-odszyfrowania-raspberry-pi/&#34;&gt;rozwiązanie wykorzystujące dedykowane urządzenia USB w roli klucza&lt;/a&gt;, bez którego system się nie
uruchomi. Są jednak i inne rozwiązania, które mogą nam pomóc odszyfrować system RPI bez potrzeby
fatygowania się do pomieszczenia i wtykania w jej port USB jakiegoś pendrive. Mowa o zaprzęgnięciu
usługi SSH, która by została uruchomiona w fazie initramfs/initrd, chwilę przed wpisaniem hasła do
kontenera LUKS. Takie rozwiązanie wymaga jednak zainstalowania innego serwera SSH, tj. Dropbear,
pogodzenia go z serwerem OpenSSH oraz też trzeba odpowiednio przygotować sam obraz initramfs/initrd.
Po pomyślnym skonfigurowaniu systemu, będziemy się logować do Raspberry Pi przez SSH i wpisywać
hasło do kontenera LUKS, a jeśli to hasło będzie prawidłowe, to system zostanie odszyfrowany i
uruchomiony.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Wykorzystanie nośnika USB jako klucz do odszyfrowania Raspberry Pi (LUKS)</title>
      <link>https://morfikov.github.io/post/wykorzystanie-nosnika-usb-jako-klucz-do-odszyfrowania-raspberry-pi/</link>
      <pubDate>Thu, 11 Nov 2021 05:32:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/wykorzystanie-nosnika-usb-jako-klucz-do-odszyfrowania-raspberry-pi/</guid>
      <description>&lt;p&gt;Ostatnio udało mi się &lt;a href=&#34;https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/&#34;&gt;zaszyfrować swojego Raspberry Pi 4B przez wdrożenie kontenera LUKS&lt;/a&gt; i
upchnięcie w nim wszystkich danych z partycji &lt;code&gt;/&lt;/code&gt; zainstalowanego w tym urządzeniu systemu
RasPiOS/Raspbian. To jednak nie był koniec pracy, bo taki zaszyfrowany system na RPI ma szereg wad.
Tym główniejszym uniedogodnieniem jest wpisywanie hasła na początku fazy boot, by pełny start
systemu był w ogóle możliwy. Sytuacja się komplikuje, gdy do naszego minikomputera nie mamy
podłączonego monitora i/lub klawiatury. Ten zaistniały problem można rozwiązać na kilka sposobów,
np. przez zaprzęgnięcie do pracy dodatkowego nośnika USB w celu umieszczenia na nim pliku klucza
(keyfile). Niemniej jednak, można pójść o krok dalej i wykorzystać samo urządzenie jako klucz i gdy
takiego pendrive nie podłączymy do portu USB naszej maliny, to system nam się nie uruchomi. Te dwa
rozwiązania są bardzo podobne do siebie ale to drugie jest nieco bardziej odporne na ewentualne
problemy ze skasowaniem pliku klucza, co może nam się przytrafić, gdy taki pendrive jest
wykorzystywany w roli regularnego nośnika danych przechowującego dla niepoznaki jakieś pliki. Tak
czy inaczej oba te sposoby zostaną opisane w niniejszym artykule.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zaszyfrować Raspberry Pi (RasPiOS/Raspbian, LUKS)</title>
      <link>https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/</link>
      <pubDate>Sun, 07 Nov 2021 22:17:00 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zaszyfrowac-raspberry-pi-raspios-raspbian-luks/</guid>
      <description>&lt;p&gt;Ostatnio napisał do mnie pewien osobnik, który miał dość spory problem z zaszyfrowaniem swojego
Raspberry Pi. Po wymianie kilku maili zacząłem tracić rozeznanie w całej tej sytuacji i doszedłem
do wniosku, że najwyraźniej zaszyfrowanie systemu maliny nie jest rzeczą trywialną. Postanowiłem
zatem rzucić okiem na swojego RPI i sprawdzić czy są tutaj faktycznie jakieś odstępstwa od
tradycyjnego szyfrowania na bazie LUKS w stosunku do szyfrowania spotykanego w pierwszej lepszej
dystrybucji linux&#39;a, takiej jak Debian czy Ubuntu. Pobrałem więc ze strony Raspberry Pi najnowszy
obraz systemu RasPiOS/Raspbian, wrzuciłem go na kartę SD przy pomocy &lt;code&gt;dd&lt;/code&gt; i okazało się, że w
zasadzie większych problemów z zaszyfrowaniem mojej maliny nie było. Przyznać trzeba, że informacje
na temat szyfrowania RPI, które można spotkać na internetach, są w przeważającej większości bardzo
słabej jakości i mam wrażenie, że pisane przez osoby, które nie do końca się zainteresowały
poruszanym przez siebie zagadnieniem. Postanowiłem zatem na przykładzie mojego Raspberry Pi 4B
opisać w miarę dokładny sposób od początku do końca jak przeprowadzić cały ten proces szyfrowania
danych na karcie SD, którą podpinamy do naszego minikomputera.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Tworzenie kopii zapasowej linux&#39;a z BorgBackup</title>
      <link>https://morfikov.github.io/post/tworzenie-kopii-zapasowej-linux-z-borgbackup/</link>
      <pubDate>Thu, 08 Oct 2020 19:05:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/tworzenie-kopii-zapasowej-linux-z-borgbackup/</guid>
      <description>&lt;p&gt;Gdy chodzi o bezpieczeństwo danych przechowywanych na nośnikach pamięci masowych, takich jak dyski
twarde, to użytkownicy linux&#39;a często piszą sobie skrypty shell&#39;owe mające na celu przeprowadzić
backup całego nośnika lub też jego konkretnych plików/katalogów. Zwykle zaprzęgany jest do pracy
&lt;code&gt;rsync&lt;/code&gt; , który bez problemu jest w stanie  zsynchronizować zawartość dwóch folderów (źródłowego i
docelowego) i po tym procesie wołany jest także &lt;code&gt;tar&lt;/code&gt; mający na celu skompresować pliki backup&#39;u,
tak by zajmowały mniej miejsca. Nie mam nic do tego rozwiązania, bo sam też przez lata z niego
korzystałem ale ma ono całą masę wad. Przede wszystkim, ten mechanizm nie bierze pod uwagę zmian w
samych plikach, czyli tworzy kopię tego co mu się poda i w taki sposób mamy wiele paczek &lt;code&gt;.tar.gz&lt;/code&gt; ,
które zajmują sporo miejsca. Kolejną sprawą jest brak zabezpieczenia przed nieuprawnionym dostępem
do plików kopii zapasowej, np. przy pomocy szyfrowania. W ten sposób trzeba posiłkować się
zewnętrznymi rozwiązaniami, np. pełne szyfrowanie dysku za sprawą LUKS/dm-crypt, co nie zawsze jest
możliwe i też bardzo komplikuje cały proces tworzenia kopii zapasowej, zwłaszcza na zewnętrznych
nośnikach czy zdalnych hostach w sieci. Ostatnio jednak trafiłem na &lt;a href=&#34;https://borgbackup.readthedocs.io/&#34;&gt;narzędzie BorgBackup&lt;/a&gt;, które
to dość znacznie upraszcza cały proces tworzenia backup&#39;u plików na linux, a takie cechy jak
szyfrowanie, kompresja i deduplikacja danych są w borg zaimplementowane standardowo. Postanowiłem
zatem zmigrować z mojego skryptowego systemu tworzenia kopii zapasowych na rzecz borg&#39;a i spisać
przy okazji te użyteczniejsze informacje dotyczące posługiwania się tym narzędziem&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Systemowy GPG/GnuPG w Thunderbird 78&#43; na linux</title>
      <link>https://morfikov.github.io/post/systemowy-gpg-gnupg-w-thunderbird-78-na-linux/</link>
      <pubDate>Mon, 07 Sep 2020 20:15:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/systemowy-gpg-gnupg-w-thunderbird-78-na-linux/</guid>
      <description>&lt;p&gt;Jakiś już czas temu Mozilla ogłosiła, że Thunderbird od wersji 78 będzie posiadał natywne wsparcie
dla szyfrowania wiadomości z wykorzystaniem kluczy GPG/PGP, przez co &lt;a href=&#34;https://enigmail.net/index.php/en/&#34;&gt;dodatek Enigmail&lt;/a&gt; będzie
już zwyczajnie zbędny. Dziś z kolei czytam sobie o &lt;a href=&#34;https://blog.thunderbird.net/2020/09/openpgp-in-thunderbird-78/&#34;&gt;zakończeniu wsparcia dla wersji 68&lt;/a&gt; tego
klienta pocztowego, które będzie miało miejsce z końcem września 2020, czyli został już niespełna
miesiąc i ta starsza wersja Thunderbird&#39;a nie będzie już dostawać łat bezpieczeństwa. Pewne jest
zatem, że dystrybucje linux&#39;a w niedługim czasie pchną wersję 78 do głównych repozytoriów. W
Debianie, wersja 78 Thunderbird&#39;a od dłuższego czasu jest dostępna w gałęzi eksperymentalnej i można
było ją już wcześniej sobie zainstalować, jeśli ktoś wyrażał taką chęć. Gdy ja ostatni raz
testowałem wersję 78, to nie była ona zbytnio do użytku ale wygląda na to, że większość
niedogodności, których mi się udało doświadczyć, została już wyeliminowana. Pozostał w zasadzie
jeden problem, tj. Thunderbird domyślnie używa własnego keyring&#39;a kluczy GPG/PGP, w efekcie czego
systemowy GPG/GnuPG nie jest w ogóle wykorzystywany. Taki san rzeczy sprawia, że będziemy mieć dwie
różne bazy danych kluczy (jedna dla Thunderbird&#39;a, a druga dla reszty linux&#39;a), co może trochę
irytować. Na szczęście jest opcja wymuszenia na TB, by korzystał on z systemowego keyring&#39;a kluczy
GPG/PGP i celem tego artykułu jest pokazanie właśnie jak tego typu zabieg przeprowadzić.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak odszyfrować linux&#39;a przy pomocy telefonu z Androidem</title>
      <link>https://morfikov.github.io/post/jak-odszyfrowac-linux-przy-pomocy-telefonu-z-androidem/</link>
      <pubDate>Sat, 15 Aug 2020 02:43:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-odszyfrowac-linux-przy-pomocy-telefonu-z-androidem/</guid>
      <description>&lt;p&gt;Zaszyfrowane systemy (desktopy/laptopy) mają jeden poważny problem, gdy chodzi o zapewnianie
bezpieczeństwa chronionym plikom przechowywanym na dyskach twardych. Gdy siedzimy obok naszej
maszyny, możemy czuć się bezpiecznie, bo przecież nikt nie może się włamać do jej systemu bez
naszej wiedzy. Nawet jeśli ktoś będzie próbował się dostać do naszego PC, to istnieje spora szansa,
że takie działanie zostałoby natychmiast przez nas wykryte, przez co moglibyśmy w odpowiedni sposób
zareagować na zaistniałe zagrożenie. Co jednak w przypadku, gdy zostawiamy przykładowo naszego
laptopa samego? Nawet jeśli zablokujemy mu ekran, wyłączymy go albo zahibernujemy, to ta maszyna
wciąż nie jest odpowiednio zabezpieczona, by uniemożliwić osobom postronnym dostęp do naszych
wrażliwych danych. Problem leży w fizycznym dostępie do sprzętu, który ludzie mogą uzyskać, gdy nas
nie ma w pobliżu naszego komputera. W taki sposób osoby trzecie mogą wykorzystać fakt, że tracimy
maszynę z oczu i być w stanie zastawić na nas różne pułapki. By uniknąć zagrożenia związanego z
zostawieniem laptopa/desktopa bez nadzoru, nie możemy w zasadzie pozostawiać tego urządzenia samego,
co jest zadaniem praktycznie nie do wykonania. Komputery stacjonarne czy nawet laptopy nie są
urządzeniami o małych gabarytach i zwykle nie możemy ich wszędzie zabrać ze sobą, w przeciwieństwie
do smartfonów. Postanowiłem zatem tak skonfigurować swojego linux&#39;a, by jego zaszyfrowany dysk
(LUKS + LVM) można było odszyfrować jedynie przy pomocy mojego telefonu z Androidem, z którym w
zasadzie się nie rozstaję.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak włączyć w Firefox ESNI (Encrypted SNI)</title>
      <link>https://morfikov.github.io/post/jak-wlaczyc-w-firefox-esni-encrypted-sni/</link>
      <pubDate>Mon, 10 Aug 2020 18:15:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-wlaczyc-w-firefox-esni-encrypted-sni/</guid>
      <description>&lt;p&gt;Obecnie szyfrowanie zapytań DNS staje się powoli normą za sprawą protokołu DoH (&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_HTTPS&#34;&gt;DNS over HTTPS&lt;/a&gt;)
lub DoT (&lt;a href=&#34;https://en.wikipedia.org/wiki/DNS_over_TLS&#34;&gt;DNS over TLS&lt;/a&gt;). Można by zatem pomyśleć, że wraz z implementacją szyfrowania tego
kluczowego dla działania internetu protokołu (przynajmniej z naszego ludzkiego punktu widzenia),
poprawie ulegnie również nasza prywatność w kwestii odwiedzanych przez nas stron WWW. Niemniej
jednak, w dalszym ciągu można bez problemu wyciągnąć adresy domen, które zamierzamy odwiedzić. Nie
ma przy tym żadnego znaczenia ile stron jest hostowanych na danym adresie IP, ani nawet fakt, że
ruch do serwera WWW będzie szyfrowany (w pasku adresu wpiszemy &lt;code&gt;https://&lt;/code&gt; ) z wykorzystaniem
protokołu SSL/TLS (w tym również TLS v1.3). Wszystko przez rozszerzenie SNI (&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication&#34;&gt;Server Name
Indication&lt;/a&gt;), którego to zadaniem jest umożliwienie jednemu serwerowi na prezentowanie wielu
certyfikatów hostowanych w jego obrębie domen. Dzięki takiemu rozwiązaniu, każda domena może
szyfrować ruch niezależnie od siebie na linii serwer&amp;lt;-&amp;gt;klient (używać innych kluczy szyfrujących).
Niemniej jednak, podczas nawiązywania szyfrowanego połączenia, w pakiecie ClientHello przesyłanym
do takiego serwera musi znaleźć się nazwa domeny, której to certyfikat serwer będzie musiał nam
przedstawić. Niestety ten pakiet jest przesyłany przez sieć otwartym tekstem, przez co każdy, kto
podsłuchuje naszą komunikację (w tym też nasz ISP), bez problemu może ustalić na jakie strony
internetowe wchodzimy. Ostatnimi czasy jednak pojawiły się dwa rozszerzenia ECH (&lt;a href=&#34;https://en.wikipedia.org/wiki/Server_Name_Indication#Encrypted_Client_Hello&#34;&gt;Encrypted Client
Hello&lt;/a&gt;) oraz ESNI (&lt;a href=&#34;https://tools.ietf.org/html/draft-ietf-tls-esni-07&#34;&gt;Encrypted SNI&lt;/a&gt;), które mają zaadresować problemy związane z prywatnością
przez pełne zaszyfrowanie pakietu ClientHello lub też zaszyfrowanie jedynie pola SNI w tym pakiecie.
Póki co, prace nad tymi rozszerzeniami nie są jeszcze skończone ale Firefox w połączeniu z
CloudFlare powoli testują ESNI. Postanowiłem zatem dobrowolnie przyłączyć się do grupy testerów i
wdrożyć na swoim linux&#39;ie to rozszerzenie ESNI dla przeglądarki Firefox.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Kernel crash przy szyfrowaniu smartfona lub próbie resetu ustawień do fabrycznych</title>
      <link>https://morfikov.github.io/post/kernel-crash-przy-szyfrowaniu-smartfona-lub-probie-resetu-ustawien-do-fabrycznych/</link>
      <pubDate>Sat, 22 Sep 2018 11:13:00 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/kernel-crash-przy-szyfrowaniu-smartfona-lub-probie-resetu-ustawien-do-fabrycznych/</guid>
      <description>&lt;p&gt;Parę dni temu dowiedziałem się o &lt;a href=&#34;https://e.foundation/&#34;&gt;projekcie /e/&lt;/a&gt;. Z racji, że ten ROM jest dostępny na mój
smartfon LG G4C (jeszcze nieoficjalnie), to postanowiłem go sobie wgrać i zobaczyć jak się będzie
sprawował. Podczas testów nowego oprogramowania spróbowałem zaszyfrować partycję &lt;code&gt;/data/&lt;/code&gt; . Problem
w tym, że po automatycznym zresetowaniu się systemu, urządzenie już nie chciało się uruchomić. Przez
dłuższy czas widniało logo LG, a po chwili pojawił się czarny ekran z informacją &amp;quot;Kernel Crash&amp;quot; lub
niebieski ekran z informacją &amp;quot;Subsystem Crash&amp;quot;. Czy telefon w takiej sytuacji nadaje się jedynie do
wyrzucenia?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Zmiana domyślnego hasła szyfrującego klucz główny w Neffos X1 i X1 Max</title>
      <link>https://morfikov.github.io/post/zmiana-domyslnego-hasla-szyfrujacego-klucz-glowny-w-neffos-x1-i-x1-max/</link>
      <pubDate>Wed, 16 May 2018 19:33:54 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/zmiana-domyslnego-hasla-szyfrujacego-klucz-glowny-w-neffos-x1-i-x1-max/</guid>
      <description>&lt;p&gt;Nie bawiłem się ostatnio Neffos&#39;ami ale w końcu udało mi się doprowadzić szyfrowanie w X1 Max (i
pewnie X1 też) do ładu. Dla przypomnienia, to w tych modelach najwyraźniej system zapomniał by
pytać użytkownika o hasło podczas konfiguracji, a że partycja z danymi użytkownikami jest
zaszyfrowana w standardzie (bez możliwości zmiany), to ustawiane jest domyślne hasło tj.
&lt;code&gt;default_password&lt;/code&gt; . W ten sposób z technicznego punktu widzenia wilk jest syty i owca cała,
no bo użytkownik nie jest dręczony dodatkowym hasłem przy uruchamianiu systemu (obok hasła blokady
ekranu), no i dane są zaszyfrowane, no chyba, że ktoś wpisze ten nieszczęsny
&lt;code&gt;default_password&lt;/code&gt; .&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Szyfrowanie rozmów i SMS&#39;ów na smartfonie z Androidem (Signal)</title>
      <link>https://morfikov.github.io/post/szyfrowanie-rozmow-i-smsow-na-smartfonie-z-androidem-signal/</link>
      <pubDate>Sun, 26 Mar 2017 18:35:14 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-rozmow-i-smsow-na-smartfonie-z-androidem-signal/</guid>
      <description>&lt;p&gt;Każdy z nas ma już raczej w swoim posiadaniu telefon, czy jego nieco bardziej zaawansowaną wersję
określaną mianem smartfona. Te urządzenia to w zasadzie przenośne i do tego bardzo małe komputery,
które umożliwiają nam komunikowanie się z osobami na całym świecie. Wykonywanie połączeń głosowych,
przesyłanie SMS&#39;ów/MMS&#39;ów czy też korzystanie z Internetu w naszych komórkach od dawna jest już
standardem i ciężko byłoby nam się obejść bez tej technologii obecnie. Problem w tym, że nasza
komunikacja jest narażona na podsłuch. W przypadku Internetu większość połączeń jest już szyfrowana
na linii dwóch klientów (E2E, End To End). Natomiast jeśli chodzi o telefony, to tutaj sprawa kuleje
i to bardzo poważnie, bo w zasadzie nasze połączenia głosowe czy SMS&#39;y są do wglądu dla każdych
służb, które z jakiegoś powodu uznają, że mogą naruszać naszą prywatność. Jedyna opcja, która jest
w stanie zabezpieczyć nas przed tego typu praktykami, to szyfrowanie rozmów. Tak się składa, że jest
kilka aplikacji na Androida, które są w stanie realizować tego typu przedsięwzięcie. Jedną z nich
jest darmowa i otwartoźródłowa aplikacja Signal, której się przyjrzymy nieco bliżej w tym artykule.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zmienić hasło do zaszyfrowanego smartfona z Androidem</title>
      <link>https://morfikov.github.io/post/jak-zmienic-haslo-do-zaszyfrowanego-smartfona-z-androidem/</link>
      <pubDate>Fri, 03 Mar 2017 17:58:36 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zmienic-haslo-do-zaszyfrowanego-smartfona-z-androidem/</guid>
      <description>&lt;p&gt;Każdy nowszy smartfon z Androidem oferuje możliwość zaszyfrowania wszystkich danych użytkownika
zlokalizowanych na partycji &lt;code&gt;/data/&lt;/code&gt; . Cały proces można przeprowadzić w bardzo prosty sposób i bez
większych problemów. Raz zaszyfrowanego telefonu nie da rady cofnąć do stadium przed szyfrowaniem i
w zasadzie to zabezpieczenie można zdjąć jedynie przez przywrócenie urządzenia do ustawień
fabrycznych. My tutaj jednak nie będziemy zajmować się samym szyfrowaniem smartfona i skupimy się
bardziej na hasłach zabezpieczających mających stać na straży dostępu do naszych cennych danych,
które mamy w telefonie. Większość z nas wykorzystuje krótkie hasło do odblokowania ekranu. To samo
hasło z kolei jest wykorzystywane do zaszyfrowania klucza używanego w procesie
szyfrowania/deszyfrowania danych na flash&#39;u smartfona. W ustawieniach Androida nie ma jednak opcji
rozdzielenia tych haseł i można by pomyśleć, że wykorzystanie czterocyfrowego kodu PIN jako
zabezpieczenie mija się z celem. Na pewno w części smartfonów tak ale niekoniecznie we wszystkich
modelach. Tak się składa, że akurat leży u mnie nieużywany Neffos Y5 od TP-LINK, to postanowiłem
przyjrzeć się nieco bliżej tej kwestii haseł i sprawdzić czy jest się czego obawiać stosując krótkie
hasła w zaszyfrowanych Androidach.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Problem z zaszyfrowaniem partycji /data/ na smartfonie z Androidem</title>
      <link>https://morfikov.github.io/post/problem-z-zaszyfrowaniem-partycji-data-na-smartfonie-z-androidem/</link>
      <pubDate>Sat, 11 Feb 2017 18:59:25 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/problem-z-zaszyfrowaniem-partycji-data-na-smartfonie-z-androidem/</guid>
      <description>&lt;p&gt;Bawiąc się ostatnio trochę mechanizmami szyfrującymi w moich smartfonach Neffos podesłanych przez
TP-LINK, po raz kolejny coś nieopatrznie uszkodziłem. Tym razem sprawa wygląda nieco bardziej
poważnie, bo uwalony został cały moduł szyfrujący urządzenie. Chodzi generalnie o to, że w
Androidzie w wersji 4.4/5.0 została wprowadzona &lt;a href=&#34;https://source.android.com/security/encryption/full-disk&#34;&gt;możliwość zaszyfrowania wszystkich danych
użytkownika&lt;/a&gt;, tj. informacji przechowywanych na partycji &lt;code&gt;/data/&lt;/code&gt; . Do odszyfrowania tej partycji
potrzebny jest klucz szyfrujący. Problem w tym, że Android musi gdzieś ten klucz trzymać i to w taki
sposób, by proces Factory Reset był w stanie ten klucz usunąć, choćby na wypadek zapomnienia hasła i
próby odzyskania w takiej sytuacji władzy nad smartfonem. Pech chciał, że akurat na moim Neffos Y5
mam wgrane TWRP recovery i z jakiegoś powodu nie mogłem zresetować ustawień telefonu do fabrycznych
przez ten tryb i posłużyłem się narzędziem &lt;code&gt;fastboot&lt;/code&gt; . Ono najwyraźniej nieco inaczej formatuje
partycję &lt;code&gt;/data/&lt;/code&gt; i w ten sposób uwala cały mechanizm szyfrowania oferowany przez Androida. Czy da
radę jakoś poprawić ten problem, a jeśli tak to w jaki sposób?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak odszyfrować zawartość karty SD w smartfonie z Androidem</title>
      <link>https://morfikov.github.io/post/jak-odszyfrowac-zawartosc-karty-sd-w-smartfonie-z-androidem/</link>
      <pubDate>Thu, 09 Feb 2017 18:01:56 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-odszyfrowac-zawartosc-karty-sd-w-smartfonie-z-androidem/</guid>
      <description>&lt;p&gt;W Androidzie 6.0 Marshmallow został wprowadzony ciekawy mechanizm zwany &lt;a href=&#34;https://source.android.com/devices/storage/adoptable&#34;&gt;Adoptable Storage&lt;/a&gt;,
który umożliwia &lt;a href=&#34;https://morfikov.github.io/post/android-formatowanie-karty-sd-jako-pamiec-wewnetrzna/&#34;&gt;zamontowanie karty SD w smartfonie jako pamięć wewnętrzna&lt;/a&gt;. W ten
sposób pamięć flash w telefonach, które mają jej niewiele, może zostać nieco rozbudowana. Jedyny
problem z tym całym Adoptable Storage jest taki, że Android szyfruje zawartość karty SD
automatycznie, przez co nie jesteśmy w stanie odczytać żadnych informacji z takiego nośnika na
innych urządzeniach. Istnieje jednak sposób, by rozszyfrować i tym samym uzyskać dostęp do danych
zgromadzonych na karcie SD z poziomu linux&#39;a, np. dystrybucji Debian. W tym artykule prześledzimy
sobie właśnie ten proces na przykładzie &lt;a href=&#34;http://www.neffos.pl/product/details/Y5&#34;&gt;smartfona Neffos Y5&lt;/a&gt; od TP-LINK.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak zaszyfrować zapytania DNS na smartfonie (dnscrypt-proxy)</title>
      <link>https://morfikov.github.io/post/jak-zaszyfrowac-zapytania-dns-na-smartfonie-dnscrypt-proxy/</link>
      <pubDate>Thu, 27 Oct 2016 18:52:19 +0200</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-zaszyfrowac-zapytania-dns-na-smartfonie-dnscrypt-proxy/</guid>
      <description>&lt;p&gt;Smartfony to takie małe komputery, z których praktycznie każdy z nas korzysta na co dzień. Nie
różnią się one zbytnio od tych domowych PC czy laptopów, no może za wyjątkiem rozmiarów.
Wszystkie elementy tyczące się spraw sieciowych, np. korzystanie z internetu za pomocą przeglądarki,
są dokładnie taka same co w przypadku zwykłych komputerów. Na smartfonach domeny również trzeba
jakoś rozwiązać. Standardowo w Androidzie są wykorzystywane serwery od Google (8.8.8.8 i 8.8.4.4).
Jeśli nasza sieć WiFi oferuje inne DNS&#39;y, to wtedy one mają pierwszeństwo. Niemniej jednak, nie
zawsze będziemy w stanie kontrolować środowisko sieciowe, do którego zostaniemy podłączeni. W takiej
sytuacji będziemy zdani na łaskę admina obcej sieci w kwestii poufności odwiedzanych przez nas stron
www czy jakichkolwiek innych domen w internecie. Z doświadczenia wiem, by nie składać swojej
prywatności w czyjeś ręce i dlatego też postanowiłem poszukać sposobu na zaszyfrowanie zapytań DNS
bezpośrednio na smartfonie. Długo nie musiałem szukać, bo okazuje się, że &lt;a href=&#34;https://dnscrypt.org/#dnscrypt-android&#34;&gt;dnscrypt-proxy jest
dostępny również na Androida&lt;/a&gt;.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Jak ukryć zaszyfrowany kontener LUKS pod linux</title>
      <link>https://morfikov.github.io/post/jak-ukryc-zaszyfrowany-kontener-luks-pod-linux/</link>
      <pubDate>Tue, 25 Oct 2016 19:30:23 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/jak-ukryc-zaszyfrowany-kontener-luks-pod-linux/</guid>
      <description>&lt;p&gt;Gdy w grę wchodzi poufność informacji, to przeciętny użytkownik komputera od razu zaczyna rozważać
szyfrowanie danych. Są różne narzędzia, które te kwestię realizują w mniejszym lub większym stopniu.
Kiedyś wszyscy korzystali z &lt;a href=&#34;http://truecrypt.sourceforge.net/&#34;&gt;TrueCrypt&lt;/a&gt; ale po jego dziwnych
przygodach ludzie stopniowo zaczęli od tego oprogramowania odchodzić. W jego miejscu zaczęły
pojawiać się różne forki, np. &lt;a href=&#34;https://veracrypt.codeplex.com/&#34;&gt;VeraCrypt&lt;/a&gt;. Abstrahując od tych ww.
narzędzi, w każdym linux&#39;ie mamy również dostępny &lt;a href=&#34;https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions&#34;&gt;mechanizm szyfrujący na bazie
LUKS&lt;/a&gt; i jego gołą wersję
wykorzystującą dm-crypt. Przy pomocy każdego z tych narzędzi jesteśmy w stanie zaszyfrować dysk
komputera, pendrive, czy nawet kartę SD, w taki sposób, by nikt inny nie uzyskał dostępu do danych
zgromadzonych na tych nośnikach informacji. Problem w tym, że w dalszym ciągu ktoś może nas
torturować, by wydobyć od nas hasło czy keyfile i uzyskać dostęp do tych zaszyfrowanych danych bez
większego trudu. Dlatego też pojawiło się coś nazwanego &lt;a href=&#34;https://en.wikipedia.org/wiki/Plausible_deniability&#34;&gt;Plausible
Deniability&lt;/a&gt;, gdzie wykorzystywane są tak
naprawdę dwa nośniki z czego jeden robi za przykrywkę, a na drugim mamy zgromadzone poufne pliki. W
ten sposób agresorowi podajemy hasło do trefnego kontenera i wszyscy są zadowoleni. Czy aby na
pewno?&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Szyfrowanie logów w OpenWRT (syslog-ng)</title>
      <link>https://morfikov.github.io/post/szyfrowanie-logow-w-openwrt-syslog-ng/</link>
      <pubDate>Fri, 29 Apr 2016 02:36:00 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/szyfrowanie-logow-w-openwrt-syslog-ng/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://morfikov.github.io/post/logread-czyli-system-logowania-w-openwrt/&#34;&gt;We wpisie dotyczącym logread&lt;/a&gt;
została podniesiona kwestia przesłania logów przez sieć. OpenWRT jest w stanie tego typu zadanie
realizować po określeniu kilku dodatkowych opcji w pliku &lt;code&gt;/etc/config/system&lt;/code&gt; . Trzeba jednak zdawać
sobie sprawę, że tak przesyłane komunikaty nie będą w żaden sposób zabezpieczone. W sieci domowej
raczej nie musimy sobie zawracać głowy tym mankamentem. Niemniej jednak, gdy w grę wchodzi
przesyłanie logów do zdalnego serwera zlokalizowanego gdzieś w internecie, to taką komunikację
należy zabezpieczyć przed podsłuchem. Niestety OpenWRT standardowo nie wspiera takich udziwnień ale
dysponuje on pakietami, które mogą nam zapewnić taką funkcjonalność. Szyfrowanie logów możemy w
łatwy sposób wdrożyć za pomocą pakietu &lt;code&gt;syslog-ng3&lt;/code&gt; . W nim znajduje się demon &lt;code&gt;syslog-ng&lt;/code&gt; , który
jest kompatybilny w pełni z innymi linux&#39;owymi demonami logowania. Nie powinno zatem być problemów
ze skonfigurowaniem tego całego mechanizmu.&lt;/p&gt;
&lt;p&gt;W OpenWRT w wersji Chaos Calmer nie ma pakietu &lt;code&gt;syslog-ng3&lt;/code&gt; . W efekcie szyfrowanie logów routera
nie jest obecnie możliwe. Ten wpis dotyczy jedynie wydania Barrier Breaker i zostanie zaktualizowany
jak tylko wspomniany pakiet trafi do repozytorium.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Klucze szyfrujące RSA w OpenWRT (ssh)</title>
      <link>https://morfikov.github.io/post/klucze-szyfrujace-rsa-w-openwrt-ssh/</link>
      <pubDate>Sun, 24 Apr 2016 01:14:41 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/klucze-szyfrujace-rsa-w-openwrt-ssh/</guid>
      <description>&lt;p&gt;Klucze RSA w protokole SSH mogą być wykorzystane jako sposób identyfikacji danej osoby przy
logowaniu się do zdalnego serwera. Te klucze zawsze występują w parach. Jeden prywatny, drugi
publiczny. Pierwszy z nich jest znany tylko nam i powinien być trzymany w sekrecie i pilnie
strzeżony. Klucz publiczny z kolei zaś jest przesyłany na każdy serwer SSH, z którym chcemy się
połączyć. Gdy serwer jest w posiadaniu naszego klucza publicznego i widzi przy tym, że próbujemy
nawiązać połączenie, używa on tego klucza, by wysłać do nas zapytanie (challange). Jest ono
zakodowane i musi na nie zostać udzielona prawidłowa odpowiedź. Tej z kolei może udzielić ktoś, kto
jest w posiadaniu klucza prywatnego. Nie ma innej opcji, by rozkodować wiadomość. Dlatego też nikt
inny nie może udzielić na nią prawidłowej odpowiedzi. To rozwiązanie eliminuje wrażliwość na różne
formy podsłuchu. Ten kto nasłuchuje nie będzie w stanie przechwycić pakietów zawierających hasło, bo
ono nie jest nigdy transmitowane prze sieć. No i oczywiście jeśli chodzi o samo hasło, to odpadają
nam ataki bruteforce pod kątem jego złamania. W tym wpisie postaramy się zaimplementować na routerze
z OpenWrt system logowania oparty o klucze RSA.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Nagłówek kontenera LUKS trzymany na pendrive</title>
      <link>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</link>
      <pubDate>Fri, 15 Jan 2016 20:28:24 +0100</pubDate>
      
      <guid>https://morfikov.github.io/post/naglowek-kontenera-luks-trzymany-na-pendrive/</guid>
      <description>&lt;p&gt;Jeśli kiedyś rozważaliśmy &lt;a href=&#34;https://morfikov.github.io/post/keyfile-trzymany-w-glebokim-ukryciu/&#34;&gt;umieszczenie pliku klucza (keyfile) do zaszyfrowanego kontenera LUKS na
pendrive&lt;/a&gt;, to ciekawszą alternatywą może okazać się umieszczenie całego nagłówka takiego
kontenera na zewnętrznym nośniku. Ma to tę przewagę nad keyfile, że wszystkie informacje
zapewniające dostęp do kontenera, wliczając w to klucz główny, są oddzielone od zaszyfrowanych
danych. W ten sposób nawet jeśli kontener wpadnie w niepowołane ręce, to nie ma żadnego sposobu na
to, by ten ktoś te dane odzyskał, no bo przecie nie ma klucza szyfrującego. Przechwycenie hasła
również nic to nie zmieni, no chyba, że ten ktoś zdobędzie również pendrive z nagłówkiem kontenera.
Z ludzkiego punktu widzenia, to na takim dysku będą znajdować się jedynie losowe dane i do tego w
formie kompletnie nieczytelnej dla człowieka (brak systemu plików). Niemniej jednak, jest kilka
rzeczy, o których warto pamiętać, gdy w grę wchodzi nagłówek LUKS i to o nich porozmawiamy sobie w
tym wpisie.&lt;/p&gt;</description>
    </item>
    
    <item>
	  <author>Mikhail Morfikov</author>
      <title>Klucz główny kontenera LUKS i jego odzyskanie</title>
      <link>https://morfikov.github.io/post/odzyskanie-klucza-glownego-w-kontenerze-luks/</link>
      <pubDate>Fri, 15 Jan 2016 16:25:39 +0000</pubDate>
      
      <guid>https://morfikov.github.io/post/odzyskanie-klucza-glownego-w-kontenerze-luks/</guid>
      <description>&lt;p&gt;Kontenery LUKS to takie wynalazki, za których pomocą jesteśmy w stanie zaszyfrować całe dyski
twarde, a właściwie to znajdujące się na nich dane. Taki kontener składa się głównie z nagłówka,
który jest umieszczany na początku partycji. By być w stanie dokonać szyfrowania i deszyfrowania
informacji w locie, system musi posiadać klucz główny (master key). Ten klucz jest przechowywany w
nagłówku i by go wydobyć, musimy wprowadzić jedno z haseł do kontenera. Później klucz wędruje do
pamięci, a hasło jest z niej usuwane. W ten sposób system ma dostęp do klucza głównego przez cały
czas począwszy od chwili otwarcia kontenera, aż do momentu jego zamknięcia. &lt;a href=&#34;https://gitlab.com/cryptsetup/cryptsetup/wikis/FrequentlyAskedQuestions&#34;&gt;Ten klucz jesteśmy w
stanie bez większego problemu wydobyć&lt;/a&gt;, co może być bardzo przydatne na wypadek zapomnienia
hasła, czy też uszkodzenia samego nagłówka. W tym wpisie postaramy się odzyskać klucz główny
zaszyfrowanego kontenera LUKS.&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
