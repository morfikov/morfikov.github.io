<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Debian | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://morfikov.github.io/tags/debian/">
  <meta property="og:site_name" content="Morfitronik">
  <meta property="og:title" content="Debian">
  <meta property="og:description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT i Android)">
  <meta property="og:locale" content="pl_PL">
  <meta property="og:type" content="website">

		
  <meta itemprop="name" content="Debian">
  <meta itemprop="description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT i Android)">
  <meta itemprop="datePublished" content="2025-05-16T18:20:00+02:00">
  <meta itemprop="dateModified" content="2025-05-16T18:20:00+02:00">
		
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Debian">
  <meta name="twitter:description" content="Blog o bezpieczeństwie, prywatności oraz systemach linux (Debian/Ubuntu, OpenWRT i Android)">

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="alternate" type="application/rss+xml" href="https://morfikov.github.io/tags/debian/feed.xml" title="Morfitronik">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
  


</head>
<body class="body kind-term">
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/tags/">Tags</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Debian</li>
	</ol>
</nav>
		<div class="page block">
			<h1 class="page__title">Debian</h1>
			
		</div>
		<div class="cards">
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/tworzenie-kopii-zapasowej-linux-z-borgbackup/">Tworzenie kopii zapasowej linux&#39;a z BorgBackup</a></h1>
	<div class="entry__content"><p>Gdy chodzi o bezpieczeństwo danych przechowywanych na nośnikach pamięci masowych, takich jak dyski
twarde, to użytkownicy linux'a często piszą sobie skrypty shell'owe mające na celu przeprowadzić
backup całego nośnika lub też jego konkretnych plików/katalogów. Zwykle zaprzęgany jest do pracy
<code>rsync</code> , który bez problemu jest w stanie  zsynchronizować zawartość dwóch folderów (źródłowego i
docelowego) i po tym procesie wołany jest także <code>tar</code> mający na celu skompresować pliki backup'u,
tak by zajmowały mniej miejsca. Nie mam nic do tego rozwiązania, bo sam też przez lata z niego
korzystałem ale ma ono całą masę wad. Przede wszystkim, ten mechanizm nie bierze pod uwagę zmian w
samych plikach, czyli tworzy kopię tego co mu się poda i w taki sposób mamy wiele paczek <code>.tar.gz</code> ,
które zajmują sporo miejsca. Kolejną sprawą jest brak zabezpieczenia przed nieuprawnionym dostępem
do plików kopii zapasowej, np. przy pomocy szyfrowania. W ten sposób trzeba posiłkować się
zewnętrznymi rozwiązaniami, np. pełne szyfrowanie dysku za sprawą LUKS/dm-crypt, co nie zawsze jest
możliwe i też bardzo komplikuje cały proces tworzenia kopii zapasowej, zwłaszcza na zewnętrznych
nośnikach czy zdalnych hostach w sieci. Ostatnio jednak trafiłem na <a href="https://borgbackup.readthedocs.io/">narzędzie BorgBackup</a>, które
to dość znacznie upraszcza cały proces tworzenia backup'u plików na linux, a takie cechy jak
szyfrowanie, kompresja i deduplikacja danych są w borg zaimplementowane standardowo. Postanowiłem
zatem zmigrować z mojego skryptowego systemu tworzenia kopii zapasowych na rzecz borg'a i spisać
przy okazji te użyteczniejsze informacje dotyczące posługiwania się tym narzędziem</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-10-08T19:05:00&#43;02:00">Opublikowano: 08/10/2020</time>
	<time class="entry__meta-lastmod meta-lastmod" datetime="2023-01-08T13:10:00&#43;01:00">Zaktualizowano: 08/01/2023</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/uwierzytelnianie-odpowiedzi-z-serwerow-czasu-ntp-przy-pomocy-nts/">Uwierzytelnianie odpowiedzi z serwerów czasu NTP przy pomocy NTS</a></h1>
	<div class="entry__content"><p>Przepisując ostatnio stare artykuły dotyczące <a href="https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/">zabezpieczenia zapytań DNS za sprawą wdrożenia na
linux dnsmasq i dnscrypt-proxy</a>, natknąłem się <a href="https://blog.cloudflare.com/secure-time/">na informację</a>, że nie tylko komunikacja DNS
w obecnych czasach w sporej mierze nie jest zaszyfrowana. W zasadzie każda maszyna podłączona do
internetu potrzebuje dysponować w miarę dokładnym czasem. By ten czas był dokładny, wymyślono
mechanizm synchronizacji czasu przez wysyłanie zapytań do serwerów NTP (<a href="https://pl.wikipedia.org/wiki/Network_Time_Protocol">Network Time Protocol</a>).
Niemniej jednak, odpowiedzi z tych serwerów czasu nie są w żaden sposób zabezpieczone i praktycznie
każdy na drodze tych pakietów może nam zmienić ustawienia czasu w systemie (MITM). W taki sposób
możemy zostać cofnięci w czasie, co z kolei może oznaczać, że system zaakceptuje certyfikaty SSL/TLS
czy też <a href="https://trimstray.github.io/posts/2019-07-21-nginx-optymalizacja_sesji_ssl-tls/#ssl_session_tickets">klucze/bilety sesji</a> (używane do wznawiania sesji TLS), które już dawno temu wygasły
lub/i zostały w jakiś sposób skompromitowane. Pchnięcie nas do przodu w czasie również oznacza
problemy, bo możemy zaakceptować certyfikat, który jeszcze nie zaczął być ważny. To z kolei otwiera
drogę do odszyfrowania połączeń z serwisami WWW, a przecie nie po to szyfrujemy ruch, by go ktoś bez
większego problemu odszyfrował. Dlatego też powinniśmy zadbać o to, by informacje o aktualnym czasie
otrzymywane z sieci docierały do nas z wiarygodnego źródła i były w jakiś sposób uwierzytelnione.
Na Debianie standardowo do synchronizacji czasu wykorzystywany jest <code>systemd-timesyncd</code> ale <a href="https://github.com/systemd/systemd/issues/9481">nie
wspiera on póki co protokołu NTS</a>. Trzeba będzie zatem się go pozbyć i zastąpić go demonem <code>ntpd</code>
z pakietu <code>ntpsec</code> .</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-09-27T12:29:00&#43;02:00">Opublikowano: 27/09/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/szyfrowany-dns-z-dnscrypt-proxy-i-dnsmasq-na-debian-linux/">Szyfrowany DNS z dnscrypt-proxy i dnsmasq na Debian linux</a></h1>
	<div class="entry__content"><p>Ostatnio na forum dug.net.pl jeden z użytkowników <a href="https://forum.dug.net.pl/viewtopic.php?id=31524">miał dość spory problem</a> z ogarnięciem
zadania polegającego na zaszyfrowaniu zapytań DNS z wykorzystaniem <a href="https://dnscrypt.info/">dnscrypt-proxy</a> i
<a href="http://www.thekelleys.org.uk/dnsmasq/doc.html">dnsmasq</a>. Ładnych parę lat temu opisywałem <a href="https://morfikov.github.io/tags/resolver/">jak skonfigurować te dwa narzędzia na Debianie</a>
(i też na OpenWRT), choć od tamtego czasu w świecie linux'owym trochę rzeczy się pozmieniało. Dla
przykładu, dnscrypt-proxy przeszedł gruntowną przebudowę, no i też systemd jest w powszechniejszym
użyciu niż to miało miejsce w tamtych czasach, przez co w sporej części przypadków usługi takie jak
<code>systemd-networkd.service</code> czy <code>systemd-resolved.service</code> są już włączone domyślnie. Zatem sporo
informacji zawartych w tych napisanych przeze mnie artykułach już niekoniecznie może znaleźć
obecnie zastosowanie. Dlatego też pomyślałem, że nadszedł już czas, by ździebko zaktualizować tamte
wpisy. Ostatecznie stanęło jednak na tym, by w oparciu o te artykuły napisać kompletnie nowy tekst
na temat szyfrowania zapytań DNS na linux przy wykorzystaniu oprogramowania <code>dnscrypt-proxy</code> oraz
<code>dnsmasq</code> i zawrzeć w nim te wszystkie ciekawsze informacje, które udało mi się pozyskać przez te
ostatnie lata w kwestii poprawy bezpieczeństwa i prywatności przy przeglądaniu stron WWW.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-09-19T14:13:00&#43;02:00">Opublikowano: 19/09/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/systemowy-gpg-gnupg-w-thunderbird-78-na-linux/">Systemowy GPG/GnuPG w Thunderbird 78&#43; na linux</a></h1>
	<div class="entry__content"><p>Jakiś już czas temu Mozilla ogłosiła, że Thunderbird od wersji 78 będzie posiadał natywne wsparcie
dla szyfrowania wiadomości z wykorzystaniem kluczy GPG/PGP, przez co <a href="https://enigmail.net/index.php/en/">dodatek Enigmail</a> będzie
już zwyczajnie zbędny. Dziś z kolei czytam sobie o <a href="https://blog.thunderbird.net/2020/09/openpgp-in-thunderbird-78/">zakończeniu wsparcia dla wersji 68</a> tego
klienta pocztowego, które będzie miało miejsce z końcem września 2020, czyli został już niespełna
miesiąc i ta starsza wersja Thunderbird'a nie będzie już dostawać łat bezpieczeństwa. Pewne jest
zatem, że dystrybucje linux'a w niedługim czasie pchną wersję 78 do głównych repozytoriów. W
Debianie, wersja 78 Thunderbird'a od dłuższego czasu jest dostępna w gałęzi eksperymentalnej i można
było ją już wcześniej sobie zainstalować, jeśli ktoś wyrażał taką chęć. Gdy ja ostatni raz
testowałem wersję 78, to nie była ona zbytnio do użytku ale wygląda na to, że większość
niedogodności, których mi się udało doświadczyć, została już wyeliminowana. Pozostał w zasadzie
jeden problem, tj. Thunderbird domyślnie używa własnego keyring'a kluczy GPG/PGP, w efekcie czego
systemowy GPG/GnuPG nie jest w ogóle wykorzystywany. Taki san rzeczy sprawia, że będziemy mieć dwie
różne bazy danych kluczy (jedna dla Thunderbird'a, a druga dla reszty linux'a), co może trochę
irytować. Na szczęście jest opcja wymuszenia na TB, by korzystał on z systemowego keyring'a kluczy
GPG/PGP i celem tego artykułu jest pokazanie właśnie jak tego typu zabieg przeprowadzić.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-09-07T20:15:00&#43;02:00">Opublikowano: 07/09/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn/">Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)</a></h1>
	<div class="entry__content"><p>Parę dni temu <a href="https://forum.dug.net.pl/viewtopic.php?id=31514">na forum dug.net.pl pojawiło się zapytanie</a> dotyczące skonfigurowania linux'a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux'a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy <code>iptables</code> / <code>nftables</code> ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-09-02T18:36:00&#43;02:00">Opublikowano: 02/09/2020</time>
	<time class="entry__meta-lastmod meta-lastmod" datetime="2023-03-01T08:30:00&#43;01:00">Zaktualizowano: 01/03/2023</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/zarzadzanie-raspberry-pi-4b-z-libreelec-przez-vnc-spice/">Zarządzanie Raspberry Pi 4B z LibreELEC przez VNC/SPICE</a></h1>
	<div class="entry__content"><p>Do konfiguracji <a href="https://libreelec.tv/">systemu LibreELEC</a>, który jest zainstalowany na moim Raspberry Pi 4B nie
potrzebuję żadnego monitora czy wyświetlacza, a wszystkie prace administracyjne związane z tym
małym komputerem ogarniam po SSH. Niemniej jednak, są pewne rzeczy, których się po SSH nie da
skonfigurować. Chodzi generalnie o konfigurację Kodi i sprawy związane z domowa wideoteką. Ten
Raspberry Pi 4B jest podłączony do TV, zatem bez problemu można przez graficzny interfejs Kodi
skonfigurować to, co potrzeba. Niemniej jednak konfigurowanie Kodi przez aplikację na Androida
(<a href="https://kodi.wiki/view/Kore">Kore</a>) nie należy do najłatwiejszych zadań. Nie uśmiecha mi się też ciągle latać z myszą i
klawiaturą w celu podłączania ich do portów USB maliny. Nie mam też w zasadzie zewnętrznego
monitora HDMI, bo od lat używam jedynie laptopów. Pomyślałem zatem, by zrobić użytek z protokołu
<a href="https://en.wikipedia.org/wiki/Virtual_Network_Computing">VNC</a>/<a href="https://en.wikipedia.org/wiki/Simple_Protocol_for_Independent_Computing_Environments">SPICE</a> i przesłać obraz z Raspberry Pi 4B przez sieć do mojego laptopa. W ten sposób
odpadłoby mi ciągłe przemieszczanie się między pokojami i byłbym w stanie podejrzeć obraz TV na
ekranie monitora w moim laptopie przy jednoczesnym zachowaniu możliwości używania myszy i
klawiatury, co by mi bardzo zaoszczędziło czas przy konfiguracji Kodi.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-08-25T20:08:00&#43;02:00">Opublikowano: 25/08/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/raspberrypi/" rel="category">RaspberryPi</a>, 
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/raspberry-pi-libreelec-kodi-i-zdalne-logi-via-rsyslog/">Raspberry Pi, LibreELEC, Kodi i zdalne logi via rsyslog</a></h1>
	<div class="entry__content"><p>Parę lat temu, gdy pojawił się u mnie w domu bezprzewodowy router WiFi, postanowiłem wgrać na niego
linux'a w postaci OpenWRT. Pierwszym kluczowym elementem konfiguracyjnym tego urządzenia było
<a href="https://morfikov.github.io/post/logread-czyli-system-logowania-w-openwrt/">przesłanie jego logów systemowych przez sieć</a> do mojego laptopa, tak by wszystkie
zarejestrowane komunikaty zostały wyświetlone na konsoli mojego komputera z zainstalowanym Debianem.
W ten sposób nie musiałem się co chwila logować na router po SSH (czy też przez panel webowy), by
sprawdzić czy aby na pewno z tym urządzeniem jest wszystko w porządku. Teraz, po nabyciu Raspberry
Pi 4B i wgraniu na niego <a href="https://libreelec.tv/">LibreELEC</a> z preinstalowanym Kodi, mam dokładnie to samo zadanie do
zrealizowania. Trzeba zatem znaleźć sposób na przesłanie wszystkich logów generowanych przez system
LibreELEC do demona <code>rsyslogd</code> , który jest uruchomiony na zdalnej maszynie.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-08-25T19:21:00&#43;02:00">Opublikowano: 25/08/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/raspberrypi/" rel="category">RaspberryPi</a>, 
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-wlaczyc-stabilne-adresy-prywatne-w-ipv6-na-linux/">Jak włączyć stabilne adresy prywatne w IPv6 na linux</a></h1>
	<div class="entry__content"><p>Jakiś już czas temu opisywałem <a href="https://morfikov.github.io/post/jak-wlaczyc-ipv6-privacy-extensions-w-debianie-slaac/">jak włączyć rozszerzenia prywatności IPv6 na Debianie</a> (IPv6
Privacy Extensions) w przypadku korzystania z mechanizmu automatycznej konfiguracji adresacji
hostów SLAAC (StateLess Address AutoConfiguration). Miało to za zadanie poprawić nieco prywatność
osób podłączonych do internetu za sprawą protokołu IPv6, bo generowane adresy IP standardowo
zawierają adresy MAC kart sieciowych (<a href="https://en.wikipedia.org/wiki/MAC_address">identyfikator EUI64</a>). Parę dni temu dowiedziałem się, że
w linux można również aktywować inny mechanizm zwany stabilnymi adresami prywatnymi
(<a href="https://tools.ietf.org/html/rfc7217">stable-privacy addresses</a>), które to wykorzystują inny system przy generowaniu identyfikatorów
interfejsów sieciowych. Ten mechanizm sprawia, że część adresu IPv6 odpowiedzialna za identyfikację
hosta ma losowe, choć stabilne wartości, które nie mają nic wspólnego z adresem MAC karty sieciowej
naszego komputera. W ten sposób możemy ukrócić śledzenie nas w sieci na podstawie adresu IPv6.
Poniższy artykuł ma za zadanie pomóc skonfigurować nam te stabilne adresy prywatne na linux oraz
pokazać w jaki sposób są one w stanie pomóc naszej prywatności.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-08-19T19:31:00&#43;02:00">Opublikowano: 19/08/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/jak-odszyfrowac-linux-przy-pomocy-telefonu-z-androidem/">Jak odszyfrować linux&#39;a przy pomocy telefonu z Androidem</a></h1>
	<div class="entry__content"><p>Zaszyfrowane systemy (desktopy/laptopy) mają jeden poważny problem, gdy chodzi o zapewnianie
bezpieczeństwa chronionym plikom przechowywanym na dyskach twardych. Gdy siedzimy obok naszej
maszyny, możemy czuć się bezpiecznie, bo przecież nikt nie może się włamać do jej systemu bez
naszej wiedzy. Nawet jeśli ktoś będzie próbował się dostać do naszego PC, to istnieje spora szansa,
że takie działanie zostałoby natychmiast przez nas wykryte, przez co moglibyśmy w odpowiedni sposób
zareagować na zaistniałe zagrożenie. Co jednak w przypadku, gdy zostawiamy przykładowo naszego
laptopa samego? Nawet jeśli zablokujemy mu ekran, wyłączymy go albo zahibernujemy, to ta maszyna
wciąż nie jest odpowiednio zabezpieczona, by uniemożliwić osobom postronnym dostęp do naszych
wrażliwych danych. Problem leży w fizycznym dostępie do sprzętu, który ludzie mogą uzyskać, gdy nas
nie ma w pobliżu naszego komputera. W taki sposób osoby trzecie mogą wykorzystać fakt, że tracimy
maszynę z oczu i być w stanie zastawić na nas różne pułapki. By uniknąć zagrożenia związanego z
zostawieniem laptopa/desktopa bez nadzoru, nie możemy w zasadzie pozostawiać tego urządzenia samego,
co jest zadaniem praktycznie nie do wykonania. Komputery stacjonarne czy nawet laptopy nie są
urządzeniami o małych gabarytach i zwykle nie możemy ich wszędzie zabrać ze sobą, w przeciwieństwie
do smartfonów. Postanowiłem zatem tak skonfigurować swojego linux'a, by jego zaszyfrowany dysk
(LUKS + LVM) można było odszyfrować jedynie przy pomocy mojego telefonu z Androidem, z którym w
zasadzie się nie rozstaję.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-08-15T02:43:00&#43;02:00">Opublikowano: 15/08/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>, 
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/android/" rel="category">Android</a>
	</span>
</div>
	</div>
</article>
				</div>
			
				<div class="card card--2col">
					<article class="entry card__box block">
	<h1 class="entry__title title-excerpt"><a class="entry__title-link" href="https://morfikov.github.io/post/migracja-bloga-z-jekyll-na-hugo-i-jego-publikacja-w-github-pages/">Migracja bloga z Jekyll na Hugo i jego publikacja w GitHub Pages</a></h1>
	<div class="entry__content"><p>Prawdopodobnie zauważyliście drobne zmiany w wyglądzie tego bloga oraz pewnie też cześć osób miała
w ostatnim czasie problemy z uzyskaniem do niego dostępu. Odpowiedzialne za zaistniałą sytuację są
<a href="https://docs.github.com/en/github/working-with-github-pages/about-github-pages#usage-limits">limity narzucone przez GitHub Pages</a>. Zakładają one maksymalny rozmiar repozytorium pod stronę
WWW w granicach 1 GiB oraz czas budowania takiego serwisu krótszy niż 10 minut. Limit miejsca na
pliki przekroczony został w zasadzie w chwili przeniesienia bloga WordPress na GitHub Pages.
Natomiast parę dni temu został przekroczony limit czasu budowania tego projektu. Do momentu
transformacji, niniejszy blog działał w oparciu o <a href="https://jekyllrb.com/">Jekyll</a>, który generował w zasadzie statyczny
kod HTML ze zwykłych plików tekstowych (np. artykuły pisane w <a href="https://www.markdownguide.org/">MarkDown</a>). <a href="https://pages.github.com/">GitHub Pages
posiada wsparcie dla Jekyll</a>, przez co taką stronę WWW można bardzo prosto wdrożyć. Niemniej
jednak, cały ten mechanizm generowania projektu w obrębie infrastruktury GitHub'a zajmuje bardzo
dużo czasu. Po rozmowie z supportem okazało się, że gdyby chodziło o miejsce na pliki, to mogli by
nagiąć reguły i nie było by problemu ale nie dadzą rady tego zrobić w przypadku przekroczenia czasu
generowania projektu. Dlatego też trzeba było zrezygnować z Jekyll'a i poszukać dla niego jakiejś
alternatywy. Padło na <a href="https://gohugo.io/">Hugo</a>, który w odróżnieniu od Jekyll'a nie jest jako tako wspierany przez
GitHub i by <a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">stronę wygenerowaną przez Hugo podpiąć pod GitHub Pages</a> trzeba się trochę wysilić,
bo ten proces nie jest automatyczny i właśnie o tym jak dokonać migracji z Jekyll na Hugo w
kontekście GitHub Pages będzie ten poniższy artykuł.</p></div>
	<div class="entry__meta meta mt tar">
	<time class="entry__meta-published meta-published" datetime="2020-08-13T23:50:00&#43;02:00">Opublikowano: 13/08/2020</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</div>
	</div>
</article>
				</div>
			
		</div>
	</main>
	
<div class="pagination block">
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/tags/debian/">1</a>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/tags/debian/page/2/">2</a>
				<span class="pagination__item pagination__item--active" data-total="15">3</span>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/tags/debian/page/4/">4</a>
			<span class="pagination__item pagination__item--gap">&hellip;</span>
				<a class="pagination__item pagination__item--desktop" href="https://morfikov.github.io/tags/debian/page/15/">15</a>
</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://mastodon.social/@morfik">
			<svg class="social__icon" aria-label="Mastodon" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M416 197c0-74-49-96-49-96-42-22-172-24-222 0 0 0-49 22-49 96v59c2 72 14 145 81 162 33 9 89 18 140-6l-2-27s-27 7-58 7c-74 2-67-39-70-52 0 0 51 17 137 6 42-6 80-32 85-56 8-38 7-93 7-93zm-58 96h-35v-88c0-18-8-27-23-27-18 0-27 11-27 33v47h-34v-47c0-22-9-33-27-33-15 0-23 9-23 27v88h-35v-91c0-18 5-60 52-60 39 0 50 37 50 37s10-37 50-37c45 0 52 42 52 60v91z"/></svg>
		</a>
</div>
	<div class="footer__copyright">© 2025 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
const images = Array.from(document.querySelectorAll(".entry__content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null,  
    background: 'rgba(0, 0, 0, 0.8)'
  });
});
</script>
</body>
</html>
