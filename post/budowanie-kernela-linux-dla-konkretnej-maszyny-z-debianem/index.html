<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Budowanie kernela linux dla konkretnej maszyny z Debianem | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Budowanie kernela linux dla konkretnej maszyny z Debianem" />
<meta property="og:description" content="Każda maszyna działająca pod kontrolą dystrybucji linux ma na swoim pokładzie kernel, czyli jądro
operacyjne, które zarządza praktycznie każdym aspektem pracy takiego komputera. W dystrybucji
Debian, kernel jest dostarczany w pakietach mających nazwy zaczynające się od linux-image-*.
Te pakiety są budowane przez odpowiednie osoby z zespołu Debiana i udostępniane do łatwej
instalacji użytkownikowi końcowemu. Niemniej jednak, taki kernel ma za zadanie działać na jak
największej ilości komputerów, a przez to posiada całą masę modułów, które na naszej maszynie nigdy
nie będą wykorzystane. Ten fakt nie wpływa w jakimś ogromnym stopniu na pracę maszyny, ale gdy
później zachodzi potrzeba skonfigurowania kernela w nieco inny sposób, np. włączenie jednej czy
dwóch opcji czy też nałożenie patch&#39;a, który nie został zaaplikowany przez dev&#39;ów Debiana, to
trzeba taki kernel na nowo skompilować już samodzielnie, a to zajmie nam bardzo dużo czasu. Zamiast
tego można pokusić się o przygotowanie kernela pod konkretny hardware wyłączając przy tym całą masę
zbędnych rzeczy i ograniczając przy tym czas jaki jest potrzebny na zbudowanie całego jądra
operacyjnego. Czy istnieje jakiś prosty sposób, by taki kernel zbudować sobie samemu mając przy tym
minimalną wiedzę co do opcji kernela, które mogą nas przysporzyć o ból... głowy? Okazuje się, że
tak i w tym artykule prześledzimy sobie cały ten proces." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/budowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem/" />
<meta property="article:published_time" content="2018-12-27T22:14:00+00:00" />
<meta property="article:modified_time" content="2021-04-30T06:00:00+02:00" />

		<meta itemprop="name" content="Budowanie kernela linux dla konkretnej maszyny z Debianem">
<meta itemprop="description" content="Każda maszyna działająca pod kontrolą dystrybucji linux ma na swoim pokładzie kernel, czyli jądro
operacyjne, które zarządza praktycznie każdym aspektem pracy takiego komputera. W dystrybucji
Debian, kernel jest dostarczany w pakietach mających nazwy zaczynające się od linux-image-*.
Te pakiety są budowane przez odpowiednie osoby z zespołu Debiana i udostępniane do łatwej
instalacji użytkownikowi końcowemu. Niemniej jednak, taki kernel ma za zadanie działać na jak
największej ilości komputerów, a przez to posiada całą masę modułów, które na naszej maszynie nigdy
nie będą wykorzystane. Ten fakt nie wpływa w jakimś ogromnym stopniu na pracę maszyny, ale gdy
później zachodzi potrzeba skonfigurowania kernela w nieco inny sposób, np. włączenie jednej czy
dwóch opcji czy też nałożenie patch&#39;a, który nie został zaaplikowany przez dev&#39;ów Debiana, to
trzeba taki kernel na nowo skompilować już samodzielnie, a to zajmie nam bardzo dużo czasu. Zamiast
tego można pokusić się o przygotowanie kernela pod konkretny hardware wyłączając przy tym całą masę
zbędnych rzeczy i ograniczając przy tym czas jaki jest potrzebny na zbudowanie całego jądra
operacyjnego. Czy istnieje jakiś prosty sposób, by taki kernel zbudować sobie samemu mając przy tym
minimalną wiedzę co do opcji kernela, które mogą nas przysporzyć o ból... głowy? Okazuje się, że
tak i w tym artykule prześledzimy sobie cały ten proces.">
<meta itemprop="datePublished" content="2018-12-27T22:14:00+00:00" />
<meta itemprop="dateModified" content="2021-04-30T06:00:00+02:00" />
<meta itemprop="wordCount" content="4545">



<meta itemprop="keywords" content="debian,kernel,kompilacja," />

		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Budowanie kernela linux dla konkretnej maszyny z Debianem"/>
<meta name="twitter:description" content="Każda maszyna działająca pod kontrolą dystrybucji linux ma na swoim pokładzie kernel, czyli jądro
operacyjne, które zarządza praktycznie każdym aspektem pracy takiego komputera. W dystrybucji
Debian, kernel jest dostarczany w pakietach mających nazwy zaczynające się od linux-image-*.
Te pakiety są budowane przez odpowiednie osoby z zespołu Debiana i udostępniane do łatwej
instalacji użytkownikowi końcowemu. Niemniej jednak, taki kernel ma za zadanie działać na jak
największej ilości komputerów, a przez to posiada całą masę modułów, które na naszej maszynie nigdy
nie będą wykorzystane. Ten fakt nie wpływa w jakimś ogromnym stopniu na pracę maszyny, ale gdy
później zachodzi potrzeba skonfigurowania kernela w nieco inny sposób, np. włączenie jednej czy
dwóch opcji czy też nałożenie patch&#39;a, który nie został zaaplikowany przez dev&#39;ów Debiana, to
trzeba taki kernel na nowo skompilować już samodzielnie, a to zajmie nam bardzo dużo czasu. Zamiast
tego można pokusić się o przygotowanie kernela pod konkretny hardware wyłączając przy tym całą masę
zbędnych rzeczy i ograniczając przy tym czas jaki jest potrzebny na zbudowanie całego jądra
operacyjnego. Czy istnieje jakiś prosty sposób, by taki kernel zbudować sobie samemu mając przy tym
minimalną wiedzę co do opcji kernela, które mogą nas przysporzyć o ból... głowy? Okazuje się, że
tak i w tym artykule prześledzimy sobie cały ten proces."/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Budowanie kernela linux dla konkretnej maszyny z Debianem</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2018-12-27T22:14:00Z">Opublikowano: 27/12/2018</time>
	<time class="entry__meta-lastmod meta-lastmod" datetime="2021-04-30T06:00:00&#43;02:00">Zaktualizowano: 30/04/2021</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Budowanie kernela linux dla konkretnej maszyny z Debianem</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#źródła-kernela-oraz-zależności">Źródła kernela oraz zależności</a></li>
    <li><a href="#wstępna-konfiguracja-systemu-i-zmienne-środowiskowe">Wstępna konfiguracja systemu i zmienne środowiskowe</a>
      <ol>
        <li><a href="#skrypt-scriptspackagemkdebian-oraz-plik-debianrules">Skrypt scripts/package/mkdebian oraz plik debian/rules</a></li>
        <li><a href="#zmienne-cflags-cppflags-cxxflags-i-ldflags">Zmienne $CFLAGS, $CPPFLAGS, $CXXFLAGS i $LDFLAGS</a>
          <ol>
            <li><a href="#flagi-kompilatora">Flagi kompilatora</a></li>
            <li><a href="#flagi-linkera">Flagi linkera</a></li>
          </ol>
        </li>
        <li><a href="#hardening-kernela">Hardening kernela</a>
          <ol>
            <li><a href="#gcc-plugins">GCC plugins</a></li>
          </ol>
        </li>
        <li><a href="#problemy-z-xconfig">Problemy z xconfig</a></li>
        <li><a href="#ccache">ccache</a></li>
        <li><a href="#wersja-gccgcpp">Wersja gcc/g++/cpp</a></li>
      </ol>
    </li>
    <li><a href="#pozyskiwanie-informacji-o-sprzęcie">Pozyskiwanie informacji o sprzęcie</a></li>
    <li><a href="#make-localyesconfig">make localyesconfig</a></li>
    <li><a href="#make-xconfig">make xconfig</a></li>
    <li><a href="#budowanie-kernela-linux">Budowanie kernela linux</a></li>
    <li><a href="#funkcjonalność-kernela-wkompilowana-na-stałe-czy-jako-moduł">Funkcjonalność kernela wkompilowana na stałe czy jako moduł</a>
      <ol>
        <li><a href="#rozmiar-kernela-i-obrazu-initramfsinitrd">Rozmiar kernela i obrazu initramfs/initrd</a></li>
        <li><a href="#jaka-funkcjonalność-kernela-została-wkompilowana-na-stałe">Jaka funkcjonalność kernela została wkompilowana na stałe</a></li>
        <li><a href="#parametry-modułów-wkompilowanych-na-stałe">Parametry modułów wkompilowanych na stałe</a></li>
        <li><a href="#całkowite-wyłączenie-obsługi-modułów">Całkowite wyłączenie obsługi modułów</a>
          <ol>
            <li><a href="#wyłączenie-możliwości-ładowania-modułów-podczas-pracy-systemu">Wyłączenie możliwości ładowania modułów podczas pracy systemu</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#nakładanie-łatek-na-kernel-patch">Nakładanie łatek na kernel (patch)</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Każda maszyna działająca pod kontrolą dystrybucji linux ma na swoim pokładzie kernel, czyli jądro
operacyjne, które zarządza praktycznie każdym aspektem pracy takiego komputera. W dystrybucji
Debian, kernel jest dostarczany w pakietach mających nazwy zaczynające się od <code>linux-image-*</code>.
Te pakiety są budowane przez odpowiednie osoby z zespołu Debiana i udostępniane do łatwej
instalacji użytkownikowi końcowemu. Niemniej jednak, taki kernel ma za zadanie działać na jak
największej ilości komputerów, a przez to posiada całą masę modułów, które na naszej maszynie nigdy
nie będą wykorzystane. Ten fakt nie wpływa w jakimś ogromnym stopniu na pracę maszyny, ale gdy
później zachodzi potrzeba skonfigurowania kernela w nieco inny sposób, np. włączenie jednej czy
dwóch opcji czy też nałożenie patch'a, który nie został zaaplikowany przez dev'ów Debiana, to
trzeba taki kernel na nowo skompilować już samodzielnie, a to zajmie nam bardzo dużo czasu. Zamiast
tego można pokusić się o przygotowanie kernela pod konkretny hardware wyłączając przy tym całą masę
zbędnych rzeczy i ograniczając przy tym czas jaki jest potrzebny na zbudowanie całego jądra
operacyjnego. Czy istnieje jakiś prosty sposób, by taki kernel zbudować sobie samemu mając przy tym
minimalną wiedzę co do opcji kernela, które mogą nas przysporzyć o ból... głowy? Okazuje się, że
tak i w tym artykule prześledzimy sobie cały ten proces.</p>
<h2 id="źródła-kernela-oraz-zależności">Źródła kernela oraz zależności</h2>
<p>Przede wszystkim, by móc bawić się w kompilację kernela musimy sobie załatwić jego źródła, a te z
kolei możemy albo pozyskać z dystrybucji Debiana, albo też bezpośrednio z <a href="https://www.kernel.org/">kernel.org</a>. Bez
znaczenia, na które źródła się zdecydujemy -- one są prawie identyczne, zakładając, że numerki się
zgadzają. Prawie, a to dlatego, że Debianowy kernel zawiera szereg łat bezpieczeństwa, które
domyślnie będą zaaplikowane już. Jeśli chcemy goły kernel, to musimy pobrać go z oficjalnej strony
kernela. Jeśli wybierzemy źródła kernela Debiana, to w terminalu wydajemy poniższe polecenie:</p>
<pre><code># aptitude install linux-source
</code></pre>
<p>Po pobraniu paczki, źródła zostaną zainstalowane w katalogu <code>/usr/src/linux-*/</code>, gdzie <code>*</code> oznacza
numerek kernela.</p>
<p>Musimy doinstalować także szereg zależności niezbędnych w procesie budowania źródeł kernela:</p>
<pre><code># aptitude install \
 build-essential \
 bc \
 kmod \
 cpio \
 flex \
 libncurses5-dev \
 libssl-dev \
 libelf-dev \
 qt5-default \
</code></pre>
<h2 id="wstępna-konfiguracja-systemu-i-zmienne-środowiskowe">Wstępna konfiguracja systemu i zmienne środowiskowe</h2>
<p>Okazuje się, że w przypadku budowania paczki z kernelem dla Debiana trzeba nieco inaczej podejść
do sprawy eksportu zmiennych środowiskowych, min. przy ustawianiu flag dla kompilatora i linkera.</p>
<p>Z reguły ludzie też starają się eksportować zmienną <code>$ARCH</code> w konfiguracji shell'a tak, by proces
kompilacji mógł sobie ją podebrać. Zmienna <code>$ARCH</code> precyzuje architekturę naszego systemu i będzie
ona widoczna w procesie kompilacji ale nie powinniśmy jej w ten sposób eksportować. Chodzi o to, że
niektóre narzędzia Debiana mogą zostać wprowadzone w błąd jeśli ta zmienna zostanie w konfiguracji
shell'a ustawiona. Poniżej jest przykład aktualizacji systemu, a konkretnie jednej z paczek DKMS:</p>
<pre><code># cat /var/lib/dkms/xtables-addons/3.2/build/make.log
DKMS make.log for xtables-addons-3.2 for kernel 4.19.13-amd64-morficzny (x86_64)
Thu  3 Jan 10:57:49 CET 2019
make: Entering directory '/usr/src/linux-headers-4.19.13-amd64-morficzny'
Makefile:618: arch//Makefile: No such file or directory
make: *** No rule to make target 'arch//Makefile'.  Stop.
make: Leaving directory '/usr/src/linux-headers-4.19.13-amd64-morficzny'
</code></pre>
<p>I jak widać z powyższego błędu, proces kompilacji tego modułu się nie powiódł bo plik
<code>arch//Makefile</code> nie został odnaleziony. Żeby ten błąd fix'nąć, trzeba zmienną <code>$ARCH</code> usunąć ze
środowiska przez <code>unset</code> albo zwyczajnie jej nie eksportować.</p>
<p>Zamiast eksportować zmienną <code>$ARCH</code> globalnie, lepiej jest wrzucić ją do polecenia z <code>make</code> ,
przykładowo:</p>
<pre><code>make ARCH=&quot;x86_64&quot; -j2 bindeb-pkg
</code></pre>
<p>Natomiast jeśli chodzi o flagi kompilatora i linkera, to ten temat jest nieco skompilowany.</p>
<h3 id="skrypt-scriptspackagemkdebian-oraz-plik-debianrules">Skrypt scripts/package/mkdebian oraz plik debian/rules</h3>
<p>Przede wszystkim, przy budowaniu targetu <code>bindeb-pkg</code> , tworzona jest bardzo podstawowa
konfiguracja dla Debianowych narzędzi w podkatalogu <code>debian/</code> . Chwilę po wywołaniu polecenia
<code>make bindeb-pkg</code> wołany jest skrypt <code>scripts/package/mkdebian</code> , który to ma za zadanie uzupełnić
szereg plików w oparciu o pewne zmienne (min. o tę ustawioną wcześniej zmienną <code>$ARCH</code> ). Te pliki
są przepisywane za każdym razem ilekroć wołany jest <code>make bindeb-pkg</code> i generalnie to tych plików
nie powinniśmy edytować ręcznie. Skryptu w zasadzie też nie ma po co ruszać.</p>
<h3 id="zmienne-cflags-cppflags-cxxflags-i-ldflags">Zmienne $CFLAGS, $CPPFLAGS, $CXXFLAGS i $LDFLAGS</h3>
<p>Technicznie rzecz biorąc, to proces budowania paczki z kernelem jest niemal taki sam jak w
przypadku <a href="https://morfikov.github.io/post/poradnik-maintainera-czyli-jak-zrobic-pakiet-deb/">budowania każdej innej paczki .deb</a> dla dystrybucji Debiana. Jedyną różnicą jest fakt,
że kernel nie jest standardową <a href="https://pl.wikipedia.org/wiki/Executable_and_Linkable_Format">binarką ELF</a>.</p>
<p>Gdy buduje się zwykłe paczki różnych aplikacji, to w pliku <code>debian/rules</code> ustawia się kilka
zmiennych m.in. zmienną <code>$DEB_BUILD_MAINT_OPTIONS</code> , która to konfiguruje wstępnie zmienne dla
kompilatora i linkera. W zasadzie wszystkie standardowe flagi używane przy kompilacji mogą zostać
skonfigurowane przez tę zmienną <code>$DEB_BUILD_MAINT_OPTIONS</code> , przykładowo:</p>
<pre><code>export DEB_BUILD_MAINT_OPTIONS = hardening=+all
DPKG_EXPORT_BUILDFLAGS = 1
include /usr/share/dpkg/buildflags.mk
</code></pre>
<p>Przynajmniej tak jest w przypadku zwykłych aplikacji. Jeśli chodzi zaś o proces kompilowania samego
kernela, to ustawianie zmiennej <code>$DEB_BUILD_MAINT_OPTIONS</code> nic nam nie da. Podobnie jak i ręczne
ustawianie zmiennych <code>$CFLAGS</code> , <code>$CPPFLAGS</code> , <code>$CXXFLAGS</code> oraz <code>$LDFLAGS</code> w konfiguracji shell'a,
bo nie będą brane w ogóle pod uwagę.</p>
<p>Jeśli już ktoś chciałby te zmienne ustawić, to musiałbym to zrobić przez plik <code>debian/rules</code> , tj.
za sprawą skryptu <code>scripts/package/mkdebian</code> dodając zaraz pod:</p>
<pre><code>...
cat &lt;&lt;EOF &gt; debian/rules
#!$(command -v $MAKE) -f
...
</code></pre>
<p>poniższe linijki kodu:</p>
<pre><code>CFLAGS   += -march=native -O2 -pipe -Wall -fstack-clash-protection -fpic
CXXFLAGS += -march=native -O2 -pipe -Wall -fstack-clash-protection -fpic
CPPFLAGS += -march=native -O2 -pipe -Wall -fstack-clash-protection -fpic
LDFLAGS  += -Wl,-O2 -Wl,--as-needed -Wl,-z,defs -Wl,-shared
</code></pre>
<p>To jakie flagi faktycznie zostaną ustawione można podejrzeć przez dodanie do pliku <code>debian/rules</code>
(za sprawą skryptu) poniższego polecenia w targecie <code>build</code> :</p>
<pre><code>...
build:
    dpkg-buildflags --status
...
</code></pre>
<p>Narzędzie <code>dpkg-buildflags</code> jest w stanie ustawić te poniższe flagi:</p>
<ul>
<li><code>$CFLAGS</code> określa flagi dla kompilatora C. Domyślne flagi uwzględniają <code>-g</code> oraz <code>-O2</code> , chyba,
że <code>DEB_BUILD_MAINT_OPTIONS</code> ma zdefiniowane <code>noopt</code> i wtedy jest używany <code>-O0</code> .</li>
<li><code>$CXXFLAGS</code> określa flagi dla kompilatora C++. Takie same jak <code>$CFLAGS</code> .</li>
<li><code>$CPPFLAGS</code> określa flagi preprocesora C (<code>C</code> <code>P</code>re<code>P</code>rocessor). Domyślnie puste.</li>
<li><code>$FCFLAGS</code> określa flagi kompilatora Fortran 9x . Takie same jak <code>$CFLAGS</code></li>
<li><code>$FFLAGS</code> określa flagi kompilatora Fortran 77. Podzbiór <code>$CFLAGS</code> .</li>
<li><code>$GCJFLAGS</code> określa flagi kompilatora GNU Java (gcj). Podzbiór <code>$CFLAGS</code> .</li>
<li><code>$LDFLAGS</code> określa flagi linkera. Domyślnie puste.</li>
<li><code>$OBJCFLAGS</code> określa flagi kompilatora obiektowego C. Takie same jak <code>$CFLAGS</code> .</li>
<li><code>$OBJCXXFLAGS</code> określa flagi kompilatora obiektowego C++. Takie same jak <code>$CXXFLAGS</code> .</li>
</ul>
<p>Jeśli teraz odpalilibyśmy proces kompilacji, to <code>dpkg-buildflags --status</code> zwróci nam coś na wzór
poniższego kodu:</p>
<pre><code>...
dpkg-buildflags --status
dpkg-buildflags: status: environment variable DEB_BUILD_OPTIONS=parallel=2
dpkg-buildflags: status: environment variable DEB_HOST_ARCH=amd64
dpkg-buildflags: status: vendor is Debian
dpkg-buildflags: status: future features: lfs=no
dpkg-buildflags: status: hardening features: bindnow=no format=yes fortify=yes pie=yes relro=yes stackprotector=yes stackprotectorstrong=yes
dpkg-buildflags: status: qa features: bug=no canary=no
dpkg-buildflags: status: reproducible features: fixdebugpath=yes fixfilepath=no timeless=yes
dpkg-buildflags: status: sanitize features: address=no leak=no thread=no undefined=no
dpkg-buildflags: status: CFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong -Wformat -Werror=format-security
dpkg-buildflags: status: CPPFLAGS [vendor]: -Wdate-time -D_FORTIFY_SOURCE=2
dpkg-buildflags: status: CXXFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong -Wformat -Werror=format-security
dpkg-buildflags: status: FCFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong
dpkg-buildflags: status: FFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong
dpkg-buildflags: status: GCJFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong
dpkg-buildflags: status: LDFLAGS [vendor]: -Wl,-z,relro
dpkg-buildflags: status: OBJCFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong -Wformat -Werror=format-security
dpkg-buildflags: status: OBJCXXFLAGS [vendor]: -g -O2 -fdebug-prefix-map=/usr/src/linux-source-4.19=. -fstack-protector-strong -Wformat -Werror=format-security
...
</code></pre>
<p>Przez konfigurację obszarów cech (feature areas) można wpływać ma to jakie flagi zostaną ustawione.
To jakie flagi te obszary cech definiują zostało dokładnie opisane
w <a href="https://manpages.debian.org/unstable/dpkg-dev/dpkg-buildflags.1.en.html">manualu dpkg-buildflags</a>.</p>
<h4 id="flagi-kompilatora">Flagi kompilatora</h4>
<p>Poniżej jest krótka rozpiska <a href="http://man7.org/linux/man-pages/man1/gcc.1.html">flag kompilatora</a>, które są wykorzystywane przy budowaniu kodu
źródłowego:</p>
<ul>
<li>flaga <code>-march=</code> określa dla jakiego procesora jest budowany kod. W przypadku, gdy kompilujemy
kernel (czy w ogóle jakiś kod) tylko i wyłącznie dla naszej maszyny, to nie musimy sobie zawracać
głowy właściwościami jej procesora. W takim przypadku można tutaj określić <code>native</code> i kompilator
już sobie obada ten procesor i odpowiednie flagi dobierze sam.</li>
<li>flaga <code>-O</code> odpowiada za stopień optymalizacji kodu. Stopni jest kilka: <code>0</code> , <code>1</code> , <code>2</code> , <code>3</code> ,
<code>s</code> , <code>g</code> oraz <code>fast</code> . <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">Każdy poziom jest nacechowany innymi flagami</a> ale tym zalecanym jest
poziom <code>2</code>.</li>
<li>flaga <code>-pipe</code> nie ma jako takiego przełożenia na generowany kod ale może uczynić proces
kompilacji szybszym przez wykorzystanie potoków (pipe) zamiast fizycznych plików tymczasowych.
Takie rozwiązanie wiąże się jednak z większym apetytem procesu kompilacji na pamięć operacyjną i
nie powinno się tej flagi stosować, gdy nasz komputer nie ma dostatecznie dużo pamięci, by sobie z
procesem kompilacji poradzić, bo kompilator może zostać ubity przez system.</li>
<li>flaga <code>-g</code> tworzy informacje wykorzystywane przy debugowaniu w natywnym dla systemu operacyjnego
formacie (stabs, COFF, XCOFF lub DWARF).</li>
<li>flaga <code>-Wall</code> sprawa, że wszystkie ostrzeżenia w procesie kompilacji będą widoczne.</li>
<li>flagi <code>-Werror=*</code> odpowiadają za podniesienie pewnych grup ostrzeżeń do rangi błędu, co
efektywnie kończy proces kompilacji w przypadku, gdy takie ostrzeżenie zostanie odnotowane.</li>
<li>flaga <code>-Wformat</code> sprawdza czy wywołania <code>printf</code> i <code>scanf</code>, itp. mają określony odpowiedni format.</li>
<li>flaga <code>-fstack-protector-strong</code> ma za zadanie chronić stos przed jego celowym uszkodzeniem
(<a href="https://en.wikipedia.org/wiki/Stack_buffer_overflow">stack smashing/stack buffer overflow</a>).</li>
<li>flaga <code>-fstack-clash-protection</code> ma za zadanie chronić stos przed atakami <a href="https://blog.qualys.com/securitylabs/2017/06/19/the-stack-clash">stack clash</a>.</li>
<li>flaga <code>-D_FORTIFY_SOURCE=2</code> odpowiada za zastąpienie niebezpiecznych wywołań funkcji mających
nieograniczony rozmiar buforu tymi, które taki limit posiadają.</li>
<li>flagi <code>-pie</code> i <code>-fPIE</code> sprawiają, że pozycyjnie niezależne pliki wykonywalne (Position Independent
Executable) mogą korzystać z ALSR (<a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">Address Space Layout Randomization</a>).</li>
<li>flaga <code>-fpic</code> generuje kod niezależny od położenia
(<a href="https://en.wikipedia.org/wiki/Position-independent_code">position independent code, PIC</a>) dla bibliotek współdzielonych.</li>
</ul>
<h4 id="flagi-linkera">Flagi linkera</h4>
<p>Jeśli chodzi zaś o flagi linkera, to nie są one podawane bezpośrednio do niego ( <code>ld</code> ) ale do
kompilatora ( <code>gcc</code> ). Dlatego trzeba każdą z flag linkera poprzedzić flagą <code>-Wl</code> :</p>
<ul>
<li>flaga <code>-O</code> odpowiada za stopień optymalizacji kodu.</li>
<li>flaga <code>--as-needed</code> nakazuje linkerowi, by linkował w zbudowanym pliku binarnym tylko te
biblioteki, które zawierają symbole używane przez ten konkretny plik binarny. Więcej info
<a href="https://wiki.gentoo.org/wiki/Project:Quality_Assurance/As-needed">tutaj</a>.</li>
<li>flaga <code>-z,relro</code> sprawia, że w chwili ładowania programu pewne
sekcje <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">pamięci ELF</a>, które muszą być zapisane przez linker, będą zmienione tylko do odczytu
przed przekazaniem kontroli temu programowi. Chroni to przed częścią <a href="https://en.wikipedia.org/wiki/Global_Offset_Table">ataków GOT</a> (Global
Offset Table).</li>
<li>flaga <code>-z,now</code> sprawia, że podczas ładowania programu, wszystkie dynamiczne symbole są
rozwiązywane pozwalając tym samym na oznaczenie GOT jako tylko do odczytu. Może to jednak nieść ze
sobą pewne problemy z wydajnością przy ładowaniu większych aplikacji.</li>
</ul>
<p>Więcej o flagach można poczytać <a href="https://wiki.gentoo.org/wiki/GCC_optimization">tutaj</a> oraz <a href="https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/">tutaj</a>.</p>
<h3 id="hardening-kernela">Hardening kernela</h3>
<p>W zasadzie to nie musimy ustawiać żadnych z tych opisanych wyżej flag samodzielnie. Wszystko co
powinno zostać ustawione, zostanie ustawione automatycznie i żadnych dodatkowych czynności nie
musimy przeprowadzać. Niemniej jednak, na necie można się spotkać z różnymi formami hardening'u
kernela przez ustawianie flag. Wychodzi jednak na to, że manipulacja flagami nie wpływa w żaden
sposób na to co zostanie zbudowane ze źródeł kernela, przynajmniej w przypadku wywoływania
<code>make bindeb-pkg</code> . Zwykle każda zmiana flag powinna skutkować przebudową części albo całego kodu
od początku w przypadku korzystania z <code>ccache</code> ale tak się nie dzieje. Po zmianie flag, Cache HIT
rośnie, a nie powinien. Dlatego też tę całą zabawę w hardening kernela za sprawą flag można sobie
darować.</p>
<p>Jeśli już chodzi o prawdziwy hardening kernela, to trzeba podejść do tego zadania od strony
konfiguracyjnej, a konkretnie chodzi o <a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project/Recommended_Settings">ustawienie stosownych opcji</a> w samym kernelu.</p>
<p>Warto tutaj dodać, że <code>hardening-check</code> na wypakowanej binarce kernela zwróci nam błędny wynik
niezależnie od tego z jakimi flagami będziemy źródła kernela kompilować. Dzieje się tak dlatego, że
aplikacje typu <code>hardening-check</code> są przeznaczone do pracy z regularnymi binarkami ELF, a binarka
kernela się do takowych nie zalicza i ciężko jest oczekiwać od tych narzędzi, by zwracały poprawny
wynik.</p>
<h4 id="gcc-plugins">GCC plugins</h4>
<p>Jeśli będziemy się bawić w hardening kernela przez jego odpowiednią konfigurację, to przydałoby się
też włączyć opcje od <code>GCC plugins</code> . Standardowo są one jednak nieaktywne lub wyłączone i nie da
się ich przestawić bez wcześniejszej instalacji w systemie paczki <code>gcc-8-plugin-dev</code> :</p>
<pre><code># aptitude install gcc-8-plugin-dev
</code></pre>
<p>Teraz te opcje powinny być już aktywne.</p>
<h3 id="problemy-z-xconfig">Problemy z xconfig</h3>
<p>Generalnie rzecz biorąc, kernel możemy
konfigurować <a href="https://en.wikipedia.org/wiki/Xconfig">przez narzędzie  GUI</a> wydając w terminalu polecenie <code>make xconfig</code>. To narzędzie
wykorzystuje interfejs QT, a do jego skonfigurowania potrzebny nam będzie <code>qt5ct</code>. Musimy zatem
doinstalować sobie poniższy pakiet:</p>
<pre><code># aptitude install qt5ct
</code></pre>
<p>W przypadku problemów przy odpalaniu <code>qt5ct</code>, trzeba będzie wyeksportować zmienną
<code>$QT_QPA_PLATFORMTHEME</code>:</p>
<pre><code># export QT_QPA_PLATFORMTHEME=&quot;qt5c&quot;
</code></pre>
<h3 id="ccache">ccache</h3>
<p>By dodatkowo przyśpieszyć proces ponownej kompilacji kodu, możemy doinstalować w systemie <code>ccache</code>:</p>
<pre><code># aptitude install ccache
</code></pre>
<p>Trzeba także porobić kilka dowiązań, by <code>ccache</code> był wykorzystywany podczas kompilacji:</p>
<pre><code># ln -s /usr/bin/ccache /usr/local/bin/gcc
# ln -s /usr/bin/ccache /usr/local/bin/g++
# ln -s /usr/bin/ccache /usr/local/bin/cc
# ln -s /usr/bin/ccache /usr/local/bin/c++
</code></pre>
<p>Musimy również wyeksportować kilka zmiennych:</p>
<pre><code># export USE_CCACHE=&quot;1&quot;
# export CCACHE_DIR=&quot;/media/kernel/ccache&quot;
</code></pre>
<p>Wielkością cache sterujemy w poniższy sposób:</p>
<pre><code># ccache -M 10G
Set cache size limit to 10.0 GB

# ccache -s
cache directory                     /media/kernel/ccache/
primary config                      /media/kernel/ccache/ccache.conf
...
max cache size                      10.0 GB
</code></pre>
<h3 id="wersja-gccgcpp">Wersja gcc/g++/cpp</h3>
<p>W Debianie dostępnych jest kilka wersji kompilatorów gcc/g++ i preprocesora C. Aktualnie domyślną
wersją jest wersja 10. Niemniej jednak, w systemie można zainstalować także wersję 11 i to raczej
nie powinno stanowić problemu. Natomiast problemem może być wybór, którą wersję tych narzędzi
chcemy wykorzystywać przy budowaniu kernela czy też innych projektów. W takich sytuacjach z pomocą
przychodzi system alternatyw, za pomocą którego to musimy określić <a href="https://azrael.digipen.edu/~mmead/www/mg/update-compilers/index.html">preferowaną wersję
gcc/g++/cpp</a>, a linki do odpowiednich binarek zostaną już automatycznie utworzone za nas. Mając
już zainstalowane stosowne pakiety, odpalamy terminal i wpisujemy w nim te poniższe polecenia.</p>
<p>Usuwamy stare alternatywy dla gcc/g++/cpp:</p>
<pre><code># update-alternatives --remove-all cc
# update-alternatives --remove-all c++
# update-alternatives --remove-all gcc
# update-alternatives --remove-all g++
# update-alternatives --remove-all cpp-bin
</code></pre>
<p>Dodajemy teraz nowe alternatywy:</p>
<pre><code># update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-10 50  \
                      --slave /usr/bin/g++ g++ /usr/bin/g++-10

# update-alternatives --install /usr/bin/cpp cpp-bin /usr/bin/cpp-10

# update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100 \
                      --slave /usr/bin/g++ g++ /usr/bin/g++-11

# update-alternatives --install /usr/bin/cpp cpp-bin /usr/bin/cpp-10 50
# update-alternatives --install /usr/bin/cpp cpp-bin /usr/bin/cpp-11 100
</code></pre>
<p>Warto tutaj wspomnieć, że alternatywy dla <code>g++</code> zostały dodane za sprawą przełącznika <code>--slave</code> .
Uzależniamy w ten sposób alternatywy dla <code>g++</code> od <code>gcc</code> . W ten sposób wystarczy skonfigurować
alternatywę dla <code>gcc</code> , a alternatywy dla <code>g++</code> zostaną automatycznie dostosowane.</p>
<p>Ustawiamy również by linki cc/c++ wskazywały na gcc/g++ :</p>
<pre><code># update-alternatives --install /usr/bin/cc cc /usr/bin/gcc 30 \
                      --slave /usr/bin/c++ c++ /usr/bin/g++
</code></pre>
<p>I na koniec konfigurujemy sobie preferowaną wersję gcc/g++/cpp:</p>
<pre><code># update-alternatives --config gcc
# update-alternatives --config cpp-bin
</code></pre>
<h2 id="pozyskiwanie-informacji-o-sprzęcie">Pozyskiwanie informacji o sprzęcie</h2>
<p>To co jest niezbędne do zbudowania kernela, który będzie w stanie obsłużyć nasz sprzęt w pełni, to
informacje o modułach, których potrzebują poszczególne podzespoły. Każdy kawałek hardware działa w
oparciu o jakiś moduł. Listę aktualnie załadowanych w systemie modułów możemy ustalić wydając
polecenie <code>lsmod</code>. Trzeba tutaj jednak pamiętać, że jest to lista modułów dla urządzeń, które
aktualnie działają w systemie, ewentualnie też dla tych, które zostały od niego odłączone ale
system nie został zresetowany, a moduły nie zostały wyładowane ręcznie. Dlatego też przydałoby się
w tym momencie podłączyć wszystkie te urządzenia, z których zamierzamy korzystać w przyszłości, np.
pendrive, modemy LTE, karty WiFi, adaptery bluetooth, myszy, klawiatury USB, itp. System sobie
dobierze odpowiednie moduły i je nam załaduje. Lista tych modułów zostanie następnie podana podczas
wstępnej konfiguracji kernela.</p>
<h2 id="make-localyesconfig">make localyesconfig</h2>
<p>Gdy już mamy załadowane wszystkie potrzebne moduły, przechodzimy do katalogu ze źródłami i wydajemy
poniższe polecenie:</p>
<pre><code># make localyesconfig
</code></pre>
<p>W katalogu roboczym powinien zostać wygenerowany plik <code>.config</code> zawierający konfigurację kernela.
Być może zostaniemy poproszeni o udzielenie odpowiedzi na szereg pytań dotyczących nowych opcji,
czyli tych, które nie występowały we wcześniejszej konfiguracji:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2018/12/002.debian-kernel-localyesconfig.png" alt=""    class="huge"></p>
<p>Można bez problemu odpowiedzieć negatywnie na wszystkie pytania wciskając <code>N</code>, chyba, że coś jest
nam potrzebne.</p>
<h2 id="make-xconfig">make xconfig</h2>
<p>Mając konfigurację w pliku <code>.config</code> możemy wpisać w terminal poniższe polecenie:</p>
<pre><code># make xconfig
</code></pre>
<p>Powinno zostać nam wyświetlone okienko, w którym będziemy mogli już dowolnie włączać lub wyłączać
określone opcje kernela:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2018/12/003.debian-kernel-xconfig.png" alt=""    class="huge"></p>
<p>Mój laptop posiada procesor Intel ale szereg opcji od procesorów AMD było również pozaznaczanych.
Dlatego też warto przejrzeć te już zaznaczone opcje i je sobie dostosować.</p>
<h2 id="budowanie-kernela-linux">Budowanie kernela linux</h2>
<p>Gdy już skończymy się bawić w konfiguracji, zapisujemy ją i wracamy na terminal, gdzie wydajemy
poniższe polecenie:</p>
<pre><code># make ARCH=&quot;x86_64&quot; -j2 bindeb-pkg
</code></pre>
<p>Target <code>bindeb-pkg</code> zbuduje nam trzy pliki: <code>linux-image-*.deb</code> , <code>linux-headers-*.deb</code> oraz
<code>linux-libc-dev_*.deb</code> . Te dwa pierwsze można zainstalować już w systemie, natomiast ten ostatni
zwykle będzie kolidował z wersją, która została zainstalowana w systemie z racji posiadania
dystrybucyjnego kernela. Ja tego trzeciego pakietu nie instalowałem póki co, a system zdaje się
działać jak należy.</p>
<p>Jeśli jest potrzeba zbudowania innych rzeczy, to dobrze jest zajrzeć do pomocy:</p>
<pre><code># make help
</code></pre>
<h2 id="funkcjonalność-kernela-wkompilowana-na-stałe-czy-jako-moduł">Funkcjonalność kernela wkompilowana na stałe czy jako moduł</h2>
<p>Kernel linux'a posiada całą masę opcji przekładających się na jego funkcjonalność podczas normalnej
pracy komputera. Gdyby wszystkie te rzeczy wkompilować na stałe w kernel, to miałby on spore
rozmiary i zjadałby nam cenne zasoby pamięci operacyjnej. Dlatego też kernele różnych dystrybucji
linux'a mają całą masę modułów, które są lub mogą być ładowane w późniejszym czasie, gdy zachodzi
taka potrzeba, np. podłączamy nowe urządzenie USB do komputera.</p>
<p>Moduły są w porządku, gdy mamy do czynienia z kernelem, który ma działać na sporej masie sprzętów,
lub też gdy pewne urządzenia podłączamy jedynie sporadycznie. Niemniej jednak, cała ta
funkcjonalność kernela, która jest niezbędna naszej konkretnej maszynie do prawidłowego
funkcjonowania powinna być wkompilowana na stałe. To czy wkompilować na stałe obsługę modemu LTE,
z którego korzystamy w chwili, gdy nam padnie główne połączenie internetu, to już każdy powinien
sobie odpowiedzieć sam. Podobnie sprawa ma się z pozostałym sprzętem, którego nie używamy na co
dzień.</p>
<p>Jeśli chodzi o wydajność, to nie ma praktycznie żadnej różnicy w przypadku kompilacji części kodu
na stałe w stosunku do odpowiednika modułowego, przynajmniej jeśli chodzi o działanie, bo przecie w
przypadku modułu trzeba doliczyć trochę czasu na jego załadowanie.</p>
<h3 id="rozmiar-kernela-i-obrazu-initramfsinitrd">Rozmiar kernela i obrazu initramfs/initrd</h3>
<p>Poniżej porównany został rozmiar samego kernela oraz obrazu initramfs, które są ładowane do pamięci
komputera zaraz po jego uruchomieniu.</p>
<pre><code># ls -alh /boot/ | egrep &quot;initrd|vmlinuz&quot;
-rw-r--r--  1 root root  32M 2018-12-31 02:52:17 initrd.img-4.19.0-1-amd64
-rw-r--r--  1 root root 9.9M 2019-01-01 16:58:10 initrd.img-4.19.13-amd64-morficzny
-rw-r--r--  1 root root 5.0M 2018-12-30 10:04:03 vmlinuz-4.19.0-1-amd64
-rw-r--r--  1 root root 8.4M 2019-01-01 16:46:34 vmlinuz-4.19.13-amd64-morficzny
</code></pre>
<p>Powyższe pliki dotyczą tego samego kernela, z tym, że ten mający sufiks <code>-morficzny</code> został
zbudowany przeze mnie, a nie przez ludzi z dystrybucji Debiana. Ja wbudowałem całą funkcjonalność
kernela odpowiedzialną za prawidłowe działanie mojego laptopa na stałe. Tak samo postąpiłem w
przypadku pozostałych urządzeń, które od czasu do czasu podłączam do niego.</p>
<p>Oczywiście powyższe pliki są skompresowane i by porównać ich faktyczne rozmiary, to trzeba te pliki
pierw wypakować:</p>
<pre><code># /usr/src/linux-source-4.19/scripts/extract-vmlinux /boot/vmlinuz-4.19.13-amd64-morficzny &gt; kernel-morficzny
# /usr/src/linux-source-4.19/scripts/extract-vmlinux /boot/vmlinuz-4.19.0-1-amd64  &gt; kernel-debiana

# ls -alh /tmp/kernel-*
-rw-r--r-- 1 root root 27M 2019-01-01 18:45:01 /tmp/kernel-debiana
-rw-r--r-- 1 root root 38M 2019-01-01 18:44:49 /tmp/kernel-morficzny
</code></pre>
<p>Widać wyraźnie, że mój kernel jest o ponad 40% większy od tego dystrybucyjnego . Nie oznacza to, że
będzie on zjadał więcej pamięci RAM -- bo przecie ten dystrybucyjny kernel musi sobie jeszcze
załadować moduły, które zostały wgrane na dysk.</p>
<p>Jeśli natomiast chodzi o obraz initramfs, to sprawa prezentuje się następująco:</p>
<pre><code># unmkinitramfs /boot/initrd.img-4.19.13-amd64-morficzny  /tmp/initramfs-morficzny
# unmkinitramfs /boot/initrd.img-4.19.0-1-amd64  /tmp/initramfs-debiana

# du -hm /tmp/initramfs-*
104     /tmp/initramfs-debiana/main
2       /tmp/initramfs-debiana/early
105     /tmp/initramfs-debiana
21      /tmp/initramfs-morficzny/main
2       /tmp/initramfs-morficzny/early
22      /tmp/initramfs-morficzny
</code></pre>
<p>Wartości w pierwszej kolumnie są w megabajtach. Widać zatem, że mój obraz initramfs już jest
znacznie mniejszy od tego dystrybucyjnego, bo w przeciwieństwie do niego nie zawiera całej masy
zbędnych modułów. Oczywiście różnica na poziomie parudziesięciu megabajtów raczej w dzisiejszych
czasach nikomu snu z powiek nie spędzi. Podobnie jak i ładowanie modułów z wolnego HDD czy nawet
szybszego SSD, bo to jest kwestia co najwyżej kilku czy kilkunastu sekund.</p>
<h3 id="jaka-funkcjonalność-kernela-została-wkompilowana-na-stałe">Jaka funkcjonalność kernela została wkompilowana na stałe</h3>
<p>Po zresetowaniu maszyny, ta powinna się nam uruchomić bez większego problemu, chyba, że za dużo
rzeczy ręcznie wyłączyliśmy. Mi póki co udało się pozbawić mojego laptopa klawiatury, dźwięku,
filtra pakietów (iptables), no i też przez złe dobranie modułów kryptograficznych nie mogłem
odszyfrować swojego systemu ale wszystkie te rzeczy zostały już poprawione. To co jednak może się
popsuć na samym początku, to usługa systemd odpowiedzialna za ładowanie modułów podczas startu
systemu. Warto jest się zatem zainteresować tym, co mamy w katalogu <code>/etc/modules-load.d/</code>. Błędy
będą powodowane jedynie przez brak konkretnego modułu. Jeśli taka funkcjonalność kernela zostanie
wkompilowana na stałe, to system zwróci nam jedynie stosowną informacje:</p>
<pre><code>systemd-modules-load[582]: Module 'loop' is builtin
</code></pre>
<p>Trzeba też pamiętać o fakcie, że wszystkie wbudowane moduły na stałe nie będą już widoczne w
<code>lsmod</code> lub w pliku <code>/proc/modules</code> . Jeśli chcemy sprawdzić jaka funkcjonalność została wbudowana
kernel i czy są te moduły, których się spodziewamy, to możemy podejrzeć konfigurację kernela:</p>
<pre><code># cat /boot/config-$(uname -r)
# zcat /proc/config.gz
</code></pre>
<p>Możemy także zajrzeć do pliku <code>modules.builtin</code> w katalogu z modułami kernela:</p>
<pre><code># cat /lib/modules/$(uname -r)/modules.builtin
</code></pre>
<p>W przypadku, gdy kompilujemy wszystkie opcje kernela na stałe, to dobrze jest jeszcze sprawdzić czy
nie zostały nam jakieś niedobitki:</p>
<pre><code># egrep \=m /boot/config-4.19.13-amd64-morficzny
</code></pre>
<p>Jeśli to powyższe polecenie nam nie zwróci żadnego wyniku, to cała funkcjonalność kernela została
wkompilowana w niego na stałe.</p>
<h3 id="parametry-modułów-wkompilowanych-na-stałe">Parametry modułów wkompilowanych na stałe</h3>
<p>Jeśli zdarzyło nam się konfigurować parametry modułów, to raczej powinniśmy być zaznajomieni z
katalogiem <code>/etc/modprobe.d/</code> . W przypadku, gdy moduły mamy wkompilowane na stałe, to konfiguracja
z tego katalogu nam zwyczajnie nie zadziała. Niemniej jednak, w dalszym ciągu możemy parametry
modułów zmieniać. Trzeba to tylko robić przez &quot;kernel command line&quot;, którą możemy uzupełnić na dwa
sposoby.</p>
<p>Pierwszym sposobem jest edycja konfiguracji bootloader'a, gdzie mamy wpis podobny do tego poniżej:</p>
<pre><code>...
APPEND root=/dev/mapper/wd_black_label-root ... loop.max_part=63 ro
...
</code></pre>
<p>Drugim sposobem jest określenie stosownej opcji w konfiguracji źródeł kernela:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2018/12/004.debian-kernel-xconfig.png" alt=""    class="huge"></p>
<p>Oba te sposoby są w zasadzie podobne, bo wynikowa linijka kernela widziana pod <code>/proc/cmdline</code>
będzie dokładnie taka sama, tj. zawierać te same parametry i te same
wartości. <a href="https://people.freedesktop.org/~narmstrong/meson_drm_doc/admin-guide/kernel-parameters.html">Sposób określania parametrów</a> w linijce kernela jest następujący. Najpierw określamy
nazwę modułu, w tym przypadku jest to <code>loop</code> . Później dajemy <code>.</code> , która oddziela nazwę modułu od
jego parametru podawanego po kropce, tj. <code>max_part</code>. Temu parametrowi można przypisać wartość i
dlatego po nim występuje <code>=</code> i pożądana wartość <code>63</code> .</p>
<p>Wiemy zatem jak skonfigurować moduł ale skąd wziąć parametry modułów? Można odczytać je z <code>modinfo</code>:</p>
<pre><code># modinfo loop
...
parm:           max_loop:Maximum number of loop devices (int)
parm:           max_part:Maximum number of partitions per loop device (int)
</code></pre>
<p>Można także użyć <code>systool</code>:</p>
<pre><code># systool -v -m loop
...
  Parameters:
    max_loop            = &quot;0&quot;
    max_part            = &quot;63&quot;
</code></pre>
<p>W przypadku <code>systool</code> widać także aktualną konfigurację modułu.</p>
<p>Narzędzia <code>modinfo</code> jest w stanie nam pomóc jedynie w przypadku, gdy mamy załadowany kernel mający
moduły, czyli jeszcze nie przelogowaliśmy się na nasze świeżo ugotowane jajo. Gdy to zrobimy, to
<code>modinfo</code> zwróci nam jedynie błąd, że moduł nie został znaleziony:</p>
<pre><code>#  modinfo loop
modinfo: ERROR: Module loop not found.
</code></pre>
<p>Więc albo posiłkujmy się narzędziem <code>systool</code> , albo trzeba zajrzeć do katalogu
<code>/sys/module/nazwa_modułu/parameters/</code> .</p>
<h3 id="całkowite-wyłączenie-obsługi-modułów">Całkowite wyłączenie obsługi modułów</h3>
<p>Gdy zamierzamy całkowicie zrezygnować z modułów i wkompilować całą potrzebną nam funkcjonalność
kernela na stałe, to można by się pokusić o całkowite wyłączenie obsługi modułów w kernelu.
Przemawiać może za tym poprawa bezpieczeństwa (nikt żadnych modułów już nie będzie w stanie
załadować) oraz prostszy w budowie kernel, co z kolei przyśpieszy jego pracę. Niemniej jednak,
odhaczenie <code>CONFIG_MODULES</code> sprawia, że niektóre aplikacje mogą mieć problemy z ustaleniem czy
pewna funkcjonalność jest oferowana przez kernel. Jedną z takich aplikacji jest <code>containerd</code> ,
który zwraca poniższy błąd:</p>
<pre><code>modprobe: ERROR: ../libkmod/libkmod.c:514 lookup_builtin_file() could not open builtin file '/lib/modules/4.19.13-amd64-morficzny/modules.builtin.bin'
modprobe: FATAL: Module overlay not found in directory /lib/modules/4.19.13-amd64-morficzny
</code></pre>
<p>Niby wszystkie potrzebne moduły zostały wbudowane w kernel ale z racji braku pliku
<code>modules.builtin.bin</code> usługa się nie chce podnieść. Zwykle wystarczy poszukać w usługach wywołań z
<code>modprobe</code> i je wykomentować:</p>
<pre><code>...
[Service]
#ExecStartPre=/sbin/modprobe overlay
ExecStart=/usr/bin/containerd
...
</code></pre>
<p>Podobnie sprawa ma się z usługą <code>systemd-modules-load.service</code> , która również się nam nie odpali i
zwróci błąd. I tę usługę wypadałoby także wyłączyć.</p>
<pre><code># systemctl mask systemd-modules-load.service
</code></pre>
<p>Warto też zajrzeć do plików w katalogu <code>/etc/initramfs-tools/</code> i przejrzeć je pod kątem
ewentualnych prób ładowania modułów.</p>
<p>O ile usługi oraz konfigurację systemową można bez problemu poprawić, to gdy zamierzamy instalować
paczki mające w nazwie <code>*-dkms</code> , to niestety nie możemy wyłączyć całkowicie obsługi modułów,
bo <a href="https://morfikov.github.io/post/dkms-czyli-automatycznie-budowane-moduly/">mechanizm DKMS</a> w końcu buduje moduły, które będą ładowane, gdy zajdzie taka potrzeba.</p>
<h4 id="wyłączenie-możliwości-ładowania-modułów-podczas-pracy-systemu">Wyłączenie możliwości ładowania modułów podczas pracy systemu</h4>
<p>Jeśli całkowite wyłączenie modułów w kernelu generuje u nas sporo problemów, to zawsze można
skorzystać z mniej inwazyjnej opcji jaką jest wyłączenie możliwości ładowania modułów podczas pracy
systemu. Tutaj już wystarczy ustawić tylko tę poniższą opcję w pliku <code>/etc/sysctl.conf</code> :</p>
<pre><code>kernel.modules_disabled = 1
</code></pre>
<p>Trzeba jednak pamiętać, że <code>kernel.modules_disabled</code> chroni nas jedynie od momentu ustawienia tej
opcji -- nie da się jej przestawić z <code>1</code> na <code>0</code> bez restartu systemu. W dalszym ciągu jednak trefne
moduły mogą zostać załadowane na starcie systemu.</p>
<h2 id="nakładanie-łatek-na-kernel-patch">Nakładanie łatek na kernel (patch)</h2>
<p>Niekiedy pojawiają się ciekawe łatki na kernel, które z jakiegoś powodu (czasami zasadnego, np.
wywołują BUG'i w kernelu) nie są aplikowane na kernel dystrybucyjny. Przykładem takiej łatki może
być <a href="https://patchwork.kernel.org/patch/9773791/">TPE (Trusted Path Execution)</a>. Mając własny kernel, można taką łatę sobie pobrać i
zaaplikować. Proces nakładania łatek może być automatyczny lub manualny, w zależności od tego czy
potrafimy korzystać z <code>quilt</code>'a.</p>
<p>Standardowo, taki patch pobiera się do katalogu, w którym mamy również katalog kernela, czyli w
tym przypadku jest to <code>/usr/src/</code> po czym przechodzi się do katalogu kernela i aplikuje patch w
poniższy sposób:</p>
<pre><code># cd /usr/src/linux-4.19.12/
# patch --dry-run -p1 &lt; ../v2-1-1-Add-Trusted-Path-Execution-as-a-stackable-LSM.diff
# patch -p1 &lt; ../v2-1-1-Add-Trusted-Path-Execution-as-a-stackable-LSM.diff
</code></pre>
<p>A gdy zachodzi potrzeba ściągnąć łatkę, to robimy to przy pomocy parametru <code>-R</code>:</p>
<pre><code># patch -R --dry-run -p1 &lt; ../v2-1-1-Add-Trusted-Path-Execution-as-a-stackable-LSM.diff
# patch -R -p1 &lt; ../v2-1-1-Add-Trusted-Path-Execution-as-a-stackable-LSM.diff
</code></pre>
<p>Jeśli patch składa się z kilku plików, to nakładamy te pliki w kolejności numerycznej od
najmniejszego. W przypadku ściągania takiego patch'a robimy to w odwrotnej kolejności, czyli
ostatni zaaplikowany plik ściągamy w pierwszej kolejności.</p>
<p>Problem z takim zakładaniem i ściganiem patch'y jest taki, że nie mamy żadnego mechanizmu
śledzącego zmiany, których dokonujemy na źródłach kernela. Gdy mamy do dyspozycji tylko kilka
łatek, to taka sytuacja raczej nam wielkiego problemu nie przysporzy ale jeśli w grę wchodzi wiele
patch'y, to już łatwo można się pogubić. Dlatego zamiast ogarniać sprawę łat ręcznie, dobrze jest
zaopatrzyć się w <code>quilt</code> . To narzędzie może nie być domyślnie zainstalowane. Także jak coś to
trzeba je doinstalować:</p>
<pre><code># aptitude install quilt
</code></pre>
<p>Tworzymy sobie plik konfiguracyjny dla <code>quilt</code> , tj. <code>/root/.quiltrc</code> o poniższej zawartości:</p>
<pre><code># cat /root/.quiltrc
export QUILT_PATCHES=&quot;debian/patches&quot;
export QUILT_PUSH_ARGS=&quot;--color=auto&quot;
export QUILT_DIFF_ARGS=&quot;--no-timestamps --no-index -p ab --color=auto&quot;
export QUILT_REFRESH_ARGS=&quot;--no-timestamps --no-index -p ab&quot;
export QUILT_DIFF_OPTS='-p'
</code></pre>
<p>Z powyższego pliku najbardziej interesuje nas zmienna <code>$QUILT_PATCHES</code> , bo to ona definiuje w
jakim katalogu będą się znajdować łaty. Ścieżka do katalogu jest względna w stosunku do katalogu
roboczego, tj. źródeł kernela. Podczas budowania paczki z kernelem dla Debiana zostanie stworzony
katalog <code>debian/</code> (i szereg plików w nim) w głównym katalogu ze źródłami kernela. Jeśli nie chcemy
umieszczać łatek w <code>debian/patches/</code> , to zawsze możemy ten katalog usunąć i stworzyć na jego
miejsce dowiązanie symboliczne, np. do katalogu <code>/usr/src/kernel-patches/</code> :</p>
<pre><code># rmdir debian/patches
# ln -s /usr/src/kernel-patches/ ./debian/patches
</code></pre>
<p>W ten sposób wszystkie łatki zawsze będą rezydować poza źródłami kernela i sobie ich przez
przypadek nie usuniemy, gdy będziemy usuwać stare źródła.</p>
<p>Mając przygotowanego <code>quilt</code>'a, możemy zaimportować łatę i nałożyć ją w poniższy sposób:</p>
<pre><code># quilt import /sciezka/do/pliku
# quilt push
</code></pre>
<p><img loading="lazy" src="https://morfikov.github.io/img/2018/12/005.debian-kernel-patch.png" alt=""    class="huge"></p>
<p>Łatkę ściągamy za to tak:</p>
<pre><code># quilt pop
</code></pre>
<p>Jak chcemy ściągnąć lub nałożyć wszystkie łaty naraz, to dajemy:</p>
<pre><code># quilt push -a
# quilt pop -a
</code></pre>
<p>Po nałożeniu łątek, zwykle w <code>xconfig</code> będziemy mieli do zaznaczenia kilka dodatkowych opcji. Jeśli
nie chce nam się ich szukać (przez tą zbugowaną szukajkę), to możemy zamiast <code>make xconfig</code> dać
<code>make oldconfig</code> , który wypisze nam wszystkie nowe opcje w stosunku do tych określonych już w
konfiguracji.</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2018/12/006.debian-kernel-oldconfig.png" alt=""    class="huge"></p>
<p>Dla pewności możemy jeszcze zajrzeć do <code>xconfig</code>:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2018/12/007.debian-kernel-xconfig-v.png" alt=""    class="huge"></p>
<p>Po nałożeniu łaty, kernel trzeba skompilować jeszcze raz. W zależności od dokonanych zmian w
konfiguracji, rekompilacja/kompilacja może dotyczyć tylko części kodu kernela. Więc nie trzeba
kompilować kernela od początku mając już wcześniej skompilowane źródła, no chyba, że wyda się
<code>make clean</code>. Dlatego też jeśli zmieniamy tylko nieznacznie konfigurację kernela, to paczki <code>.deb</code>
z gotowym do zainstalowania kernelem możemy zrobić sobie bardzo szybko, no chyba, że wyjdzie nowsza
wersja kernela, to wtedy niestety kompilacja będzie przebiegać od początku, a to może potrwać
chwilę.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/debian/">debian</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/kernel/">kernel</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/kompilacja/">kompilacja</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f&amp;text=Budowanie%20kernela%20linux%20dla%20konkretnej%20maszyny%20z%20Debianem" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f&amp;title=Budowanie%20kernela%20linux%20dla%20konkretnej%20maszyny%20z%20Debianem" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f&amp;title=Budowanie%20kernela%20linux%20dla%20konkretnej%20maszyny%20z%20Debianem" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f&title=Budowanie%20kernela%20linux%20dla%20konkretnej%20maszyny%20z%20Debianem" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f&amp;title=Budowanie%20kernela%20linux%20dla%20konkretnej%20maszyny%20z%20Debianem" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbudowanie-kernela-linux-dla-konkretnej-maszyny-z-debianem%2f&description=Budowanie%20kernela%20linux%20dla%20konkretnej%20maszyny%20z%20Debianem" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/dkms-czyli-automatycznie-budowane-moduly/">DKMS, czyli automatycznie budowane moduły</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/konfiguracja-serwer-xmpp-jabber-linux-ejabberd/">Konfiguracja serwera XMPP/Jabber pod linux (ejabberd)</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/android-studio-i-android-sdk-pod-linux/">Android Studio i Android SDK pod linux</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/redshift-i-dostosowanie-temperatury-kolorow-ekranu/">Redshift i dostosowanie temperatury kolorów ekranu</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-skonfigurowac-polaczenie-vpn-przez-ssh/">Jak skonfigurować połączenie VPN przez SSH</a></li>
		
	</ul>
</div>

	

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2021 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
		<img alt="Licencja Creative Commons" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/80x15.png" />
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script data-goatcounter="https://morfik.goatcounter.com/count"
  async src="//gc.zgo.at/count.js"></script>
</body>
</html>
