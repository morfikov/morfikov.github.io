<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:url" content="https://morfikov.github.io/post/trim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux/">
  <meta property="og:site_name" content="Morfitronik">
  <meta property="og:title" content="TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux">
  <meta property="og:description" content="Jakiś czas temu opisywałem jak na Debianie włączyć obsługę mechanizmu TRIM (realizowanego przez polecenie fstrim ) na podpiętych do komputera dyskach SSD. Problem w tym, że dyski SSD, z którymi będziemy wchodzić w interakcję, nie zawsze będą podłączane do dedykowanych portów SATA/mSATA. Jak zachowa się zatem nasz linux, gdy będziemy chcieli podłączyć po portu USB zewnętrzny dysk SSD? Przez zewnętrzny dysk USB nie mam na myśli dedykowanych zewnętrznych dysków USB, bo te raczej nie powinny sprawiać kłopotów. Chodzi mi bardziej o wewnętrzne dyski SSD (np. ze starego laptopa), które zamkniemy w dedykowanej obudowie USB, lub też będziemy taki dysk podłączać na krótko za pomocą adaptera USB-SATA. W takich przypadkach zwykle kernel linux&#39;a nie odważy się włączyć wsparcia dla TRIM dla nośników SSD i tak właśnie się stało w przypadku mojego nowo zakupionego dysku od Goodram, a konkretnie jest to model SSDPR-CX400-02T-G2 , który to został podłączony do portu USB3 mojego Raspberry PI (i Debiana) przy pomocy kabelka USB-SATA (Unitek USB3.1 USB-A to 2.5&#34; SATA6G). Przez kilka miesięcy dysk sprawował się bez zarzutu ale ostatnio przy próbie wgrania na niego danych (przez sieć), transfer spadł do dosłownie pojedynczych MiB/s. Poszukałem trochę informacji i okazało się, że dla tego typu nośników trzeba ręcznie włączyć TRIM, o ile będzie to w ogóle możliwe.">
  <meta property="og:locale" content="pl_PL">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2024-06-16T16:30:00+02:00">
    <meta property="article:modified_time" content="2024-06-16T16:30:00+02:00">
    <meta property="article:tag" content="Debian">
    <meta property="article:tag" content="Ssd">
    <meta property="article:tag" content="Trim">
    <meta property="article:tag" content="Discard">
    <meta property="article:tag" content="System-Plików">
    <meta property="article:tag" content="Ext4">

		
  <meta itemprop="name" content="TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux">
  <meta itemprop="description" content="Jakiś czas temu opisywałem jak na Debianie włączyć obsługę mechanizmu TRIM (realizowanego przez polecenie fstrim ) na podpiętych do komputera dyskach SSD. Problem w tym, że dyski SSD, z którymi będziemy wchodzić w interakcję, nie zawsze będą podłączane do dedykowanych portów SATA/mSATA. Jak zachowa się zatem nasz linux, gdy będziemy chcieli podłączyć po portu USB zewnętrzny dysk SSD? Przez zewnętrzny dysk USB nie mam na myśli dedykowanych zewnętrznych dysków USB, bo te raczej nie powinny sprawiać kłopotów. Chodzi mi bardziej o wewnętrzne dyski SSD (np. ze starego laptopa), które zamkniemy w dedykowanej obudowie USB, lub też będziemy taki dysk podłączać na krótko za pomocą adaptera USB-SATA. W takich przypadkach zwykle kernel linux&#39;a nie odważy się włączyć wsparcia dla TRIM dla nośników SSD i tak właśnie się stało w przypadku mojego nowo zakupionego dysku od Goodram, a konkretnie jest to model SSDPR-CX400-02T-G2 , który to został podłączony do portu USB3 mojego Raspberry PI (i Debiana) przy pomocy kabelka USB-SATA (Unitek USB3.1 USB-A to 2.5&#34; SATA6G). Przez kilka miesięcy dysk sprawował się bez zarzutu ale ostatnio przy próbie wgrania na niego danych (przez sieć), transfer spadł do dosłownie pojedynczych MiB/s. Poszukałem trochę informacji i okazało się, że dla tego typu nośników trzeba ręcznie włączyć TRIM, o ile będzie to w ogóle możliwe.">
  <meta itemprop="datePublished" content="2024-06-16T16:30:00+02:00">
  <meta itemprop="dateModified" content="2024-06-16T16:30:00+02:00">
  <meta itemprop="wordCount" content="4072">
  <meta itemprop="keywords" content="Debian,Ssd,Trim,Discard,System-Plików,Ext4,Udev,Usb">
		
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux">
  <meta name="twitter:description" content="Jakiś czas temu opisywałem jak na Debianie włączyć obsługę mechanizmu TRIM (realizowanego przez polecenie fstrim ) na podpiętych do komputera dyskach SSD. Problem w tym, że dyski SSD, z którymi będziemy wchodzić w interakcję, nie zawsze będą podłączane do dedykowanych portów SATA/mSATA. Jak zachowa się zatem nasz linux, gdy będziemy chcieli podłączyć po portu USB zewnętrzny dysk SSD? Przez zewnętrzny dysk USB nie mam na myśli dedykowanych zewnętrznych dysków USB, bo te raczej nie powinny sprawiać kłopotów. Chodzi mi bardziej o wewnętrzne dyski SSD (np. ze starego laptopa), które zamkniemy w dedykowanej obudowie USB, lub też będziemy taki dysk podłączać na krótko za pomocą adaptera USB-SATA. W takich przypadkach zwykle kernel linux&#39;a nie odważy się włączyć wsparcia dla TRIM dla nośników SSD i tak właśnie się stało w przypadku mojego nowo zakupionego dysku od Goodram, a konkretnie jest to model SSDPR-CX400-02T-G2 , który to został podłączony do portu USB3 mojego Raspberry PI (i Debiana) przy pomocy kabelka USB-SATA (Unitek USB3.1 USB-A to 2.5&#34; SATA6G). Przez kilka miesięcy dysk sprawował się bez zarzutu ale ostatnio przy próbie wgrania na niego danych (przez sieć), transfer spadł do dosłownie pojedynczych MiB/s. Poszukałem trochę informacji i okazało się, że dla tego typu nośników trzeba ręcznie włączyć TRIM, o ile będzie to w ogóle możliwe.">

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
  


</head>
<body class="body kind-page">
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2024-06-16T16:30:00&#43;02:00">Opublikowano: 16/06/2024</time>

<div class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>, 
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/raspberrypi/" rel="category">RaspberryPi</a>
	</span>
</div>
	</div>
				<h1 class="entry__title">TRIM/UNMAP w dyskach SSD podłączonych via adapter USB-SATA na linux</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#czy-mój-dysk-ssd-na-usb-wspiera-trim">Czy mój dysk SSD na USB wspiera TRIM</a></li>
    <li><a href="#problematyczny-adapter-usb-sata-obudowa-usb">Problematyczny adapter USB-SATA (obudowa USB)</a></li>
    <li><a href="#ryzyko-utraty-danych-i-uszkodzenia-dysku-ssd">Ryzyko utraty danych i uszkodzenia dysku SSD</a></li>
    <li><a href="#strony-vpd-vital-product-data">Strony VPD (Vital Product Data)</a>
      <ol>
        <li><a href="#brak-auto-konfiguracji-w-oparciu-o-vpd">Brak auto konfiguracji w oparciu o VPD</a></li>
      </ol>
    </li>
    <li><a href="#jak-włączyć-trim-w-dysku-ssd-na-usb">Jak włączyć TRIM w dysku SSD na USB</a>
      <ol>
        <li><a href="#ręczne-określenie-wartości-w-provisioning_mode-konfiguracja-unmap">Ręczne określenie wartości w provisioning_mode (konfiguracja UNMAP)</a></li>
        <li><a href="#wartości-dla-discard_max_bytes-i-discard_max_hw_bytes">Wartości dla discard_max_bytes i discard_max_hw_bytes</a></li>
      </ol>
    </li>
    <li><a href="#test-trim-dysku-ssd-na-usb">Test TRIM dysku SSD na USB</a></li>
    <li><a href="#reguła-dla-udev">Reguła dla UDEV</a></li>
    <li><a href="#podsumowanie">Podsumowanie</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Jakiś czas temu opisywałem <a href="https://morfikov.github.io/post/trim-discard-przy-luks-lvm-na-dysku-ssd-pod-debian-linux/">jak na Debianie włączyć obsługę mechanizmu TRIM</a> (realizowanego
przez polecenie <code>fstrim</code> ) na podpiętych do komputera dyskach SSD. Problem w tym, że dyski SSD, z
którymi będziemy wchodzić w interakcję, nie zawsze będą podłączane do dedykowanych portów
SATA/mSATA. Jak zachowa się zatem nasz linux, gdy będziemy chcieli podłączyć po portu USB
zewnętrzny dysk SSD? Przez zewnętrzny dysk USB nie mam na myśli dedykowanych zewnętrznych dysków
USB, bo te raczej nie powinny sprawiać kłopotów. Chodzi mi bardziej o wewnętrzne dyski SSD (np. ze
starego laptopa), które zamkniemy w dedykowanej obudowie USB, lub też będziemy taki dysk podłączać
na krótko za pomocą adaptera USB-SATA. W takich przypadkach zwykle kernel linux'a nie odważy się
włączyć wsparcia dla TRIM dla nośników SSD i tak właśnie się stało w przypadku mojego nowo
zakupionego dysku od Goodram, a konkretnie jest to model <code>SSDPR-CX400-02T-G2</code> , który to został
podłączony do portu USB3 mojego Raspberry PI (i Debiana) przy pomocy kabelka USB-SATA (Unitek
USB3.1 USB-A to 2.5&quot; SATA6G). Przez kilka miesięcy dysk sprawował się bez zarzutu ale ostatnio przy
próbie wgrania na niego danych (przez sieć), transfer spadł do dosłownie pojedynczych MiB/s.
Poszukałem trochę informacji i okazało się, że dla tego typu nośników <a href="https://www.jeffgeerling.com/blog/2020/enabling-trim-on-external-ssd-on-raspberry-pi">trzeba ręcznie włączyć
TRIM</a>, o ile będzie to w ogóle możliwe.</p>
<h2 id="czy-mój-dysk-ssd-na-usb-wspiera-trim">Czy mój dysk SSD na USB wspiera TRIM</h2>
<p>Ten nowo zakupiony dysk SSD ma w zasadzie działać w roli storage pod filmy/seriale odtwarzane na TV
podpiętym do mojego Raspberry Pi 4B. Dlaczego dysk SSD (i to jeszcze w technologi SLC), a nie dysk
HDD? Bo dyski SSD nie mają głowic magnetycznych i przy takim zastosowaniu (w roli dysku pod TV),
nawet dysk SSD SLC będzie o wiele żywotniejszy niż dyski HDD, w których głowica parkuje dosłownie
co kilka sekund. Może i istnieją sposoby, <a href="https://morfikov.github.io/post/parkowanie-glowicy-w-dyskach-wstern-digital/">by sobie poradzić z tym parkowaniem głowicy w dyskach
HDD</a> ale podejście producentów tych nośników do klientów sprawiło, że postanowiłem w końcu
pokazać im środkowy palec i pod storage wybrać dysk SSD. Z racji, że w zasadzie rzadko kiedy z tego
dysku coś będzie usuwane (chyba że dysk ulegnie zapełnieniu), to tą niezbyt dużą ilością cykli
wymazywania/zapisywania komórek flash (około 350) nie ma zbytnio się co przejmować. Podobnie sprawa
wygląda w kwestii wydajności, przynajmniej przy odczycie danych.</p>
<p>Po kilku miesiącach użytkowania tego dysku SSD zaszła potrzebna, by go nieco przeczyścić i tym
samym zrobić nieco wolnego miejsca pod nowe filmy i seriale. Problem w tym, że transfer po sieci w
pewnym momencie spadł mi ze 110 MiB/s do około 1-2 MiB/s i tak wisiał w menadżerze plików, a
postępu w kopiowaniu danych nie było żadnych (no dobra prawie żadnych). Myślałem, że może coś się
stało z procesem kopiowania (został przerwany czy zawiesił się) ale ten funkcjonował poprawnie.
Podejrzenie padło więc na mechanizm TRIM. Okazało się, że ten dysk SSD ma TRIM zupełnie wyłączony,
choć sam nośnik wsparcie dla TRIM posiada. Jak to możliwe? Wygląda na to, że w przypadku dysków
SSD podpinanych do portów USB komputera, ten cały TRIM może nieść ze sobą bardzo niemiłe
konsekwencje i dlatego jest domyślnie wyłączony.</p>
<p>By sprawdzić czy TRIM dla dysku SSD podpiętego do portu USB komputera jest aktywny i działa, możemy
albo skorzystać z polecenia <code>fstrim</code> na systemie plików takiego nośnika, albo też możemy posłużyć
się poleceniem <code>lsblk</code> .</p>
<p>W tym przypadku, polecenia <code>fstrim</code> zwróciło komunikat o braku wsparcia dla TRIM:</p>
<pre><code># fstrim -v /media/morfik/gdata
fstrim: /media/morfik/gdata: the discard operation is not supported
</code></pre>
<p>Jeśli zaś zajrzymy do wyjścia polecenia <code>lsblk</code> , to zobaczymy wartość 0B w kolumnie <code>DISC-MAX</code> ,
co też jednoznacznie nam mówi, że kernel wsparcia dla TRIM dla tego dysku z jakiegoś powodu nie
włączył:</p>
<pre><code># lsblk -D /dev/sdc
NAME   DISC-ALN DISC-GRAN DISC-MAX DISC-ZERO
sdc           0      512B       0B         0
└─sdc1        0      512B       0B         0
</code></pre>
<p>Jest to o tyle dziwne, że model dysku SSD <code>SSDPR-CX400-02T-G2</code> wsparcie dla mechanizmu TRIM jak
najbardziej posiada, co możemy odczytać z raportu
SMART ( <code>TRIM Command: Available, deterministic, zeroed</code> ):</p>
<pre><code># smartctl -x  /dev/sdc
smartctl 7.4 2023-08-01 r5530 [x86_64-linux-6.9.4-amd64] (local build)
Copyright (C) 2002-23, Bruce Allen, Christian Franke, www.smartmontools.org

=== START OF INFORMATION SECTION ===
Device Model:     SSDPR-CX400-02T-G2
Serial Number:    G44034700
LU WWN Device Id: 5 000000 0000027b9
Firmware Version: SN17595
User Capacity:    2,048,408,248,320 bytes [2.04 TB]
Sector Size:      512 bytes logical/physical
Rotation Rate:    Solid State Device
Form Factor:      2.5 inches
TRIM Command:     Available, deterministic, zeroed
Device is:        Not in smartctl database 7.3/5610
ATA Version is:   ACS-4 (minor revision not indicated)
SATA Version is:  SATA 3.2, 6.0 Gb/s (current: 6.0 Gb/s)
Local Time is:    Sun Jun 16 10:39:14 2024 CEST
SMART support is: Available - device has SMART capability.
SMART support is: Enabled
AAM feature is:   Unavailable
APM feature is:   Unavailable
Rd look-ahead is: Enabled
Write cache is:   Enabled
DSN feature is:   Unavailable
ATA Security is:  Disabled, NOT FROZEN [SEC1]
Wt Cache Reorder: Enabled

=== START OF READ SMART DATA SECTION ===
SMART overall-health self-assessment test result: PASSED

General SMART Values:
Offline data collection status:  (0x00) Offline data collection activity
                                        was never started.
                                        Auto Offline Data Collection: Disabled.
Self-test execution status:      (   0) The previous self-test routine completed
                                        without error or no self-test has ever
                                        been run.
Total time to complete Offline
data collection:                (   33) seconds.
Offline data collection
capabilities:                    (0x7b) SMART execute Offline immediate.
                                        Auto Offline data collection on/off support.
                                        Suspend Offline collection upon new
                                        command.
                                        Offline surface scan supported.
                                        Self-test supported.
                                        Conveyance Self-test supported.
                                        Selective Self-test supported.
SMART capabilities:            (0x0003) Saves SMART data before entering
                                        power-saving mode.
                                        Supports SMART auto save timer.
Error logging capability:        (0x01) Error logging supported.
                                        General Purpose Logging supported.
Short self-test routine
recommended polling time:        (   2) minutes.
Extended self-test routine
recommended polling time:        (  85) minutes.
Conveyance self-test routine
recommended polling time:        (   2) minutes.
SCT capabilities:              (0x0031) SCT Status supported.
                                        SCT Feature Control supported.
                                        SCT Data Table supported.

SMART Attributes Data Structure revision number: 20
Vendor Specific SMART Attributes with Thresholds:
ID# ATTRIBUTE_NAME          FLAGS    VALUE WORST THRESH FAIL RAW_VALUE
  5 Reallocated_Sector_Ct   PO--C-   100   100   010    -    0
  9 Power_On_Hours          -O--C-   100   100   000    -    273
 12 Power_Cycle_Count       -O--C-   100   100   000    -    100
164 Unknown_Attribute       ------   100   100   000    -    21476540424
165 Unknown_Attribute       ------   100   100   000    -    26
166 Unknown_Attribute       ------   100   100   000    -    5
167 Unknown_Attribute       -O---K   100   100   000    -    8
194 Temperature_Celsius     -O---K   029   029   000    -    29 (Min/Max 24/40)
199 UDMA_CRC_Error_Count    -O--C-   100   100   000    -    0
241 Total_LBAs_Written      -O--CK   100   100   000    -    1776
242 Total_LBAs_Read         -O--CK   100   100   000    -    396
                            ||||||_ K auto-keep
                            |||||__ C event count
                            ||||___ R error rate
                            |||____ S speed/performance
                            ||_____ O updated online
                            |______ P prefailure warning

General Purpose Log Directory Version 1
SMART           Log Directory Version 1 [multi-sector log support]
Address    Access  R/W   Size  Description
0x00       GPL,SL  R/O      1  Log Directory
0x01           SL  R/O      1  Summary SMART error log
0x02           SL  R/O     51  Comprehensive SMART error log
0x03       GPL     R/O     64  Ext. Comprehensive SMART error log
0x04       GPL,SL  R/O      8  Device Statistics log
0x06           SL  R/O      1  SMART self-test log
0x07       GPL     R/O      1  Extended self-test log
0x09           SL  R/W      1  Selective self-test log
0x10       GPL     R/O      1  NCQ Command Error log
0x11       GPL     R/O      1  SATA Phy Event Counters log
0x30       GPL,SL  R/O      9  IDENTIFY DEVICE data log
0x80-0x9f  GPL,SL  R/W     16  Host vendor specific log
0xe0       GPL,SL  R/W      1  SCT Command/Status
0xe1       GPL,SL  R/W      1  SCT Data Transfer

SMART Extended Comprehensive Error Log Version: 1 (64 sectors)
No Errors Logged

SMART Extended Self-test Log Version: 1 (1 sectors)
Num  Test_Description    Status                  Remaining  LifeTime(hours)  LBA_of_first_error
# 1  Extended offline    Completed without error       00%         1         -

SMART Selective self-test log data structure revision number 1
 SPAN  MIN_LBA  MAX_LBA  CURRENT_TEST_STATUS
    1        0        0  Not_testing
    2        0        0  Not_testing
    3        0        0  Not_testing
    4        0        0  Not_testing
    5        0        0  Not_testing
Selective self-test flags (0x0):
  After scanning selected spans, do NOT read-scan remainder of disk.
If Selective self-test is pending on power-up, resume after 0 minute delay.

SCT Status Version:                  3
SCT Version (vendor specific):       1 (0x0001)
Device State:                        Active (0)
Current Temperature:                    32 Celsius
Power Cycle Min/Max Temperature:      ?/32 Celsius
Lifetime    Min/Max Temperature:      ?/ ? Celsius
Under/Over Temperature Limit Count:   0/0

SCT Temperature History Version:     2
Temperature Sampling Period:         1 minute
Temperature Logging Interval:        1 minute
Min/Max recommended Temperature:     -127/127 Celsius
Min/Max Temperature Limit:           -127/127 Celsius
Temperature History Size (Index):    478 (369)

Index    Estimated Time   Temperature Celsius
 370    2024-06-16 02:42     ?  -
 371    2024-06-16 02:43    30  ***********
...
 369    2024-06-16 10:39    32  *************

SCT Error Recovery Control command not supported

Device Statistics (GP Log 0x04)
Page  Offset Size        Value Flags Description
0x01  =====  =               =  ===  == General Statistics (rev 1) ==
0x01  0x008  4             100  ---  Lifetime Power-On Resets
0x01  0x010  4             273  ---  Power-on Hours
0x01  0x018  6      3725681472  ---  Logical Sectors Written
0x01  0x020  6        13529637  ---  Number of Write Commands
0x01  0x028  6       832035662  ---  Logical Sectors Read
0x01  0x030  6         3014905  ---  Number of Read Commands
0x07  =====  =               =  ===  == Solid State Device Statistics (rev 1) ==
0x07  0x008  1               5  N--  Percentage Used Endurance Indicator
                                |||_ C monitored condition met
                                ||__ D supports DSN
                                |___ N normalized value

Pending Defects log (GP Log 0x0c) not supported

SATA Phy Event Counters (GP Log 0x11)
ID      Size     Value  Description
0x0001  2            0  Command failed due to ICRC error
0x0003  2            0  R_ERR response for device-to-host data FIS
0x0004  2            0  R_ERR response for host-to-device data FIS
0x0006  2            0  R_ERR response for device-to-host non-data FIS
0x0007  2            0  R_ERR response for host-to-device non-data FIS
0x0008  2            0  Device-to-host non-data FIS retries
0x0009  4            0  Transition from drive PhyRdy to drive PhyNRdy
0x000a  4            1  Device-to-host register FISes sent due to a COMRESET
0x000f  2            0  R_ERR response for host-to-device data FIS, CRC
0x0010  2            0  R_ERR response for host-to-device data FIS, non-CRC
0x0012  2            0  R_ERR response for host-to-device non-data FIS, CRC
0x0013  2            0  R_ERR response for host-to-device non-data FIS, non-CRC
</code></pre>
<p>Zatem wsparcie dla TRIM w firmware dysku SSD jest ale pozostaje ono nieaktywne w systemie. Problem
tkwi w adapterze USB-SATA (czy też zewnętrznej obudowie USB), za pomocą którego ten nośnik SSD
został podpięty do portu USB komputera. Najwyraźniej z jakiegoś powodu taka konfiguracja upośledza
ten cały mechanizm TRIM.</p>
<h2 id="problematyczny-adapter-usb-sata-obudowa-usb">Problematyczny adapter USB-SATA (obudowa USB)</h2>
<p>Zgodnie z tym, co <a href="https://superuser.com/questions/1740543/no-trim-discard-with-a-sata-ssd-connected-through-an-uasp-enabled-usb-adapter">można wyczytać tutaj</a>, taki adapter USB-SATA ma spełniać dwie główne funkcje.
Pierwszą z nich jest interfejs UAS, który jest interfejsem USB do kapsułkowania (enkapsulacji)
poleceń protokołu SCSI. Drugą zaś jest translacja, gdzie polecenia SCSI są konwertowane na
polecenia ATA. Zestaw poleceń określonych przez protokół SCSI jest spory i nie wszystkie
urządzenia SCSI wspierają wszystkie te polecenia. Dlatego też istnieje kilka poleceń, które mogą
zostać wykorzystane do UNMAP (TRIM to polecenie ATA, UNMAP to jego analog SCSI). Translator
SCSI-ATA może wspierać jedno z tych poleceń, może także wspierać kilka lub wszystkie ale też może
nie wspierać żadnego. W przypadku tego ostatniego nie będzie możliwy UNMAP bloku dysku SSD. Dlatego
też trzeba się zaopatrzyć w taki adapter USB-SATA, który wspiera choć jedno polecenie UNMAP.</p>
<p>Poniżej jest trochę informacji na temat samego adaptera USB-SATA (Unitek USB3.1 USB-A to 2.5&quot;
SATA6G):</p>
<pre><code># lsusb
...
Bus 004 Device 003: ID 174c:55aa ASMedia Technology Inc. ASM1051E SATA 6Gb/s bridge, ASM1053E SATA 6Gb/s bridge, ASM1153 SATA 3Gb/s bridge, ASM1153E SATA 6Gb/s bridge
...

# lsusb -t
...
/:  Bus 004.Port 001: Dev 001, Class=root_hub, Driver=xhci_hcd/4p, 5000M
    |__ Port 001: Dev 003, If 0, Class=Mass Storage, Driver=uas, 5000M
...

# lsusb -vvv -d 174c:55aa

Bus 004 Device 003: ID 174c:55aa ASMedia Technology Inc. ASM1051E SATA 6Gb/s bridge, ASM1053E SATA 6Gb/s bridge, ASM1153 SATA 3Gb/s bridge, ASM1153E SATA 6Gb/s bridge
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               3.10
  bDeviceClass            0 [unknown]
  bDeviceSubClass         0 [unknown]
  bDeviceProtocol         0
  bMaxPacketSize0         9
  idVendor           0x174c ASMedia Technology Inc.
  idProduct          0x55aa ASM1051E SATA 6Gb/s bridge, ASM1053E SATA 6Gb/s bridge, ASM1153 SATA 3Gb/s bridge, ASM1153E SATA 6Gb/s bridge
  bcdDevice            1.00
  iManufacturer           2 asmedia
  iProduct                3 ASMT1153e
  iSerial                 1 123456789394
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength       0x0079
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          0
    bmAttributes         0xc0
      Self Powered
    MaxPower                0mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           2
      bInterfaceClass         8 Mass Storage
      bInterfaceSubClass      6 SCSI
      bInterfaceProtocol     80 Bulk-Only
      iInterface              0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0400  1x 1024 bytes
        bInterval               0
        bMaxBurst              15
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x02  EP 2 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0400  1x 1024 bytes
        bInterval               0
        bMaxBurst              15
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       1
      bNumEndpoints           4
      bInterfaceClass         8 Mass Storage
      bInterfaceSubClass      6 SCSI
      bInterfaceProtocol     98
      iInterface              0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0400  1x 1024 bytes
        bInterval               0
        bMaxBurst              15
        MaxStreams             32
        Data-in pipe (0x03)
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x02  EP 2 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0400  1x 1024 bytes
        bInterval               0
        bMaxBurst              15
        MaxStreams             32
        Data-out pipe (0x04)
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x83  EP 3 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0400  1x 1024 bytes
        bInterval               0
        bMaxBurst              15
        MaxStreams             32
        Status pipe (0x02)
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x04  EP 4 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0400  1x 1024 bytes
        bInterval               0
        bMaxBurst               0
        Command pipe (0x01)
Binary Object Store Descriptor:
  bLength                 5
  bDescriptorType        15
  wTotalLength       0x0016
  bNumDeviceCaps          2
  USB 2.0 Extension Device Capability:
    bLength                 7
    bDescriptorType        16
    bDevCapabilityType      2
    bmAttributes   0x0000f41e
      BESL Link Power Management (LPM) Supported
    BESL value     1024 us
    Deep BESL value    61440 us
  SuperSpeed USB Device Capability:
    bLength                10
    bDescriptorType        16
    bDevCapabilityType      3
    bmAttributes         0x00
    wSpeedsSupported   0x000e
      Device can operate at Full Speed (12Mbps)
      Device can operate at High Speed (480Mbps)
      Device can operate at SuperSpeed (5Gbps)
    bFunctionalitySupport   1
      Lowest fully-functional device speed is Full Speed (12Mbps)
    bU1DevExitLat          10 micro seconds
    bU2DevExitLat        2047 micro seconds
can't get debug descriptor: Resource temporarily unavailable
Device Status:     0x000d
  Self Powered
  U1 Enabled
  U2 Enabled
</code></pre>
<h2 id="ryzyko-utraty-danych-i-uszkodzenia-dysku-ssd">Ryzyko utraty danych i uszkodzenia dysku SSD</h2>
<p>Trzeba tutaj wyraźnie rozgraniczyć dwie rzeczy. To, że w firmware dysku SSD zaimplementowano
wsparcie dla TRIM nie oznacza z automatu, że kernel linux'a będzie do takiego nośnika przesyłał
takie żądania, przez co sam nośnik SSD może (i prawdopodobnie będzie) nam się zachowywać tak, jakby
wsparcia dla TRIM nie posiadał. Przyczyny mogą być różne, choć ta najpopularniejsza to błędy w
komunikacji między kernelem a dyskiem, co może prowadzić do uwalenia dysku lub utraty
zgromadzonych na nim danych. Dlatego też jeśli zaistnieją przesłanki, że TRIM nie powinien być
obsługiwany dla tego konkretnego dysku SSD, to kernel go nie włącza. Z reguły kernel linux'a ma
dobre powody by nie włączać na pewnych nośnika SSD obsługi mechanizmu TRIM. Niemniej jednak, w
pewnych przypadkach decyzja podjęta przez kernel może być niewłaściwa i trzeba będzie taki nośnik
SSD oznaczyć ręcznie, by kernel na nim TRIM włączył.</p>
<p>Jeśli nie jesteśmy przekonani co do włączania TRIM dla dysków SSD zamkniętych w zewnętrznych
obudowach USB czy też podłączanych za pomocą adaptera USB-SATA, to najlepszym rozwiązaniem dla nas
będzie wypięcie takiego nośnika z obudowy/adaptera i podłączenie go do slotu SATA w komputerze i
dopiero w takim przypadku zainicjowanie TRIM przez wydanie polecenia <code>fstrim</code> na podmontowanym
systemie plików. W taki sposób nie ma ryzyka utraty danych czy uszkodzenia samego dysku SSD,
niemniej jednak jeśli zapisujemy dużo danych na dysku, to takie ciągłe przepinanie mija się raczej
z celem.</p>
<h2 id="strony-vpd-vital-product-data">Strony VPD (Vital Product Data)</h2>
<p>Czytając dalej ten podlinkowany wyżej artykuł, możemy wyłapać informację, że ze względu na bogactwo
zestawu poleceń SCSI, sterownik kernela linux musi wiedzieć jakie funkcje są obsługiwane przez dane
urządzenie. Odbywa się to za pomocą stron informacyjnych, zwanych stronami VPD (Vital Product Data),
zwracanych przez urządzenie do sterownika.</p>
<p>Pierwszą stroną jest <code>Supported VPD pages</code>, która zawiera listę stron obsługiwanych przez
dane urządzenie. Zwykle sterownik wysyła zapytanie o tę pierwszą stronę, a następnie o
interesujące go strony, jeśli są one obsługiwane. Jeśli chodzi o funkcję UNMAP, interesującą nas
stroną jest strona <code>Logical block provisioning</code> .</p>
<p>Na linux'ach jesteśmy w stanie wysłać zapytanie o strony <code>Supported VPD pages</code> oraz
<code>Logical block provisioning</code> przy pomocy narzędzia <code>sg_vpd</code> (z pakietu <code>sg3-utils</code> ). Musimy
jedynie określić dysk, do którego zapytania powędrują:</p>
<p>Dla strony <code>Supported VPD pages</code> :</p>
<pre><code># sg_vpd -p bl /dev/sdc
Block limits VPD page (SBC):
  Write same non-zero (WSNZ): 0
  Maximum compare and write length: 0 blocks [Command not implemented]
  Optimal transfer length granularity: 1 blocks
  Maximum transfer length: 65535 blocks
  Optimal transfer length: 65535 blocks
  Maximum prefetch transfer length: 65535 blocks
  Maximum unmap LBA count: 4194240
  Maximum unmap block descriptor count: 1
  Optimal unmap granularity: 1 blocks
  Unmap granularity alignment valid: false
  Unmap granularity alignment: 0 [invalid]
  Maximum write same length: 0 blocks [not reported]
  Maximum atomic transfer length: 0 blocks [not reported]
  Atomic alignment: 0 [unaligned atomic writes permitted]
  Atomic transfer length granularity: 0 [no granularity requirement
  Maximum atomic transfer length with atomic boundary: 0 blocks [not reported]
  Maximum atomic boundary size: 0 blocks [can only write atomic 1 block]
</code></pre>
<p>Dla strony <code>Logical block provisioning</code> :</p>
<pre><code># sg_vpd --page=0xb2 /dev/sdc
# sg_vpd -p lbpv /dev/sdc
Logical block provisioning VPD page (SBC):
  Unmap command supported (LBPU): 1
  Write same (16) with unmap bit supported (LBPWS): 0
  Write same (10) with unmap bit supported (LBPWS10): 0
  Logical block provisioning read zeros (LBPRZ): 0
  Anchored LBAs supported (ANC_SUP): 0
  Threshold exponent: 0 [threshold sets not supported]
  Descriptor present (DP): 0
  Minimum percentage: 0 [not reported]
  Provisioning type: 0 (not known or fully provisioned)
  Threshold percentage: 0 [percentages not supported]
</code></pre>
<p>To co się rzuca w oczy, to fakt, że translator SCSI-ATA wspiera polecenie
UNMAP ( <code>Unmap command supported (LBPU)</code> ) ale nie wspiera <a href="https://linux.die.net/man/8/sg_write_same">poleceń WRITE SAME</a>,
tj. ( <code>Write same (16)</code> i <code>Write same (10)</code> ). Będzie to miało znaczenie w późniejszym procesie
konfiguracji TRIM dla tego nośnika SSD.</p>
<h3 id="brak-auto-konfiguracji-w-oparciu-o-vpd">Brak auto konfiguracji w oparciu o VPD</h3>
<p>Normalnie sterownik odczytałby te strony i odpowiednio skonfigurował urządzenie. Niemniej jednak,
istnieje ryzyko, że próba odczytania niektórych stron VPD może doprowadzić do
zablokowania (lock-up) lub też wręcz uszkodzenia nośnika SSD. Dlatego też deweloperzy kernela linux
zdecydowali się <a href="https://git.kernel.org/pub/scm/linux/kernel/git/mkp/linux.git/commit/?h=5.18/discovery&amp;id=916740efdd2208564decee40a6049674f2063811">domyślnie nie odpytywać stron VPD</a> dla urządzeń SCSI podłączonych przez USB i
nie konfigurować zaawansowanych funkcji, takich jak UNMAP.</p>
<h2 id="jak-włączyć-trim-w-dysku-ssd-na-usb">Jak włączyć TRIM w dysku SSD na USB</h2>
<p>W tym przypadku mamy do czynienia z dyskiem SSD od Goodram, konkretnie jest to
model <code>SSDPR-CX400-02T-G2</code> . Poniższe instrukcje zostały przetestowane tylko i wyłączenie z tym
dyskiem i jeśli nie mamy pewności co do obsługi TRIM/UNMAP w przypadku naszego dysku/adaptera
USB-SATA, to lepiej jest tych poniższych kroków nie przeprowadzać.</p>
<h3 id="ręczne-określenie-wartości-w-provisioning_mode-konfiguracja-unmap">Ręczne określenie wartości w provisioning_mode (konfiguracja UNMAP)</h3>
<p>Dobra wiadomość jest taka, że te powyżej opisane funkcje można skonfigurować z przestrzeni
użytkownika używając do tego celu pliku <code>/sys/block/*/device/scsi_disk/*/provisioning_mode</code>
lub <code>/sys/devices/**/scsi_disk/**/provisioning_mode</code> . Gdy podłączymy dysk SSD za pomocą adaptera
USB-SATA do portu USB komputera, to wartość w tym pliku będzie prawdopodobnie wskazywać na <code>full</code> :</p>
<pre><code># find /sys/ -name provisioning_mode -exec grep -H . {} + | sort
/sys/devices/pci0000:00/0000:00:14.0/usb4/4-1/4-1:1.0/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0/provisioning_mode:full
...
</code></pre>
<p>Możemy jednak tę wartość przestawić ręcznie zapisując powyższy plik. W tym przypadku pozostaje nam
w zasadzie jedynie <code>unmap</code> ponieważ ten dysk podłączony przez adapter USB-SATA obsługuje jedynie
polecenie UNMAP. Można także określić wartości (jeśli są wspierane ) <code>writesame_16</code> , <code>writesame_10</code> , <code>writesame_zero</code> oraz <code>disabled</code> .</p>
<p>W przypadku, gdy mamy więcej niż jeden dysk, dobrze jest upewnić się, że ta ścieżka powyżej jest
odpowiednia:</p>
<pre><code># lsscsi -liv
...
[6:0:0:0]    disk    SSDPR-CX 400-02T-G2       0     /dev/sdc   SSDPR-CX_400-02T-G2_123456789394-0:0
  state=running queue_depth=30 scsi_level=7 type=0 device_blocked=0 timeout=30
  dir: /sys/bus/scsi/devices/6:0:0:0  [/sys/devices/pci0000:00/0000:00:14.0/usb4/4-1/4-1:1.0/host6/target6:0:0/6:0:0:0]
list_ndevices: scandir: /sys/class/nvme/: No such file or directory
NVMe module may not be loaded
</code></pre>
<p>Mając ustaloną ścieżkę oraz informację, że adapter USB-SATA wspiera jedynie polecenie UNMAP,
zapisujemy stosowny plik w poniższy sposób:</p>
<pre><code># echo unmap &gt; /sys/devices/pci0000:00/0000:00:14.0/usb4/4-1/4-1:1.0/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0/provisioning_mode
</code></pre>
<p>Sprawdzamy, czy wartość została poprawnie ustawiona:</p>
<pre><code># cat /sys/devices/pci0000:00/0000:00:14.0/usb4/4-1/4-1:1.0/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0/provisioning_mode
unmap
</code></pre>
<h3 id="wartości-dla-discard_max_bytes-i-discard_max_hw_bytes">Wartości dla discard_max_bytes i discard_max_hw_bytes</h3>
<p>Sprawdzamy także co zostało ustawione w pliku <code>discard_max_bytes</code> i w <code>discard_max_hw_bytes</code> ,
które po włączeniu UNMAP zostaną automatycznie dostosowane (była tam wartość <code>0</code> ):</p>
<pre><code># cat /sys/block/sdc/queue/discard_max_bytes
4294966784

# cat /sys/block/sdc/queue/discard_max_hw_bytes
4294966784
</code></pre>
<p>Zgodnie z tym co <a href="https://wiki.gentoo.org/wiki/Discard_over_USB">można wyczytać na wiki Gentoo</a>, wartość którą widzimy tutaj, to ilość bajtów,
które mechanizm TRIM będzie w stanie wyczyścić w jednym podejściu. Możemy ją obliczyć posługując
się następującymi danymi:</p>
<pre><code># sg_vpd -p bl /dev/sdc
...
  Maximum unmap LBA count: 4194240
...
</code></pre>
<p>oraz</p>
<pre><code># sg_readcap -l /dev/sdc
...
   Logical block length=512 bytes
...
</code></pre>
<p>Mając informację o <code>Maximum unmap LBA count</code> oraz <code>Logical block length</code> , możemy ich wartości
pomnożyć przez siebie:</p>
<pre><code># echo '4194240*512' | bc
2147450880
</code></pre>
<p>Trochę to dziwne, że otrzymana wartość jest inna od tej domyślnie ustawionej. Nie wiem czy powinno
się zawierzyć tej automatycznie wykalkulowanej wartości, czy też tej obliczonej ręcznie. W każdym
razie jeśli nie chcemy zawierzać tej automatycznej, to wynik tego powyższego obliczenia możemy
przesłać do pliku <code>/sys/block/sdc/queue/discard_max_bytes</code> :</p>
<pre><code># echo 2147450880 &gt; /sys/block/sdc/queue/discard_max_bytes
</code></pre>
<p>Przeglądając pliki <code>discard_max_bytes</code> innych moich dysków SSD, wygląda na to, że jednak
wartość <code>2147450880</code> jest pewniejsza, bo inne nośniki mają ustawione właśnie <code>2147450880</code> . Jedyne
co mi przychodzi do głowy, to że ta różnica może wynikać ze sporo większego rozmiaru dysku
SSD (256GB vs. 2TB).</p>
<p>W zasadzie to te dwa pliki ( <code>discard_max_bytes</code> (RW) i <code>discard_max_hw_bytes</code> (RO) ) służą jedynie
do zmniejszenia ilości danych/bloków, które mogą zostać wyczyszczone w pojedynczej operacji TRIM.
Czasem może się zdarzyć tak, że gdy system będzie czyścił zbyt wiele bloków naraz, to wzrosną nam
dość znacznie opóźnienia w zapytaniach do dysku SSD, co zdegraduje jego wydajność. Dlatego
istnieje taki mechanizm bezpieczeństwa w kernelu, by ilość tych danych ograniczyć, co powinno
zredukować opóźnienia. Ja bym pozostawił wartość domyślną i jedynie w przypadku ewentualnej
odczuwalnej degradacji wydajności dysku SSD tę wartość w pliku <code>discard_max_bytes</code> bym próbował
przepisać.</p>
<p>Tak czy inaczej w wyjściu <code>lsblk</code> na pozycji <code>DISC-MAX</code> powinna już być widoczna jakaś wartość:</p>
<pre><code># lsblk --discard /dev/sdc
NAME   DISC-ALN DISC-GRAN DISC-MAX DISC-ZERO
sdc           0      512B       4G         0
└─sdc1        0      512B       4G         0
</code></pre>
<h2 id="test-trim-dysku-ssd-na-usb">Test TRIM dysku SSD na USB</h2>
<p>W zasadzie jedyne co zrobiliśmy w przypadku tego dysku SSD to zapisaliśmy <code>unmap</code> w
pliku <code>provisioning_mode</code> i to powinno włączyć mechanizm TRIM dla tego nośnika SSD podpiętego przez
ten adapter USB-SATA do portu USB komputera. Czy tak się faktycznie stało, możemy ocenić montując
system plików dowolnej partycji dysku i wydając w terminalu polecenie <code>fstrim</code> :</p>
<pre><code># fstrim -v /media/morfik/gdata
/media/morfik/gdata: 482.5 GiB (518127964160 bytes) trimmed
</code></pre>
<p>Jak widać tym razem polecenie <code>fstrim</code> na tym dysku zadziałało. W zależności od ilości bloków
przeznaczonych do wyczyszczenia, to powyższe polecenie może zająć dłuższą chwilę. Po jego
wykonaniu dobrze jest dać dyskowi chwilę na ogarnięcie się. Z tego co zaobserwowałem, to
bezpośrednio po wykonaniu polecenia <code>fstrim</code> wydajność dysku nie powraca od razu do tej wyjściowej.
Potrzebnych jest kilka-kilkanaście dodatkowych minut, by transfer z paru MiB/s powrócił do tego, co
było przed zapełnieniem się dysku.</p>
<p>Po odczekaniu chwili, odmontowujemy partycję i ponownie ją montujemy. Jeśli jesteśmy w stanie
odczytać dane zgromadzone na dysku SSD, to znaczy, że wszystko jest w porządku i możemy przejść do
napisania reguły dla UDEV'a dla tego nośnika.</p>
<h2 id="reguła-dla-udev">Reguła dla UDEV</h2>
<p>Sposób z zapisywaniem pliku <code>provisioning_mode</code> ma efekt jedynie tymczasowy i działa jedynie do
momentu odłączenia dysku SSD od komputera. Po ponownym podłączeniu trzeba by ponownie zapisać
wspomniany plik. Jest to mało praktyczne i przydałoby się napisać regułę dla UDEV'a, która za nas
automatycznie dostosuje ten plik po podpięciu dysku do portu USB.</p>
<p>Edytujemy (lub tworzymy) plik <code>/etc/udev/rules.d/10-trim.rules</code> i dodajemy do niego poniższą
zawartość:</p>
<pre><code># SSD disk Goodram SSDPR-CX400-02T-G2 over Unitek USB3.1 USB-A to 2.5&quot; SATA6G USB-SATA adapter
#
ACTION==&quot;add|change&quot;, ATTRS{idVendor}==&quot;174c&quot;, ATTRS{idProduct}==&quot;55aa&quot;, SUBSYSTEM==&quot;scsi_disk&quot;, ATTR{provisioning_mode}=&quot;unmap&quot;
</code></pre>
<p>Przeładowujemy politykę UDEV'a i patrzymy czy plik <code>provisioning_mode</code> zawiera już odpowiednią
wartość (dla pewności dobrze jest odłączyć dysk od portu USB i podpiąć go ponownie):</p>
<pre><code># udevadm control --reload-rules
# udevadm trigger --type=devices --action=change

# cat /sys/devices/pci0000:00/0000:00:14.0/usb4/4-1/4-1:1.0/host6/target6:0:0/6:0:0:0/scsi_disk/6:0:0:0/provisioning_mode
unmap
</code></pre>
<p>Jak widać, <code>unmap</code> został już ustawiony automatycznie.</p>
<h2 id="podsumowanie">Podsumowanie</h2>
<p>Przyznam, że gdy kupowałem dysk SSD z zamiarem używania go po USB jako storage, nie byłem świadomy,
że TRIM w takiej sytuacji nie będzie działał z automatu oraz, że próba jego włączenia może okazać
się katastrofalna w skutkach. Na szczęście, w przypadku tego dysku SSD nic złego się nie wydarzyło,
dane na dysku są i można je odczytać, a sam nośnik działa do tej pory, z nieco większą wydajnością.
Dlatego też jeśli zamierzamy kupić dysk SSD i podłączać go przez adaptery/obudowy USB-SATA, to
lepiej upewnić się, że ta obudowa czy adapter wspierają TRIM/UNMAP, bo jeśli tak nie będzie, to
trzeba będzie liczyć się z transferami rzędu pojedynczych MiB z chwilą, gdy dysk po raz pierwszy
się zapełni.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/debian/">Debian</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/ssd/">Ssd</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/trim/">Trim</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/discard/">Discard</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/ext4/">Ext4</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/udev/">Udev</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/usb/">Usb</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f&amp;text=TRIM%2fUNMAP%20w%20dyskach%20SSD%20pod%c5%82%c4%85czonych%20via%20adapter%20USB-SATA%20na%20linux" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f&amp;title=TRIM%2fUNMAP%20w%20dyskach%20SSD%20pod%c5%82%c4%85czonych%20via%20adapter%20USB-SATA%20na%20linux" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f&amp;title=TRIM%2fUNMAP%20w%20dyskach%20SSD%20pod%c5%82%c4%85czonych%20via%20adapter%20USB-SATA%20na%20linux" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f&title=TRIM%2fUNMAP%20w%20dyskach%20SSD%20pod%c5%82%c4%85czonych%20via%20adapter%20USB-SATA%20na%20linux" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f&amp;title=TRIM%2fUNMAP%20w%20dyskach%20SSD%20pod%c5%82%c4%85czonych%20via%20adapter%20USB-SATA%20na%20linux" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2ftrim-unmap-w-dyskach-ssd-podlaczonych-via-adapter-usb-sata-na-linux%2f&description=TRIM%2fUNMAP%20w%20dyskach%20SSD%20pod%c5%82%c4%85czonych%20via%20adapter%20USB-SATA%20na%20linux" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/trim-discard-przy-luks-lvm-na-dysku-ssd-pod-debian-linux/">Trim/discard przy LUKS/LVM na dysku SSD pod Debian linux</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/analiza-systemu-plikow-ext4-pod-katem-formatowania-wiekszych-dyskow-pod-linux/">Analiza systemu plików EXT4 pod kątem formatowania większych dysków pod linux</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/wybudzanie-linuxa-ze-stanu-uspienia-za-sprawa-myszy/">Wybudzanie linux&#39;a ze stanu uśpienia za sprawą myszy</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/montowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit/">Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/czym-jest-online-ext4-metadata-check-w-linuxowym-lvm/">Czym jest Online ext4 Metadata Check w linux&#39;owym LVM</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zmiana-identyfikatora-uuid/">Zmiana identyfikatora UUID systemu plików EXT4 i kontenera LUKS</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ext4/">Zmiana rozmiaru partycji EXT4</a></li>
		
	</ul>
</div>

	<div id="comments">
		<script src="https://utteranc.es/client.js"
        repo="morfikov/morfitronik-comments"
        issue-term="og:title"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>

	</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://mastodon.social/@morfik">
			<svg class="social__icon" aria-label="Mastodon" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M416 197c0-74-49-96-49-96-42-22-172-24-222 0 0 0-49 22-49 96v59c2 72 14 145 81 162 33 9 89 18 140-6l-2-27s-27 7-58 7c-74 2-67-39-70-52 0 0 51 17 137 6 42-6 80-32 85-56 8-38 7-93 7-93zm-58 96h-35v-88c0-18-8-27-23-27-18 0-27 11-27 33v47h-34v-47c0-22-9-33-27-33-15 0-23 9-23 27v88h-35v-91c0-18 5-60 52-60 39 0 50 37 50 37s10-37 50-37c45 0 52 42 52 60v91z"/></svg>
		</a>
</div>
	<div class="footer__copyright">© 2025 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
const images = Array.from(document.querySelectorAll(".entry__content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null,  
    background: 'rgba(0, 0, 0, 0.8)'
  });
});
</script>
</body>
</html>
