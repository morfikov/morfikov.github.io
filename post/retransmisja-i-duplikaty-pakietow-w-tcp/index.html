<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Retransmisja i duplikaty pakietów w TCP | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Retransmisja i duplikaty pakietów w TCP" />
<meta property="og:description" content="Retransmisja pakietu w przypadku sieci opartych na
protokołach TCP/IP nie jest niczym niezwykłym. Oczywiście, pozostaje kwestia samego realizowania
tego przedsięwzięcia ale generalnie rzecz biorąc, systemy linux&#39;owe mają szereg opcji w kernelu,
które możemy sobie dostosować konfigurując tym samym, to w jaki sposób nasz system reaguje na
zjawisko utraty pakietów podczas ich przesyłu między dwoma punktami sieciowymi." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/retransmisja-i-duplikaty-pakietow-w-tcp/" />
<meta property="article:published_time" content="2015-09-23T19:31:27+00:00" />
<meta property="article:modified_time" content="2015-09-23T19:31:27+00:00" />

		<meta itemprop="name" content="Retransmisja i duplikaty pakietów w TCP">
<meta itemprop="description" content="Retransmisja pakietu w przypadku sieci opartych na
protokołach TCP/IP nie jest niczym niezwykłym. Oczywiście, pozostaje kwestia samego realizowania
tego przedsięwzięcia ale generalnie rzecz biorąc, systemy linux&#39;owe mają szereg opcji w kernelu,
które możemy sobie dostosować konfigurując tym samym, to w jaki sposób nasz system reaguje na
zjawisko utraty pakietów podczas ich przesyłu między dwoma punktami sieciowymi.">
<meta itemprop="datePublished" content="2015-09-23T19:31:27+00:00" />
<meta itemprop="dateModified" content="2015-09-23T19:31:27+00:00" />
<meta itemprop="wordCount" content="1874">



<meta itemprop="keywords" content="tcp,sysctl,sieć," />

		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Retransmisja i duplikaty pakietów w TCP"/>
<meta name="twitter:description" content="Retransmisja pakietu w przypadku sieci opartych na
protokołach TCP/IP nie jest niczym niezwykłym. Oczywiście, pozostaje kwestia samego realizowania
tego przedsięwzięcia ale generalnie rzecz biorąc, systemy linux&#39;owe mają szereg opcji w kernelu,
które możemy sobie dostosować konfigurując tym samym, to w jaki sposób nasz system reaguje na
zjawisko utraty pakietów podczas ich przesyłu między dwoma punktami sieciowymi."/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Retransmisja i duplikaty pakietów w TCP</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2015-09-23T19:31:27Z">Opublikowano: 23/09/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Retransmisja i duplikaty pakietów w TCP</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#wyliczanie-czasu-oczekiwania-na-retransmisję-rto">Wyliczanie czasu oczekiwania na retransmisję (RTO)</a></li>
    <li><a href="#nadmierne-retransmisje">Nadmierne retransmisje</a></li>
    <li><a href="#szybka-retransmisja">Szybka retransmisja</a></li>
    <li><a href="#wczesna-retransmisja">Wczesna retransmisja</a>
      <ol>
        <li><a href="#tail-loss-probe-tlp">Tail Loss Probe (TLP)</a></li>
      </ol>
    </li>
    <li><a href="#selektywna-retransmisja">Selektywna retransmisja</a></li>
    <li><a href="#retransmisja-pakietów-syn">Retransmisja pakietów SYN</a>
      <ol>
        <li><a href="#retransmisja-pakietów-syn-ack">Retransmisja pakietów SYN-ACK</a></li>
      </ol>
    </li>
    <li><a href="#zbędna-retransmisja-spurious-retransmission">Zbędna retransmisja (Spurious retransmission)</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p><a href="https://pl.wikipedia.org/wiki/Retransmisja">Retransmisja</a> pakietu w przypadku sieci opartych na
protokołach TCP/IP nie jest niczym niezwykłym. Oczywiście, pozostaje kwestia samego realizowania
tego przedsięwzięcia ale generalnie rzecz biorąc, systemy linux'owe mają szereg opcji w kernelu,
które możemy sobie dostosować konfigurując tym samym, to w jaki sposób nasz system reaguje na
zjawisko utraty pakietów podczas ich przesyłu między dwoma punktami sieciowymi.</p>
<h2 id="wyliczanie-czasu-oczekiwania-na-retransmisję-rto">Wyliczanie czasu oczekiwania na retransmisję (RTO)</h2>
<p>Czas oczekiwania na retransmisję (RTO -- Retransmission TimeOut) jest oparty na zmierzonej wartości
RTT (Round-Trip Time) pomiędzy nadawcą i odbiorcą. By zapobiec zbędnym retransmisjom segmentów,
które uległy jedynie opóźnieniu i nie zostały zgubione, minimalne RTO (stała TCP_RTO_MIN
zdefiniowana w kenrelu) zostało ustawione na minimum 200ms. Możemy się o tym przekonać analizując
wyjście <code>ss -i</code> , gdzie nie znajdziemy wpisu z RTO &lt;200 .</p>
<p>Jeśli się przyjrzymy uważniej, dostrzeżemy, że pakiety <code>SYN</code> mają jakąś niestandardową wartość,
która sugeruje iż te pakiety nie są podpięte pod tę powyższą zasadę wyliczania czasu RTO. W sumie
nie może być przecież inaczej, bo pakiety <code>SYN</code> rozpoczynają nowe połączenie i żaden pakiet z
odpowiedzią jeszcze nie dotarł do nadawcy. W efekcie czego nie ma jak oszacować RTT i na jego
podstawie wyliczyć RTO. Dlatego też pakiety <code>SYN</code> mają przypisaną wartość RTO, która przyjmuje 1
sekundę. Z tym, że każdy retransmitowany pakiet <code>SYN</code> ma zwiększoną wartość RTO dwukrotnie:</p>
<pre><code>pakiet SYN | czas oczekiwania na retransmisję (RTO)
-----------+-----------------------------------------
     1     |   1
     2     |   1+2=3
     3     |   1+2+4=7
     4     |   1+2+4+8=15
     5     |   1+2+4+8+16=31
     6     |   1+2+4+8+16+32=63
     7     |   1+2+4+8+16+32+64=127
</code></pre>
<p>Zatem jeśli RTO pakietu <code>SYN</code> wynosi 1 sekundę i ten pakiet nie dotrze do miejsca przeznaczenia, to
jego retransmisja nastąpi po jednej sekundzie. Jeśli i ten pakiet nie zostanie dostarczony, to
kolejny będzie wysłany za kolejne dwie sekundy, czyli łącznie po trzech. Z kolei następny pakiet za
dodatkowe cztery, itd.</p>
<h2 id="nadmierne-retransmisje">Nadmierne retransmisje</h2>
<p>Nadmierne retransmisje tego samego segmentu przez stos TCP wskazują na pewne problemy z połączeniem
na jego drugim końcu lub też gdzieś po drodze. Dlatego w linux'owym kernelu mamy możliwość
określenia dwóch progów: <code>tcp_retries1</code> oraz <code>tcp_retries2</code> , które mają za zadanie zliczać ilość
dokonanych retransmisji w przypadku poszczególnych pakietów. Gdy zostanie przekroczony pierwszy próg
(domyślnie ma wartość 3), stos TCP zgłasza warstwie sieciowej, że prawdopodobnie są jakieś problemy
z takim połączeniem. W przypadku gdy ilość retransmisji tego samego pakietu przekroczy wartość
zdefiniowaną w drugim progu (domyślnie 15), połączenie zostanie zakończone.</p>
<p>Jeśli chcemy określić sobie te progi ręcznie, do w pliku <code>/etc/sysctl.conf</code> dodajemy te dwa poniższe
wpisy:</p>
<pre><code>net.ipv4.tcp_retries1 = 3
net.ipv4.tcp_retries2 = 7
</code></pre>
<h2 id="szybka-retransmisja">Szybka retransmisja</h2>
<p>W przypadku normalnej retransmisji, serwer musi czekać na timeout otrzymania pakietu <code>ACK</code> od
odbiorcy. Jeśli chodzi o szybką retransmisję, to system klienta reaguje w taki sposób, że na każdy
otrzymany poza kolejnością pakiet wysyła zduplikowane potwierdzenie <code>ACK</code> . Jeśli serwer otrzyma
kilka takich pakietów (zwykle 3), musi natychmiast wstrzymać transmisję następnych danych i dokonać
retransmisji zagubionego segmentu. Dopiero po otrzymaniu od klienta potwierdzenia tego pakietu,
transmisja wraca do normy.</p>
<p>Poniżej jest przykładowa sytuacja, gdzie nastąpiła szybka retransmisja pakietu:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2015/07/1.szybka-retransmisja-pakietu-wireshark.png" alt=""    class="huge"></p>
<p>Jak widzimy, pakiet 344 został dostarczony do klienta i potwierdzenie (254041) w pakiecie 345
zostało wysłane do nadawcy. Następny pakiet się zagubił i do klienta dotarł inny pakiet, który ma
zły numer sekwencyjny. W pakiecie 347, klient wysyła duplikat potwierdzenia z numerem takim jak był
wcześniej, tj. 254041, sygnalizując tym samym, że prawdopodobnie jakiś pakiet uległ zagubieniu.
Jako, że część danych jest w tranzycie, tj. została wcześniej przesłana przez serwer, to kilka
kolejnych segmentów dociera do klienta. I jak widzimy, pakiet 348 oraz 350, to kolejne segmenty z
danymi i każdy z nich ma inny numer sekwencyjny, których klient nie może jeszcze potwierdzić,
dlatego też wysyła kolejne zduplikowane pakiety <code>ACK</code> . Po tym jak trzeci duplikat dociera do
serwera, następuje szybka retransmisja zagubionego segmentu (pakiet 352). Po jego dotarciu do
klienta, ten potwierdza odbiór danych, z tym, że nie tylko tego segmentu ale również wszystkich
pozostałych, które w między czasie do niego doszły. Robi to także w pojedynczym pakiecie <code>ACK</code> .
Jego numer potwierdzenia to 259881 i jak łatwo można policzyć odejmując ten poprzedni numer
potwierdzenia (254041), daje nam to 5840 bajtów, czyli cztery zaakceptowane segmenty (1460 bajtów
każdy) -- jeden zagubiony i trzy otrzymane poza kolejnością.</p>
<p>Cały mechanizm szybkiej retransmisji pakietów zależy od <a href="https://morfikov.github.io/post/sack-czyli-selektywne-potwierdzenia-pakietow/">selektywnych potwierdzeń
SACK</a> i jeśli nie mamy
włączonej ich obsługi, nie aktywujemy funkcji odpowiedzialnej za szybką retransmisję.</p>
<h2 id="wczesna-retransmisja">Wczesna retransmisja</h2>
<p>Mechanizm wczesnej retransmisji (Early Retransmit) pozwala w pewnych sytuacjach zredukować liczbę
zduplikowanych pakietów <code>ACK</code> , które są potrzebne by zapoczątkować z kolei proces szybkiej
retransmisji zagubionego segmentu. Innymi słowy, stos TCP jest w stanie odzyskać zagubiony segment
wcześniej, bo nie musi czekać aż upłynie czas oczekiwania na retransmisję. Ten mechanizm przydaje
się bardzo w przypadku gdy w grę wchodzi niewielkie okno zatorowe (Congestion Window), gdzie zwykle
nie możliwe jest wygenerowanie wymaganej liczby zduplikowanych pakietów <code>ACK</code>.</p>
<p>Małe okna zatorowe mogą pojawić się za sprawą wielu czynników, np. gdy połączenie zostało
ograniczone przez jakiś algorytm przeciwzatorowy, czy też BDP (Bandwidth-Delay Product) jest zbyt
mały. Mały rozmiar okna może być także wynikiem początkowej fazy wolnego startu lub rozgłaszanego
okna/bufora odbiorczego (Receive Window) w pakietach, czy też zostać ograniczony za sprawą
aplikacji, gdzie ilość danych do przesłania na drugą stronę jest niewielka, np. przy zakończeniu
połączenia.</p>
<h3 id="tail-loss-probe-tlp">Tail Loss Probe (TLP)</h3>
<p>Czas oczekiwania na retransmisję pakietu jest bardzo szkodliwy gdy w grę wchodzą krótkie połączenia,
np. z serwerem www, gdzie taki timeout często zajmuje więcej czasu niż cała lub też pozostała część
danej transakcji. Szybka czy też wczesna retransmisja pakietu nie zawsze może okazać się pomocna. W
przypadku gdy ma miejsce koniec połączenia, to nie ma więcej pakietów, które można przesłać. Jeśli
taki pakiet, który kończy przesył danych, ulegnie zagubieniu, trzeba czekać aż wybije zegar RTO (w
przypadku linux'a to min. 200ms) i tu właśnie do gry wchodzi <a href="https://tools.ietf.org/html/draft-dukkipati-tcpm-tcp-loss-probe-01">algorytm Tail Loss
Probe</a>. Trzeba jednak zaznaczyć,
że opisana wyżej sytuacja nie jest jedyną, w której algorytm TLP znajduje zastosowanie. Generalnie
rzecz biorąc, są to wszystkie sytuacje, gdzie nadawca nie otrzymuje potwierdzenia przez określony
przedział czasu i nie może z jakiegoś powodu przesłać następnej porcji danych, czyli gdzie ryzyko
oczekiwania na RTO jest wysokie.</p>
<p>TLP został zaprojektowany z myślą o nadawcy w procesie komunikacji i wykorzystywany jest jedynie w
przypadku połączeń otwartych (stan Open), gdzie nadawca otrzymuje pakiety <code>ACK</code> w odpowiedniej
kolejności i nie zanotował on jeszcze jakiejkolwiek utraty pakietu. Musi być także włączony
mechanizm SACK.</p>
<p>W przypadku gdy ma miejsce koniec przesyłu danych i nastąpi utrata ostatniego segmentu, TLP zaczyna
wysyłać pakiety-próbki (Loss Probe) w czasie 2xRTT (Probe Timeout). Te próbki pakietów prowokują
odbiorcę by wysłał duplikaty potwierdzeń, które z kolei zainicjują proces szybkiej retransmisji tego
zagubionego segmentu bez potrzeby czekania aż wybije zegar RTO.</p>
<p>Zarówno mechanizm wczesnej retransmisji jak i algorytm TLP w kernelu linux'owym są wpięte pod jedną
zmienną, którą możemy zmienić via plik <code>/etc/sysctl.conf</code> :</p>
<pre><code>net.ipv4.tcp_early_retrans = 3
</code></pre>
<p>W przypadku ustawienia wartości <code>0</code> lub <code>1</code> , wczesne retransmisje zostaną odpowiednio wyłączone i
włączone. Możemy także podać wartość <code>2</code> i w takim przypadku zostanie włączony mechanizm wczesnych
retransmisji ale szybkie odtwarzanie (fast recovery) oraz szybkie retransmisje zostaną opóźnione o
1/4 czasu RTT. Ma to na celu ograniczenie liczby połączeń, które fałszywie odzyskały sprawność w
sieci o niewielkim stopniu zmiany kolejności pakietów (mniej niż 3). Istnieje także możliwość
ustawienia <code>3</code> , gdzie zostanie włączona wczesna retransmisja oraz protokół TLP. Jeśli zaś ustawimy
<code>4</code> , to zostanie aktywowany jedynie protokół TLP.</p>
<h2 id="selektywna-retransmisja">Selektywna retransmisja</h2>
<p>W przypadku komunikacji, gdzie nadawca i odbiorca są w stanie obsłużyć selektywne potwierdzenia
protokołu TCP, istnieje możliwość zaistnienia retransmisji selektywnej (Selective Retransmission lub
Selective Repeat), czyli takiej, której celem jest zretransmitowanie jedynie tych segmentów, które
nie dotarły jeszcze do odbiorcy. By zrozumieć w pełni ten rodzaj retransmisji, trzeba się zaznajomić
z tym jak działają selektywne potwierdzenia (SACK).</p>
<h2 id="retransmisja-pakietów-syn">Retransmisja pakietów SYN</h2>
<p>Pakiety <code>SYN</code> rozpoczynają nowe połączenia i mogą z tego względu być traktowane ulgowo, tj. możemy
im przypisać więcej prób niż ma to miejsce w przypadku retransmisji zwykłych pakietów zawierających
jakieś dane. Ustawiony zatem limit będzie tym samym ograniczał czas, przez który kernel będzie
próbował ustanowić nowe połączenie. By zmienić ilość retransmisji pakietu <code>SYN</code> , edytujemy plik
<code>/etc/sysctl.conf</code> i dodajemy poniższą linijkę:</p>
<pre><code>net.ipv4.tcp_syn_retries = 4
</code></pre>
<p>Wartość 4 oznacza zatem, że kernel, po nieudanej próbie nawiązania połączenia, spróbuje
zretransmitować pakiet <code>SYN</code> 4 razy i jeśli żadna z tych prób się nie powiedzie, po czasie 15 sekund
kernel odpuści. Popatrzmy zatem jak takie zachowanie wygląda w
praktyce:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2015/07/1.retransmisja-syn-wireshark.png" alt=""    class="huge"></p>
<h3 id="retransmisja-pakietów-syn-ack">Retransmisja pakietów SYN-ACK</h3>
<p>Gdy serwer otrzymuje zapytanie <code>SYN</code>, natychmiast wysyła odpowiedź w postaci pakietu z ustawionymi
flagami <code>SYN</code> i <code>ACK</code> umieszczając jednocześnie to połączenie w kolejce (backlog queue) do chwili aż
nadejdzie od klienta pakiet z ustawioną flagą <code>ACK</code> . Gdy taki pakiet nie nadchodzi, serwer
retransmituje swój pakiet <code>SYN-ACK</code> kilka razy, dając tym samym szansę klientowi by spróbował
odesłać pakiet <code>ACK</code> jeszcze raz.</p>
<p>Połączenia w <a href="https://morfikov.github.io/post/flagi-tcp-i-przelaczanie-stanow-polaczen/">stanie SYN RCVD</a>
zajmują cenne zasoby i by odciążyć trochę maszynę można przyśpieszyć proces zamykania tego typu
połączeń przez zmianę ilości retransmisji pakietów <code>SYN-ACK</code> . Dopisujemy zatem do pliku
<code>/etc/sysctl.conf</code> poniższy parametr:</p>
<pre><code>net.ipv4.tcp_synack_retries = 2
</code></pre>
<p>Trzeba jednak pamiętać, że obniżenie wartości tego parametru w przypadku słabych łącz może powodować
problemy. Poniżej fotka z próbą retransmisji dwóch pakietów <code>SYN-ACK</code> :</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2015/07/2.retransmisja-syn-ack-wireshark.png" alt=""    class="huge"></p>
<h2 id="zbędna-retransmisja-spurious-retransmission">Zbędna retransmisja (Spurious retransmission)</h2>
<p>Warto też wiedzieć, że istnieją także przypadki gdzie protokół TCP może zainicjować retransmisję
segmentu, który nie został utracony. Oczywistym jest, że tego typu sytuacja nie powinna mieć miejsca
ale zdarza się, np. za sprawą przedwczesnych timeout'ów (Spurious timeouts), które wystąpiły
wcześniej niż oczekiwano, tj. w momencie gdy opóźnienie przy przesyłaniu pakietu momentalnie
wzrasta dość gwałtownie i przekracza RTO, np. w sieciach bezprzewodowych.</p>
<p>Zbędne retransmisje mogą także wystąpić w innych sytuacjach. Jedną z nich jest zmiana kolejności
pakietów, które docierają do odbiorcy. Zwykle taka sytuacja ma miejsce gdy pakiety podróżują po
internecie różnymi trasami, z których jedna jest krótsza i mniej zatłoczona od pozostałych, co
przekłada się na szybkość z jaką docierają pakiety na drugi koniec połączenia. Zamiana pakietów
może mieć miejsce przy ich transferze w obu kierunkach, tj. pakiety wysłane przez nadawcę do
odbiorcy mogą u tego drugiego dotrzeć w innej kolejności niż zostały wysłane, oraz pakiety <code>ACK</code>
wracające do nadawcy mogą także dotrzeć w nie tej kolejności co potrzeba. Jeśli chodzi o zamianę
kolejności pakietów u odbiorcy, to taka sytuacja może zostać mylnie zinterpretowana jako utrata
pakietów. Jako, że utrata pakietów i docieranie ich w nieodpowiedniej kolejności powodują duplikaty
potwierdzeń <code>ACK</code> , to jeśli ilość takich pakietów przekroczy 3 (domyślne ustawienia linux'a), to
pakiet zostanie zretransmitowany ponownie. W przypadku gdy ilość pakietów zamienionych miejscami
będzie mniejsza, to protokół TCP bez problemu sobie z taką sytuacją poradzi bez jakiejkolwiek
retransmisji. Jeśli chodzi zaś o docieranie pakietów <code>ACK</code> w złej kolejności, to może to prowadzić
do impulsowości (burstiness), czyli do chwilowego szybkiego zwiększenia prędkości transmisji, co
może przełożyć się na problemy z wykorzystaniem dostępnej przepustowości łącza.</p>
<p>Innym przypadkiem, gdzie mogą nastąpić zbędne retransmisje, jest powielanie pakietów. Jest to bardzo
rzadkie zjawisko, w którym protokół IP dostarcza dany pakiet więcej niż jeden raz. Ta sytuacja może
zostać zaobserwowana gdy protokół warstwy sieciowej (model TCP/IP) nadawcy wykonuje retransmisje i
powiela dany pakiet kilka razy. To z kolei może zmylić samego nadawcę, który otrzyma kilka
duplikatów pakietów <code>ACK</code> i dokona szybkiej retransmisji segmentu, który dotarł do odbiorcy. W
przypadku wykorzystywania mechanizmu SACK (z opcją DSACK), takie duplikaty pakietów <code>ACK</code> mogą
zostać wyłapane przez protokół TCP z powodzeniem, bo zawierają informację, że dany segment został
już odebrany przez odbiorcę i szybka retransmisja w takim przypadku często nie będzie mieć miejsca.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/tcp/">tcp</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/sysctl/">sysctl</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/sie%C4%87/">sieć</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f&amp;text=Retransmisja%20i%20duplikaty%20pakiet%c3%b3w%20w%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f&amp;title=Retransmisja%20i%20duplikaty%20pakiet%c3%b3w%20w%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f&amp;title=Retransmisja%20i%20duplikaty%20pakiet%c3%b3w%20w%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f&title=Retransmisja%20i%20duplikaty%20pakiet%c3%b3w%20w%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f&amp;title=Retransmisja%20i%20duplikaty%20pakiet%c3%b3w%20w%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fretransmisja-i-duplikaty-pakietow-w-tcp%2f&description=Retransmisja%20i%20duplikaty%20pakiet%c3%b3w%20w%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/wolny-start-polaczen-w-protokole-tcp/">Wolny start połączeń w protokole TCP</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/bufor-polaczen-w-protokole-tcp/">Bufor połączeń w protokole TCP</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/sack-czyli-selektywne-potwierdzenia-pakietow/">SACK, czyli selektywne potwierdzenia pakietów</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/fragmentacja-pakietu-i-zmiana-wartosci-mtu/">Fragmentacja pakietu i zmiana wartości MTU</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/numery-sekwencyjne-w-strumieniu-tcp/">Numery sekwencyjne w strumieniu TCP</a></li>
		
	</ul>
</div>

	

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2021 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
		<img alt="Licencja Creative Commons" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/80x15.png" />
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
</body>
</html>
