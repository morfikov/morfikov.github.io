<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb" />
<meta property="og:description" content="Debian posiada bardzo rozbudowany system robienia pakietów. Generalnie rzecz biorąc, to wszystkie z
nich musiały przejść przez ten proces zanim trafiły do głównego repozytorium dystrybucji. Dzięki
takiemu stanu rzeczy, nie musimy ręcznie powielać pracy szeregu innych osób i odpada nam
własnoręczna kompilacja pakietów, a wszyscy wiemy, że zajmuje ona cenny czas i zasoby. Paczki
.deb są tworzone ze źródeł i instalowane przy pomocy menadżera pakietów aptitude/apt/dpkg .
Nic jednak nie stoi na przeszkodzie by daną aplikację skompilować sobie ręcznie i zainstalować ją
przy pomocy make install . Problem w tym, że w taki sposób robi się śmietnik w naszym systemie i
śledzenie wszystkich zainstalowanych w ten sposób pakietów w pewnym momencie stanie się wręcz
niemożliwe. Dlatego też przydałby nam się mechanizm, który ułatwiłby nam nieco to zadanie. Debian
udostępnia szereg narzędzi, które są w stanie w pełni zautomatyzować cały ten proces budowy
pakietów. Ten poradnik zaś ma na celu zebranie wszystkich istotniejszych informacji związanych z
obsługą narzędzi takich jak dh_make , dpkg-buildpackage , pbuilder , quilt czy lintian ,
tak by tworzyć pakiety w prosty sposób i przy tym równając do najwyższych standardów debiana." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/poradnik-maintainera-czyli-jak-zrobic-pakiet-deb/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2015-12-07T20:26:45+00:00" />
<meta property="article:modified_time" content="2015-12-07T20:26:45+00:00" />


		<meta itemprop="name" content="Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb">
<meta itemprop="description" content="Debian posiada bardzo rozbudowany system robienia pakietów. Generalnie rzecz biorąc, to wszystkie z
nich musiały przejść przez ten proces zanim trafiły do głównego repozytorium dystrybucji. Dzięki
takiemu stanu rzeczy, nie musimy ręcznie powielać pracy szeregu innych osób i odpada nam
własnoręczna kompilacja pakietów, a wszyscy wiemy, że zajmuje ona cenny czas i zasoby. Paczki
.deb są tworzone ze źródeł i instalowane przy pomocy menadżera pakietów aptitude/apt/dpkg .
Nic jednak nie stoi na przeszkodzie by daną aplikację skompilować sobie ręcznie i zainstalować ją
przy pomocy make install . Problem w tym, że w taki sposób robi się śmietnik w naszym systemie i
śledzenie wszystkich zainstalowanych w ten sposób pakietów w pewnym momencie stanie się wręcz
niemożliwe. Dlatego też przydałby nam się mechanizm, który ułatwiłby nam nieco to zadanie. Debian
udostępnia szereg narzędzi, które są w stanie w pełni zautomatyzować cały ten proces budowy
pakietów. Ten poradnik zaś ma na celu zebranie wszystkich istotniejszych informacji związanych z
obsługą narzędzi takich jak dh_make , dpkg-buildpackage , pbuilder , quilt czy lintian ,
tak by tworzyć pakiety w prosty sposób i przy tym równając do najwyższych standardów debiana."><meta itemprop="datePublished" content="2015-12-07T20:26:45+00:00" />
<meta itemprop="dateModified" content="2015-12-07T20:26:45+00:00" />
<meta itemprop="wordCount" content="15524">
<meta itemprop="keywords" content="debian," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb"/>
<meta name="twitter:description" content="Debian posiada bardzo rozbudowany system robienia pakietów. Generalnie rzecz biorąc, to wszystkie z
nich musiały przejść przez ten proces zanim trafiły do głównego repozytorium dystrybucji. Dzięki
takiemu stanu rzeczy, nie musimy ręcznie powielać pracy szeregu innych osób i odpada nam
własnoręczna kompilacja pakietów, a wszyscy wiemy, że zajmuje ona cenny czas i zasoby. Paczki
.deb są tworzone ze źródeł i instalowane przy pomocy menadżera pakietów aptitude/apt/dpkg .
Nic jednak nie stoi na przeszkodzie by daną aplikację skompilować sobie ręcznie i zainstalować ją
przy pomocy make install . Problem w tym, że w taki sposób robi się śmietnik w naszym systemie i
śledzenie wszystkich zainstalowanych w ten sposób pakietów w pewnym momencie stanie się wręcz
niemożliwe. Dlatego też przydałby nam się mechanizm, który ułatwiłby nam nieco to zadanie. Debian
udostępnia szereg narzędzi, które są w stanie w pełni zautomatyzować cały ten proces budowy
pakietów. Ten poradnik zaś ma na celu zebranie wszystkich istotniejszych informacji związanych z
obsługą narzędzi takich jak dh_make , dpkg-buildpackage , pbuilder , quilt czy lintian ,
tak by tworzyć pakiety w prosty sposób i przy tym równając do najwyższych standardów debiana."/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2015-12-07T20:26:45Z">Opublikowano: 07/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Poradnik maintainer&#39;a, czyli jak zrobić pakiet deb</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#potrzebne-pakiety">Potrzebne pakiety</a></li>
    <li><a href="#konfiguracja-narzędzi">Konfiguracja narzędzi</a>
      <ol>
        <li><a href="#dh-make">dh-make</a></li>
        <li><a href="#gnupg">gnupg</a></li>
        <li><a href="#devscripts">devscripts</a></li>
        <li><a href="#lintian">lintian</a></li>
        <li><a href="#apt-file">apt-file</a></li>
        <li><a href="#pbuilder">pbuilder</a></li>
        <li><a href="#ccache">ccache</a></li>
        <li><a href="#sudo">sudo</a></li>
      </ol>
    </li>
    <li><a href="#przygotowanie-środowiska-chroot">Przygotowanie środowiska chroot</a></li>
    <li><a href="#źródła-i-informacje-o-nich">Źródła i informacje o nich</a></li>
    <li><a href="#katalog-debian">Katalog debian/</a>
      <ol>
        <li><a href="#tworzenie-szkieletu">Tworzenie szkieletu</a></li>
        <li><a href="#debiancontrol">debian/control</a></li>
        <li><a href="#debianrules">debian/rules</a></li>
        <li><a href="#debianchangelog-i-debianupstreamchangelog">debian/changelog i debian/upstream.changelog</a>
          <ol>
            <li><a href="#debiannews">debian/NEWS</a></li>
          </ol>
        </li>
        <li><a href="#debiancopyright">debian/copyright</a></li>
        <li><a href="#debianwatch-i-debianupstreamsigning-keyasc">debian/watch i debian/upstream/signing-key.asc</a>
          <ol>
            <li><a href="#podpisy-cyfrowe-źródeł">Podpisy cyfrowe źródeł</a></li>
          </ol>
        </li>
        <li><a href="#debianmanpage-i-debianmanpages-dh_installman">debian/manpage.* i debian/*.manpages (dh_installman)</a>
          <ol>
            <li><a href="#automatyczne-generowanie-manuali">Automatyczne generowanie manuali</a></li>
          </ol>
        </li>
        <li><a href="#debiandocs-dh_installdocs">debian/*.docs (dh_installdocs)</a></li>
        <li><a href="#pliki-demonów-dh_installinit">Pliki demonów (dh_installinit)</a>
          <ol>
            <li><a href="#debianinit">debian/*.init</a></li>
            <li><a href="#debiandefault">debian/*default</a></li>
            <li><a href="#debianservice-dh_systemd_enable-dh_systemd_start">debian/*service (dh_systemd_enable, dh_systemd_start)</a></li>
            <li><a href="#debiantmpfile">debian/*tmpfile</a></li>
          </ol>
        </li>
        <li><a href="#debiansymbols">debian/*.symbols</a></li>
        <li><a href="#debiandirs-dh_installdirs">debian/*.dirs (dh_installdirs)</a></li>
        <li><a href="#debianinstall-dh_install">debian/*.install (dh_install)</a></li>
        <li><a href="#debiancompat">debian/compat</a></li>
        <li><a href="#debianlinks-dh_link">debian/*.links (dh_link)</a></li>
        <li><a href="#debianlintian-overrides-i-debiansourcelintian-overrides">debian/*.lintian-overrides i debian/source/lintian-overrides</a></li>
        <li><a href="#sourceformat">source/format</a></li>
        <li><a href="#sourcelocal-options-i-sourceoptions">source/local-options i source/options</a></li>
        <li><a href="#debianpatches-i-debianpatchesseries">debian/patches/ i debian/patches/series</a>
          <ol>
            <li><a href="#nagłówek-łaty">Nagłówek łaty</a></li>
          </ol>
        </li>
        <li><a href="#debianexamples-dh_installexamples">debian/*.examples (dh_installexamples)</a></li>
        <li><a href="#debiantemplates">debian/*.templates</a></li>
        <li><a href="#debianconffiles-dh_installdeb">debian/conffiles (dh_installdeb)</a></li>
        <li><a href="#debiancron-dh_installcron">debian/<em>.cron.</em> (dh_installcron)</a></li>
        <li><a href="#debianlogrotate-dh_installlogrotate">debian/*.logrotate (dh_installlogrotate)</a></li>
        <li><a href="#debianpostinst-debianpostrm-debianpreinst-debianprerm">debian/<em>.postinst, debian/</em>.postrm, debian/<em>.preinst, debian/</em>.prerm</a></li>
        <li><a href="#desktop">*.desktop</a></li>
      </ol>
    </li>
    <li><a href="#hardening-pakietów">Hardening pakietów</a></li>
    <li><a href="#budowanie-źródeł">Budowanie źródeł</a></li>
    <li><a href="#budowanie-pakietu">Budowanie pakietu</a>
      <ol>
        <li><a href="#manualne-budowanie-pakietów">Manualne budowanie pakietów</a></li>
        <li><a href="#zgubione-pliki-dh_missing">Zgubione pliki (dh_missing)</a></li>
        <li><a href="#instalowanie-zbudowanego-pakietu">Instalowanie zbudowanego pakietu</a></li>
      </ol>
    </li>
    <li><a href="#aktualizowanie-pakietu">Aktualizowanie pakietu</a>
      <ol>
        <li><a href="#aktualizacja-długo-nieaktualizowanego-pakietu">Aktualizacja długo nieaktualizowanego pakietu</a></li>
        <li><a href="#aktualizacja-pakietu-z-repozytorium-git">Aktualizacja pakietu z repozytorium git</a></li>
      </ol>
    </li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Debian posiada bardzo rozbudowany system robienia pakietów. Generalnie rzecz biorąc, to wszystkie z
nich musiały przejść przez ten proces zanim trafiły do głównego repozytorium dystrybucji. Dzięki
takiemu stanu rzeczy, nie musimy ręcznie powielać pracy szeregu innych osób i odpada nam
własnoręczna kompilacja pakietów, a wszyscy wiemy, że zajmuje ona cenny czas i zasoby. Paczki
<code>.deb</code> są tworzone ze źródeł i instalowane przy pomocy menadżera pakietów <code>aptitude</code>/<code>apt</code>/<code>dpkg</code> .
Nic jednak nie stoi na przeszkodzie by daną aplikację skompilować sobie ręcznie i zainstalować ją
przy pomocy <code>make install</code> . Problem w tym, że w taki sposób robi się śmietnik w naszym systemie i
śledzenie wszystkich zainstalowanych w ten sposób pakietów w pewnym momencie stanie się wręcz
niemożliwe. Dlatego też przydałby nam się mechanizm, który ułatwiłby nam nieco to zadanie. Debian
udostępnia szereg narzędzi, które są w stanie w pełni zautomatyzować cały ten proces budowy
pakietów. Ten poradnik zaś ma na celu zebranie wszystkich istotniejszych informacji związanych z
obsługą narzędzi takich jak <code>dh_make</code> , <code>dpkg-buildpackage</code> , <code>pbuilder</code> , <code>quilt</code> czy <code>lintian</code> ,
tak by tworzyć pakiety w prosty sposób i przy tym równając do najwyższych standardów debiana.</p>
<h2 id="potrzebne-pakiety">Potrzebne pakiety</h2>
<p>Przeciętny użytkownik debiana raczej nie będzie w stanie zbudować własnej paczki <code>.deb</code> ,
przynajmniej nie od razu. Nie musimy też rzucać się na głęboką wodę i możemy zwyczajnie zacząć od
prostszej czynności jaką jest aktualizacja konkretnego pakietu, który już jest dostępny w
repozytorium debiana (zobacz rozdział 9). Wszystkie paczki <code>.deb</code> wymagają tego by nimi się
opiekować, np. dostosowywać zależności, zgłaszać błędy upstream'owi i tego typu rzeczy. Nie jest to
specjalnie trudne ale największym wyzwaniem jest &quot;debianizacja źródeł&quot;. Ten proces polega na
odpowiednim dostosowaniu katalogu <code>debian/</code> , który zostanie utworzony w głównym folderze ze
źródłami aplikacji i nasze zadanie sprowadzać się będzie do odpowiedniego uzupełniania
określonych plików w tym katalogu. W przypadku pakietów już dostępnych w dystrybucji, debianizacja
źródeł już się odbywała i przeprowadził ją za nas ktoś inny. Dlatego aktualizacja tych pakietów
zwykle nie powinna stwarzać problemów, a nawet jeśli już, to jest ich sporo mniej niż w przypadku,
gdy byśmy budowali tę paczkę od podstaw.</p>
<p>Poniżej znajduje się lista narzędzi wraz z ich krótkim opisem. To przy ich pomocy będziemy
odpowiednio <a href="https://www.debian.org/doc/manuals/maint-guide/">dostosowywać katalog debian/</a>. Spora część z nich jest w pełni zautomatyzowana i od
nas wymagać będzie się jedynie ustawienia określonych przełączników przy wydawaniu konkretnych poleceń.</p>
<ul>
<li><code>packaging-dev</code> -- meta pakiet, który zainstaluje min:
<ul>
<li><code>build-essential</code> -- bez tego nie ma nawet co podchodzić do budowania pakietów.</li>
<li><code>debhelper</code> -- szereg programów zajmujących się obrabianiem pliku <code>debian/rules</code> .</li>
<li><code>dh-make</code> -- debianizuje źródła (tworzy katalog <code>debian/</code>).</li>
<li><code>devscripts</code> -- ten pakiet zawiera szereg skryptów ułatwiających zarządzanie plikami w
katalogu <code>debian/</code> , więcej info o tym jakie skrypty ten pakiet zawiera (oraz ich
zależności) można odczytać z opisu samego pakietu, np. w <code>aptitude</code> .</li>
<li><code>lintian</code> -- weryfikuje poprawność zbudowanych pakietów.</li>
<li><code>pbuilder</code> -- buduje paczki <code>.deb</code> .</li>
<li><code>quilt</code> -- tworzy łaty (i zarządza nimi) w oparciu o zmiany dokonywane na źródłach.</li>
</ul>
</li>
<li><code>gnupg</code> -- obsługa kluczy GPG, wymagane do podpisywania plików <code>.dsc</code> i <code>.changes</code> .</li>
<li><code>desktop-file-utils</code> -- weryfikuje składnię plików <code>.desktop</code> .</li>
<li><code>ccache</code> -- przyśpiesza znacznie rekompilację pakietów.</li>
<li><code>dh-*</code> -- różne moduły dla debhelper'a, potrzebne podczas budowania pewnych pakietów, np. te
posiadające pliki <code>.service</code> dla systemd wymagać będą <code>dh-systemd</code> , etc.</li>
<li><code>gmanedit</code> -- ułatwia tworzenie manuali.</li>
<li><code>help2man</code> -- generuje manualne dla plików wykonywalnych w oparciu o parametr <code>--help</code> .</li>
<li><code>piuparts</code> -- testuje instalację, usuwanie i aktualizację zbudowanych pakietów.</li>
<li><code>apt-file</code> -- przeszukuje pakiety w oparciu o wzorzec nazwy pliku.</li>
<li><code>patchutils</code>, <code>wdiff</code> -- dodatkowe narzędzia do pracy z łatami.</li>
<li><code>blhc</code> -- testuje log z budowania pakietu pod kątem braku określonych flag.</li>
<li><code>hardening-includes</code> -- zawiera narzędzie <code>hardening-check</code> pomagające ustalić poziom
bezpieczeństwa plików wykonywalnych.</li>
<li><code>python-minimal</code> -- zawiera narzędzie <code>pyversions</code> pomagające ustalić wersję python'a.</li>
<li><code>binutils</code>, <code>strace</code> -- <code>binutils</code> zawiera narzędzie <code>dpkg-depcheck</code> , które przy pomocy
<code>strace</code> może pomóc w ustalaniu zależności.</li>
<li><code>fakeroot</code> -- symuluje uprawnienia super użytkownika.</li>
<li><code>sudo</code> -- przekazuje część uprawnień administratora root zwykłemu użytkownikowi.</li>
</ul>
<p>Wato też nadmienić, że skoro mamy do czynienia z budową pakietów, to przydałby się gdzieś te pakiety
umieszczać. Jest raczej mało prawdopodobne, że dostaną się do głównego repozytorium debiana, dlatego
też dobrze jest się pierw pokusić o <a href="https://morfikov.github.io/post/tworzenie-repozytorium-przy-pomocy-reprepro/">stworzenie własnego repozytorium przy pomocy reprepro</a> i to
w nim umieszczać pakiety, które będziemy instalować przy pomocy <code>aptitude</code> czy też <code>apt</code> .</p>
<p>Jak widać jest tego dość sporo, no i oczywiście będzie tego więcej, gdy każdy z powyższych pakietów
dociągnie swoje zależności. Poza tymi powyższymi, dojdą nam jeszcze pewnie inne pakiety, w
zależności od tego co tak naprawdę będziemy budować.</p>
<p>Dla ułatwienia, poniżej jest linijka instalująca wszystkie powyższe narzędzia:</p>
<pre><code># aptitude install packaging-dev gnupg desktop-file-utils ccache \
gmanedit help2man piuparts apt-file patchutils wdiff blhc hardening-includes \
python-minimal binutils strace fakeroot
</code></pre>
<p>Powyższe pakiety (za wyjątkiem pewnych dodatków) są jedynymi pakietami, które będziemy instalować w
swoim głównym systemie. Wszelkie zależności budowanych pakietów będą już pakowane do <a href="https://morfikov.github.io/post/przygotowanie-srodowiska-chroot-do-pracy/">środowiska
chroot</a>, które zostanie utworzone automatycznie przez <code>pbuilder</code> . Takie rozwiązanie pomoże nam
utrzymać porządek w systemie.</p>
<p>Upychanie plików w paczkach ma na celu jedynie ich organizację i niczym zbytnio nie różni się od
zwykłego przekopiowania ich do odpowiednich katalogów (czy zainstalowania via <code>make install</code> ), no
może poza faktem, że w przypadku paczki, wszystkie pliki są śledzone przez menadżer pakietów. Chodzi
generalnie o to, że w przypadku, gdyby się pojawiła nowsza wersja jakiegoś programu, lub zwyczajnie
chcielibyśmy się pozbyć go z systemu, to może być to dość problematyczne. W przypadku jednego czy
dwóch programów, które nie mają za wiele plików, usunięcie ich raczej nie powinno sprawić problemu,
a co w przypadku bardziej rozbudowanych projektów? Część z nich potrafi się pomyślnie odinstalować
sama jeśli skrypt <code>makefile</code> obsługuje taki ficzer ale nawet w takim przypadku trzeba, po pierwsze,
trzymać źródła, a po drugie, musimy zainstalować wszystkie zależności potrzebne do zbudowania
takiego pakietu w swoim systemie. Natomiast w przypadku budowania paczek, te problemy nas nie
dotyczą.</p>
<h2 id="konfiguracja-narzędzi">Konfiguracja narzędzi</h2>
<p>Zanim jednak przejdziemy do omawiania poszczególnych plików, które mogą (ale nie muszą) znajdować
się w katalogu <code>debian/</code> , musimy poświęcić chwilę czasu na dostosowanie konfiguracji tych
wszystkich powyższych narzędzi.</p>
<h3 id="dh-make">dh-make</h3>
<p>Standardowo przy wywoływaniu polecenia <code>dh_make</code> podczas debianizowania źródeł, musimy podawać kilka
dodatkowych parametrów, tak by określić kto buduje paczkę. Zamiast tego, możemy wyeksportować
odpowiednie zmienne i uprościć nieco cały ten proces. W tym celu dodajemy poniższe linijki do <a href="https://morfikov.github.io/post/plik-bashrc-czyli-konfiguracja-basha/">pliku
konfiguracyjnego shella, .bashrc</a>:</p>
<pre><code>DEBEMAIL=&quot;morfik@nsa.com&quot;
DEBFULLNAME=&quot;Mikhail Morfikov&quot;
export DEBEMAIL DEBFULLNAME
</code></pre>
<p>W oparciu o te zmienne, szereg narzędzi będzie uzupełniać odpowiednie pola, przykładowo plik
<code>changelog</code> .</p>
<h3 id="gnupg">gnupg</h3>
<p>Jeśli planujemy robić z paczkami coś większego, np. przesyłać je do repozytorium debiana, to
będziemy potrzebować kluczy GPG, by taką paczkę podpisać. Nie będę tutaj opisywał całego procesu
generowania i konfigurowania kluczy GPG, bo zostało to już zrobione w odpowiednich wpisach na tym
blogu. Zachęcam zatem do zapoznania się z tymi artykułami: <a href="https://morfikov.github.io/post/bezpieczny-klucz-gpg/">Bezpieczny klucz GPG</a>, <a href="https://morfikov.github.io/post/konfiguracja-gpg-w-pliku-gpg-conf/">Konfiguracja
GPG w pliku gpg.conf</a> oraz <a href="https://morfikov.github.io/post/serwer-kluczy-gpg-i-kwestia-prywatnosci/">Serwer kluczy GPG i kwestia prywatności</a>.</p>
<h3 id="devscripts">devscripts</h3>
<p>Jak wspomniałem na początku, w tym pakiecie znajduje się szereg użytecznych skryptów, które będziemy
wykorzystywać w swojej pracy. Jednym z częściej używanych narzędzi będzie <code>debsign</code> , które to
będzie nam podpisywało pliki <code>.changes</code> i <code>.dsc</code> zawierające między innymi sumy kontrolne. I tu,
podobnie jak w przypadku narzędzia <code>dh-make</code> , możemy określić kila parametrów, tak by nie musieć
ich wpisywać za każdym razem, gdy chcemy podpisać jakąś paczkę.</p>
<p>Konfiguracja pakietu <code>devscripts</code> jest trzymana w pliku <code>/etc/devscripts.conf</code> . Dobrze jest
przejrzeć ten plik, choć objętościowo może nieco przytłoczyć. W każdym razie interesujące nas opcje
to:</p>
<pre><code>..
DEBSIGN_PROGRAM=gpg
...
DEBSIGN_SIGNLIKE=gpg
...
DEBSIGN_KEYID=B820057A
...
</code></pre>
<p>Możemy także zweryfikować wprowadzone dane wydając poniższe polecenie:</p>
<pre><code>$ debsign --help
...
Default settings modified by devscripts configuration files:
  DEBSIGN_PROGRAM=gpg
  DEBSIGN_KEYID=B820057A
</code></pre>
<h3 id="lintian">lintian</h3>
<p>Konfiguracja <a href="https://lintian.debian.org/manual/index.html">lintian'a</a> trzymana jest w pliku <code>/etc/lintianrc</code> i w dużej mierze odpowiada za to
jaki rodzaj błędów będzie nam pokazywany. Poniżej mój plik:</p>
<pre><code># /etc/lintianrc -- Lintian configuration file
#
# Note, that Lintian has reasonable default values for all variables
# specified below. Thus, you don't have to change this file unless you
# want something special.
#
# Also note, that this file uses a special syntax:
# Empty lines are allowed, comments are introduced by a hash sign (#).
# All other lines must have the format
#    VAR=text
# or
#    VAR=&quot;text&quot;
# It is allowed to use '~' and '$HOME' in the variables, but not other
# shell/environment variables.

# Enable info tags by default (--display info)
display-info = yes

# Enable pedantic tags by default (--pedantic)
pedantic = yes

# Enable experimental tags by default (--display-experimental)
display-experimental = no

# Enable colored output for terminal output (--color)
color = always

# Show overridden tags (--show-overrides)
#show-overrides = yes

# Ignore all overrides (--no-override)
#override = no

# Verbose output by default (--verbose)
verbose = no

info = no

# Quiet by default (--quiet)
#quiet = yes

# Specify a laboratory--a directory where Lintian should store some info
# about packages being checked.
LINTIAN_LAB=&quot;/media/Kabi/pbuilder/lintian&quot;

# Use a different directory for temporary files - useful if /tmp is a
# tmpfs with &quot;limited&quot; capacity.
#TMPDIR=&quot;/var/tmp&quot;
</code></pre>
<p>Jeśli jesteśmy początkującymi amatorami, możemy się nieco pogubić w tym co będzie próbował nam
powiedzieć <code>lintian</code> . Dobrze jest przestawić z początku opcję <code>verbose</code> oraz <code>info</code> na <code>yes</code> .
Spowoduje to wyświetlenie dość obszernej informacji na temat każdego z błędu. Zawsze można wpisać
kod błędu w google i pierwszy wynik odeśle nas na stronę lintian'a i tam na pewno znajdziemy
wyjaśnienie.</p>
<h3 id="apt-file">apt-file</h3>
<p>To narzędzie nie jest bezpośrednio powiązane z budowaniem paczek, niemniej jednak bardzo się
przydaje, a to z tego względu, że często będziemy postawieni w sytuacji, gdzie pakiet nie będzie
mógł się poprawnie zbudować i to przez brak jakiegoś pliku. Przy pomocy <code>apt-file</code> będziemy w
stanie ten plik namierzyć. Nie będę tutaj opisywał tego jak korzystać z tego narzędzia, bo to
zostało dokładnie wyjaśnione we wpisie dotyczącym <a href="https://morfikov.github.io/post/przeszukiwanie-zawartosci-pakietow-apt-file/">apt-file</a>. Zachęcam zatem do zapoznania się
również i z tym tekstem.</p>
<h3 id="pbuilder">pbuilder</h3>
<p><a href="http://pbuilder.alioth.debian.org/">Pbuilder</a> to narzędzie, które zrobi praktycznie cała robotę za nas, przynajmniej jeśli chodzi
o zbudowanie pakietu <code>.deb</code> . Trzeba mu tylko skonfigurować szereg parametrów. Przykładowy plik
konfiguracyjny dla pbuilder'a znajduje się w <code>/usr/share/doc/pbuilder/examples/pbuilderrc</code> . Trzeba
go skopiować do katalogu <code>/etc/</code> i odpowiednio przerobić. Można także zrobić sobie lokalną wersję
tego pliku i umieścić go w katalogu domowym pod nazwą <code>.pbuilderrc</code> . Poniżej zaś znajduje się mój
aktualny plik konfiguracyjny:</p>
<pre><code># pbuilder defaults; edit /etc/pbuilderrc to override these and see
# pbuilderrc.5 for documentation

BASETGZ=/media/Kabi/pbuilder/base.tgz
EXTRAPACKAGES=&quot;apt-utils debconf-utils ccache eatmydata libfile-fcntllock-perl&quot;
#export DEBIAN_BUILDARCH=athlon
BUILDPLACE=/media/Kabi/pbuilder/build/
MIRRORSITE=http://ftp.de.debian.org/debian/
#OTHERMIRROR=&quot;deb http://www.home.com/updates/ ./&quot;
#export http_proxy=http://your-proxy:8080/
USEPROC=yes
USEDEVPTS=yes
USENETWORK=no
USERUNSHM=yes
USEDEVFS=no
BUILDRESULT=/media/Kabi/pbuilder/result/

# specifying the distribution forces the distribution on &quot;pbuilder update&quot;
DISTRIBUTION=sid
# specifying the architecture passes --arch= to debootstrap; the default is
# to use the architecture of the host
ARCHITECTURE='dpkg --print-architecture'
# specifying the components of the distribution, for instance to enable all
# components on Debian use &quot;main contrib non-free&quot; and on Ubuntu &quot;main
# restricted universe multiverse&quot;
COMPONENTS=&quot;main&quot;
#specify the cache for APT
APTCACHE=&quot;/media/Kabi/pbuilder/pbuilder_apt_cache/&quot;
APTCACHEHARDLINK=&quot;no&quot;
REMOVEPACKAGES=&quot;no&quot;
#HOOKDIR=&quot;/usr/lib/pbuilder/hooks&quot;
HOOKDIR=&quot;/media/Kabi/pbuilder/hooks&quot;
# NB: this var is private to pbuilder; ccache uses &quot;CCACHE_DIR&quot; instead
# CCACHEDIR=&quot;/var/cache/pbuilder/ccache&quot; ccache -M 20G
CCACHEDIR=&quot;/media/Kabi/pbuilder/ccache&quot;
export CCACHE_DIR=&quot;/media/Kabi/pbuilder/ccache&quot;

# make debconf not interact with user
export DEBIAN_FRONTEND=&quot;noninteractive&quot;

#for pbuilder debuild
BUILDSOURCEROOTCMD=&quot;fakeroot&quot;
PBUILDERROOTCMD=&quot;sudo -E&quot;
# use cowbuilder for pdebuild
#PDEBUILD_PBUILDER=&quot;cowbuilder&quot;

# additional build results to copy out of the package build area
#ADDITIONAL_BUILDRESULTS=(xunit.xml .coverage)

# command to satisfy build-dependencies; the default is an internal shell
# implementation which is relatively slow; there are two alternate
# implementations, the &quot;experimental&quot; implementation,
# &quot;pbuilder-satisfydepends-experimental&quot;, which might be useful to pull
# packages from experimental or from repositories with a low APT Pin Priority,
# and the &quot;aptitude&quot; implementation, which will resolve build-dependencies and
# build-conflicts with aptitude which helps dealing with complex cases but does
# not support unsigned APT repositories
#PBUILDERSATISFYDEPENDSCMD=&quot;/usr/lib/pbuilder/pbuilder-satisfydepends&quot;
PBUILDERSATISFYDEPENDSCMD=&quot;/usr/lib/pbuilder/pbuilder-satisfydepends-experimental&quot;

# Arguments for $PBUILDERSATISFYDEPENDSCMD.
# PBUILDERSATISFYDEPENDSOPT=()

# You can optionally make pbuilder accept untrusted repositories by setting
# this option to yes, but this may allow remote attackers to compromise the
# system. Better set a valid key for the signed (local) repository with
# $APTKEYRINGS (see below).
ALLOWUNTRUSTED=no

# Option to pass to apt-get always.
export APTGETOPT=()
# Option to pass to aptitude always.
export APTITUDEOPT=()

#Command-line option passed on to dpkg-buildpackage.
#DEBBUILDOPTS=&quot;-IXXX -iXXX&quot;
DEBBUILDOPTS=&quot;-j1 -pgpg -kB820057A -sa&quot;

#APT configuration files directory
APTCONFDIR=&quot;/media/Kabi/pbuilder/pbuilder_apt_conf/&quot;

# the username and ID used by pbuilder, inside chroot. Needs fakeroot, really
BUILDUSERID=1234
BUILDUSERNAME=morfik

# BINDMOUNTS is a space separated list of things to mount
# inside the chroot.
BINDMOUNTS=&quot;${CCACHE_DIR}&quot;

# Set the debootstrap variant to 'buildd' type.
DEBOOTSTRAPOPTS=(
    '--variant=buildd'
    '--keyring' '/usr/share/keyrings/debian-archive-keyring.gpg'
    )
# or unset it to make it not a buildd type.
# unset DEBOOTSTRAPOPTS

# Keyrings to use for package verification with apt, not used for debootstrap
# (use DEBOOTSTRAPOPTS). By default the debian-archive-keyring package inside
# the chroot is used.
APTKEYRINGS=()

# Set the PATH I am going to use inside pbuilder: default is &quot;/usr/sbin:/usr/bin:/sbin:/bin&quot;
#export PATH=&quot;/usr/sbin:/usr/bin:/sbin:/bin&quot;
export PATH=&quot;/usr/lib/ccache:${PATH}&quot;

# SHELL variable is used inside pbuilder by commands like 'su'; and they need sane values
export SHELL=/bin/bash

# The name of debootstrap command, you might want &quot;cdebootstrap&quot;.
DEBOOTSTRAP=&quot;debootstrap&quot;

# default file extension for pkgname-logfile
PKGNAME_LOGFILE_EXTENSION=&quot;_$(dpkg --print-architecture).build&quot;

# default PKGNAME_LOGFILE
PKGNAME_LOGFILE=&quot;&quot;

# default AUTOCLEANAPTCACHE
AUTOCLEANAPTCACHE=&quot;no&quot;

#default COMPRESSPROG
COMPRESSPROG=&quot;gzip&quot;
</code></pre>
<p>W <code>EXTRAPACKAGES</code> umieściłem kilka dodatkowych pakietów, które będą instalowane po wypakowaniu
środowiska chroot, a to ze względu na szereg ostrzeżeń jakie wyrzucał mi <code>pbuilder</code> przy budowaniu
pakietów. Te pozycje tutaj nie są obowiązkowe i raczej nic się paczkom nie stanie z powodu ich
braku. Jeśli ktoś nie rozumie konkretnych opcji, to odsyłam do <a href="http://manpages.ubuntu.com/manpages/wily/en/man5/pbuilderrc.5.html">manuala</a>, gdzie wszystkie z
nich są przystępnie opisane.</p>
<h3 id="ccache">ccache</h3>
<p>W przypadku <code>ccache</code> nie musimy zbytnio nic robić, bo wszystko zostało już określone w pliku
konfiguracyjnym pbuilder'a. Konkretnie chodzi o te wpisy:</p>
<pre><code>...
EXTRAPACKAGES=&quot;... ccache ...&quot;
...
CCACHEDIR=&quot;/media/Kabi/pbuilder/ccache&quot;
export CCACHE_DIR=&quot;/media/Kabi/pbuilder/ccache&quot;
...
</code></pre>
<p>Tylko jest jeden problem. Ten <code>ccache</code> zadziała jedynie przy wywoływaniu polecenia
<code>pbuilder --build</code> . W przypadku, gdy napotkamy błąd podczas budowy pakietu, to mamy opcję by
sprawdzić co się stało. Wtedy zostaniemy zalogowani wewnątrz środowiska chroot. Jeśli zmienimy
pliki konfiguracyjne, to wewnątrz tego chroot'a będziemy w stanie zbudować pakiet via
<code>dpkg-buildpackage</code> . Niemniej jednak, nie będziemy mieli dostępu do cache <code>ccache</code> i pakiet się
będzie budował tak jakbyśmy z niego w ogóle nie korzystali. Nie mam pojęcia czemu się tak dzieje,
być może to bug albo coś nie tak z powyższą konfiguracją, ewentualnie <code>pbuilder</code> tak po prostu już
ma.</p>
<h3 id="sudo">sudo</h3>
<p>Dostęp do narzędzia <code>pbuilder</code> jest standardowo zarezerwowany jedynie dla użytkownika root. Nie jest
to zbytnio wygodne i przydałoby się umożliwić korzystanie z niego zwykłemu użytkownikowi. W tym celu
edytujemy konfigurację <code>sudo</code> wpisując w terminalu <code>visudo</code> . Dopisujemy tam te poniższe linijki:</p>
<pre><code>Host_Alias HOSTY = localhost,morfikownia

morfik     HOSTY = (root) NOPASSWD: /usr/sbin/pbuilder
</code></pre>
<p>Więcej informacji na temat samego <code>sudo</code> jak i pliku konfiguracyjnego można znaleźć <a href="https://dug.net.pl/tekst/63/przewodnik_po_sudo/">tutaj</a>.</p>
<h2 id="przygotowanie-środowiska-chroot">Przygotowanie środowiska chroot</h2>
<p>Narzędzie <code>puilder</code> musi na czymś operować, inaczej odmówi współpracy. Musimy mu stworzyć podstawowe
środowisko pracy. Chodzi o zrobienia minimalnego i do tego spakowanego chroot'a, który będzie
używany w każdym procesie budowania pakietów. Takie minimalistyczne środowisko ma na celu
zapewnienie, że pakiet będzie się budował poprawnie (chodzi o zależności) na 99% maszyn, pod
warunkiem, że się zbuduje bez problemu w tym środowisku chroot. Musimy stworzyć także szereg
katalogów, do których ścieżki podaliśmy w pliku konfiguracyjnym pbuilder'a. Dodatkowo musimy także
dostosować konfigurację dla <code>apt</code> . Jeśli chodzi zaś o same repozytoria, to raczej poniżej sida nie
ma co schodzić. Jeśli jakichś pakietów nie ma w repo testowym czy stabilnym, to albo przez licencję,
albo przez niespełnione zależności, które zwykle muszą być w najnowszych wersjach, a te są z reguły
w sid i/lub experimental, bo powodują problemy. Tworzymy zatem potrzebne nam katalogi:</p>
<pre><code>$ mkdir /media/Kabi/pbuilder/

$ mkdir /media/Kabi/pbuilder/{hooks,build,result,pbuilder_apt_cache,ccache,pbuilder_apt_conf,lintian}

$ cp /etc/apt/sources.list /media/Kabi/pbuilder/pbuilder_apt_conf/
$ cp /etc/apt/trusted.gpg /media/Kabi/pbuilder/pbuilder_apt_conf/
</code></pre>
<p>W pliku <code>sources.list</code> zostawiamy jedynie wpisy od sida:</p>
<pre><code>deb     http://ftp.de.debian.org/debian/ sid main non-free contrib
deb-src http://ftp.de.debian.org/debian/ sid main non-free contrib
</code></pre>
<p>Pewnie zdarzy się nam taki przypadek, że pakiet, który chcemy zbudować, ma w zależnościach inny
pakiet, który dopiero co zbudowaliśmy i jak z takiej sytuacji wybrnąć? Potrzebne nam będzie własne
repozytorium, to, o którym była mowa we wstępie. Wpisy do takiego repozytorium również dodajemy do
konfiguracji <code>apt</code> dla pbuilder'a:</p>
<pre><code>deb http://deb.morfikownia.lh/debian/ sid main contrib non-free
deb-src http://deb.morfikownia.lh/debian/ sid main contrib non-free
</code></pre>
<p>Wszystkie zewnętrzne repozytoria będą wymagać publicznych kluczy GPG. Trzeba je również dostarczyć
pbuilder'owi. Kopiujemy zatem systemowy keyring:</p>
<pre><code>$ cp /etc/apt/trusted.gpg /media/Kabi/pbuilder/pbuilder_apt_conf/
</code></pre>
<p>Tworzymy teraz spakowane środowisko chroot. Po wydaniu poniższego polecenia, zostanie zainicjowany
<code>debootstrap</code> , który pobierze minimalnego debiana (sid), który to zostanie wstępnie skonfigurowany
i upchnięty w paczce <code>.tgz</code> :</p>
<pre><code>morfik:~$ sudo pbuilder create
W: /root/.pbuilderrc does not exist
I: Distribution is sid.
I: Current time: Thu Feb 19 12:36:23 CET 2015
I: pbuilder-time-stamp: 1424345783
I: Building the build environment
I: running debootstrap
/usr/sbin/debootstrap
I: Retrieving Release
I: Retrieving Release.gpg
I: Checking Release signature
I: Valid Release signature (key id A1BD8E9D78F7FE5C3E65D8AF8B48AD6246925553)
I: Retrieving Packages
I: Validating Packages
...
I: creating base tarball [/media/Kabi/pbuilder/base.tgz]
I: cleaning the build env
I: removing directory /media/Kabi/pbuilder/build//46518 and its subdirectories
</code></pre>
<p>W ten sposób utworzona paczka będzie wypakowywana za każdym razem, gdy będziemy budować jakiś pakiet
przy pomocy <code>sudo pbuilder --build</code> . Niemniej jednak, całe wypakowane środowisko, niezależnie od
powodzenia akcji budowania, zostanie na zakończenie usunięte. Jeśli będziemy budować wiele razy i to
tylko jeden pakiet, można edytować tego spakowanego chroot'a i doinstalować tam szereg zależności,
tak by podczas budowania nie były w kółko pobierane i instalowane. By edytować środowisko, wpisujemy
poniższe polecenie:</p>
<pre><code>$ sudo pbuilder --login --save-after-login
</code></pre>
<p>Każdy system, nawet ten minimalny chroot zrobiony przy pomocy <code>debootstrap</code>, wymaga by go
aktualizować w miarę regularnie, a konkretnie, przed budowaniem pakietu. By zaktualizować takie
środowisko, wpisujemy w terminalu to poniższe polecenie:</p>
<pre><code>$ sudo pbuilder --update
</code></pre>
<h2 id="źródła-i-informacje-o-nich">Źródła i informacje o nich</h2>
<p>W internecie jest wiele rozmaitych miejsc, gdzie można znaleźć źródła pakietu, który chcemy
zbudować. Zwykle będzie to strona projektu lub też i jakiś git, np. GitHub. Niemniej jednak, w tych
lokalizacjach bardzo rzadko spotkamy się ze źródłami, które pozwolą nam na zbudowanie pakietu tuż po
ściągnięciu ich na dysk.</p>
<p>W sporej części przypadków, większość roboty jaką będziemy musieli odwalić, to zbieranie informacji
na temat samego projektu. Chodzi generalnie o takie informacje jak licencja, zależności czy autorzy.
Czasem możemy pójść nieco na skróty i skorzystać z czyjejś pracy, tak by nieco przyśpieszyć
zbieranie tych danych.</p>
<p>Jeśli strona projektu nie jest w najlepszym stanie i brakuje kluczowych dla nas informacji, możemy
oczywiście wysłać maila do twórcy i poprosić go o stosowne info ale to zajmuje czas. Możemy także
zajrzeć na <a href="https://anonscm.debian.org/cgit/webwml/packages.git/">git debiana</a> i tam spróbować odnaleźć interesujący nas projekt. Jeśli doszukamy się
go, możemy być pewni, że część pracy przeprowadził już ktoś za nas.</p>
<p>Innym miejscem jest repozytorium <a href="https://aur.archlinux.org/">AUR dystrybucji Archlinux</a>. Tam zawsze idzie coś znaleźć,
tylko paczki nie są zbytnio kompatybilne z debianem i trzeba wiedzieć gdzie i czego szukać.
Przykładowo, załóżmy, że interesuje nas pakiet <code>monitorix</code> :</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2015/12/1.pakiet-aur-deb.png" alt=""    class="big"></p>
<p>Jak widzimy pakiet został odnaleziony i mamy tam info o licencji i o zależnościach. Niemniej jednak,
to nie wszystko co możemy wyciągnąć z AUR. Tam w prawym górnym rogu jest <code>PKGBUILD</code> . Jest to plik,
na podstawie którego buduje się pakiet dla Archlinux'a. Jak on nam może pomóc? Wystarczy do niego
zajrzeć. Są tam zależności (choć nazwy pakietów mogą być inne) , patch'e (do wydobycia przez link
<code>Download tarball</code> ), a nawet wywoływane konkretne polecenia (trzeba uważać na ścieżki). Wszystkie
te informacje możemy wykorzystać przy budowaniu paczki <code>.deb</code> . W tym przypadku strona projektu jest
w miarę rozsądna i można się doszukać na niej wszystkich informacji.</p>
<h2 id="katalog-debian">Katalog debian/</h2>
<p>Katalog <code>debian/</code> zawsze będziemy tworzyć po wypakowaniu źródeł i to w nim będziemy dokonywać
większości zmian, dlatego też musimy poznać nieco jego strukturę. Poniżej postaram się opisać
wszystkie pliki z tego katalogu, z którymi się spotkałem budując pakiety.</p>
<p>Generalnie rzecz biorąc, w oparciu o dane określone w tych plikach, narzędzie <a href="http://manpages.ubuntu.com/manpages/wily/en/man1/install.1.html">install</a> będzie
kopiować odpowiednie pliki/foldery i budować z tego drzewo katalogów, które następnie zostanie
przeniesione do pakietu wynikowego. Dlatego też dobrze jest sobie przyswoić poszczególne parametry
tego polecenia, bo to ułatwi ewentualne szukanie przyczyn problemów, np z błędnymi uprawnieniami
plików.</p>
<h3 id="tworzenie-szkieletu">Tworzenie szkieletu</h3>
<p>Zakładając, że nie udało nam się znaleźć zdebianizowanych źródeł, musimy przejść przez proces ich
zmiany. Na sam początek pobieramy źródła takie jak widzimy na stronie projektu i wypakowujemy je:</p>
<pre><code>$ mkdir debian_build

$ cd debian_build/

$ wget http://www.monitorix.org/monitorix-3.6.0.tar.gz

$ tar xpf monitorix-3.6.0.tar.gz

$ cd monitorix-3.6.0/
</code></pre>
<p>Tworzymy teraz katalog <code>debian/</code> przy pomocy <code>dh_make</code> :</p>
<pre><code>$ dh_make -s -c gpl2 -f ../monitorix-3.6.0.tar.gz
Maintainer name  : Mikhail Morfikov
Email-Address    : morfik@nsa.com
Date             : Thu, 07 Dec 2015 14:56:01 +0100
Package Name     : monitorix
Version          : 3.6.0
License          : gpl2
Type of Package  : Single
Hit &lt;enter&gt; to confirm:
Done. Please edit the files in the debian/ subdirectory now. You should also
check that the monitorix Makefiles install into $DESTDIR and not in / .
</code></pre>
<p>Nazwa maintainera oraz adres email został automatycznie uzupełnione w oparciu o zmienne <code>DEBEMAIL</code>
oraz <code>DEBFULLNAME</code> , które podaliśmy wcześniej w pliku <code>~/.bashrc</code> . W zależności od tego jaki
pakiet będziemy budować, możemy skorzystać ze wzorców plików. Inaczej wyglądają one w przypadku
bibliotek, a inaczej w przypadku modułów kernela, etc. W tym przypadku budujemy pojedynczą binarkę i
dlatego skorzystaliśmy z opcji <code>-s</code>. Opcja <code>-c gpl2</code> odpowiada za uzupełnienie pliku <code>copyright</code> (o
nim później) o odpowiedni tekst licencji. Ostatnia opcja <code>-f</code> odpowiada za podanie pliku z
upstream'owymi źródłami. To w oparciu o ten plik będą robione ewentualne patche (o tym też później),
bo źródeł upstream'owych jako takich nie wolno nam zmieniać i nie należy mylić ich z plikami, które
mamy w wypakowanym katalogu.</p>
<p>Powinniśmy mieć już dostępny katalog <code>debian/</code> . Z kolei w katalogu nadrzędnym powinna pojawić się
dodatkowa paczka: <code>monitorix_3.6.0.orig.tar.gz</code> . Nazwa nowego pliku ze źródłami ma swój
zdefiniowany format, który wygląda tak: <code>pakiet_wersja.orig.tar.gz</code> .</p>
<p>Przechodzimy do katalogu <code>debian/</code> :</p>
<pre><code>$ cd debian/
</code></pre>
<p>Mamy w nim szereg plików, które zostały automatycznie wygenerowane ale nie wszystkie z nich zawsze
będą nam potrzebne. Dobrze jest też wiedzieć, że w przypadku, gdy skasujemy (naszym zdaniem)
niepotrzebne pliki, to możemy nakazać <code>dh_make</code> aby przywrócił ich szablony. By odzyskać skasowane
pliki, będziemy musieli wydać to poniższe polecenie:</p>
<pre><code>$ dh_make --addmissing
...
File source/format exists, skipping.
File changelog exists, skipping.
File compat exists, skipping.
...
</code></pre>
<p>Nowe pliki powinny być już dostępne w katalogu <code>debian/</code> i jak widać wyżej, system nie ruszył tych,
które już istniały, a jedynie dodał te brakujące.</p>
<h3 id="debiancontrol">debian/control</h3>
<p>Jednym z ważniejszych plików jest <code>debian/control</code> . To w nim są definiowane min. zależności
potrzebne do zbudowania/instalacji pakietu i to w oparciu o te zależności właśnie menadżery
pakietów, takie jak <code>apt</code> czy <code>aptitude</code> , będą wiedzieć jak zainstalować konkretny pakiet. W tym
przypadku, ten plik wygląda następująco:</p>
<pre><code>Source: monitorix
Section: net
Priority: optional
Maintainer: Mikhail Morfikov &lt;morfik@nsa.com&gt;
Build-Depends: debhelper (&gt;= 9), dh-systemd (&gt;= 1.5)
Standards-Version: 3.9.6
Homepage: http://www.monitorix.org/
Vcs-Git: git://github.com/mikaku/Monitorix.git
Vcs-Browser: https://github.com/mikaku/Monitorix

Package: monitorix
Architecture: any
Depends: ${shlibs:Depends}, ${misc:Depends}, ${perl:Depends},
 rrdtool,
 ...
Suggests: hddtemp,
 ...
Description: Web system monitoring tool
 ...
</code></pre>
<p>Trochę tego jest. Jedziemy zatem od góry. Linijka <code>Source</code> określa nazwę źródła, czyli to co
zostanie pobrane po wydaniu polecenia <code>apt-get source</code> , z tym, że bez wersji i sufiksu <code>.tar.gz</code> .</p>
<p>Dalej mamy <code>Section</code> i odpowiada to za przypisanie pakietu do konkretnej sekcji, a tych jest dość
sporo. Wszystkie można znaleźć <a href="https://packages.debian.org/unstable/">tutaj</a>. Tylko taka mała uwaga, zwykle tam w linku spotkamy się
z nazwami typu &quot;Administration Utilities&quot; lub &quot;Network&quot; i to nie są te nazwy, które musimy wpisać
do pliku <code>debian/control</code> . Jeśli klikniemy w daną sekcję, na samej górze dopiero dostaniemy
prawidłową nazwę, przykładowo: Software Packages in &quot;sid&quot;, Subsection <code>net</code> i to właśnie to musimy
wpisać.</p>
<p>Kolejna linijka to <code>Priority</code> i określa ona jak ważna jest paczka z punktu widzenia prawidłowego
działania systemu i z reguły tutaj będziemy wpisywać <code>optional</code> albo <code>extra</code> . Różnica między tymi
dwoma polega na tym, że ten pierwszy nie koliduje z żadnymi pakietami, które mają ustawiony
priorytet <code>required</code> , <code>important</code> lub <code>standard</code> , czyli pakiety wchodzące w skład bardzo
podstawowej instalacji systemu.</p>
<p>Następnie mamy <code>Maintainer</code> , czyli osobę, która budowała i będzie się opiekować danym pakietem.</p>
<p>Kolejna pozycja to <code>Build-Depends</code> i jest to nic innego jak zależności, które muszą zostać
spełnione, aby podjąć próbę budowania pakietu. Jeśli jakaś zależność nie zostanie spełniona,
<code>pbuilder</code> nawet nie podejmie się próby stworzenia takiego pakietu. Nie zawsze też pakiet zbuduje
się nam poprawnie w przypadku, gdy wszystkie zależności zostaną zaspokojone. Wtedy będzie trzeba
poszukać tych brakujących pakietów, których zapomnieliśmy dodać lub zwyczajnie je przeoczyliśmy i
dlatego wymagane jest budowanie paczek w minimalnym środowisku chroot. Taka mała uwaga odnośnie
&quot;bardzo podstawowych&quot; zależności, np. <code>gcc</code> . Jeśli zdefiniujemy <code>gcc</code> w tutaj zależnościach, system
upomni się o sprecyzowanie konkretnej wersji takiego pakietu. Jeśli korzystamy z dodatkowych modułów
dla debhelper'a, tak jak w tym przypadku wykorzystywany jest <code>dh-systemd</code> , trzeba ten pakiet
również uwzględnić w zależnościach.</p>
<p>Zależności będą podane na stronie projektu ale czasem (albo i często) nazwy będą bardzo
nieprecyzyjne, np. <code>qt5</code> i ciężko będzie nam ustalić, o który pakiet tak naprawdę może chodzić.
Zwykle też do źródeł będzie dołączony plik <code>README</code> lub <code>INSTALL</code> z instrukcjami na temat budowy
programu. Przykład:</p>
<pre><code>REQUIREMENTS
===============================================================================
Monitorix requires some others packages to be installed that your GNU/Linux
distribution may or may not have:

- Perl
- Perl-CGI
- Perl-libwww
- Perl-MailTools
- Perl-MIME-Lite
- Perl-DBI
- Perl-XML-Simple
- Perl-Config-General
- Perl-HTTP-Server-Simple
- perl-IO-Socket-SSL
- RRDtool and its Perl bindings (perl-rrdtool or rrdtool-perl)
- (Optional) a CGI capable Web server (Apache, Nginx, lighttpd, etc.)
</code></pre>
<p>Z tym, że trzeba rozróżnić zależności potrzebne do budowania pakietu i zależności potrzebne do
poprawnego działania programu.</p>
<p>Jeśli dany pakiet posiada plik <code>configure</code> , możemy poszukać na podstawie tego pliku potrzebnych
zależności przy pomocy <code>dpkg-depcheck</code> . Z tym, że trzeba mieć na uwadze, że ten <code>dpkg-depcheck</code>
wyrzuca zależności potrzebne do wykonania się polecenia i niekoniecznie wszystkie pakiety, które nam
zwróci musimy wpisać jako zależności w budowanej paczce. Poza tym informacje o zależnościach są
czasem niezbyt precyzyjne, np. nie wiemy nic wersji danej zależności. Poniżej przykład:</p>
<pre><code>$ dpkg-depcheck -d ./configure
checking build system type... x86_64-unknown-linux-gnu
checking host system type... x86_64-unknown-linux-gnu
...
----------------------------------------------------------------------
Packages needed:
  libc6-i386
  cpio
  perl
  ...
</code></pre>
<p>Zwykle będą nas interesować pakiety zaczynające się od <code>lib</code> , do których to będzie trzeba dodać
końcówkę <code>-dev</code> i taki pakiet dać w zależnościach. Trzeba także pamiętać, że część z powyższych
zależności może być pociągnięta przez jakiś metapakiet np. <code>build-essential</code> i możemy sobie darować
ich wpisywanie do pliku <code>debian/control</code> . Na dobrą sprawę, powyższe wyjście dobrze jest traktować
orientacyjne, a nie dosłownie.</p>
<p>Innym sposobem na ustalenie zależności może być posłużenie się <code>objdump</code> , z tym, że ten skanuje
pliki wykonywalne i by móc z niego skorzystać, musimy mieć uprzednio skompilowany program. W każdym
razie, jeśli już mamy w systemie jakiś pakiet, to zależności ustalamy tak:</p>
<pre><code>$ objdump -p /usr/sbin/dnscrypt-proxy | grep NEEDED
  NEEDED               libsodium.so.13
  NEEDED               libdl.so.2
  NEEDED               libm.so.6
  NEEDED               libc.so.6
</code></pre>
<p>Podobnie jak w przypadku <code>dpkg-depcheck</code> , obcinamy <code>.so.*</code> i dołączamy sufiks <code>-dev</code> .</p>
<p>Następnie mamy <code>Standards-Version</code> i jest to wersja standardu polityki debiana jaka ma być
spełniona, aby zbudować tę paczkę i zawsze trzeba ustawiać tutaj najnowszą wersję, obecnie jest to
3.9.6 . Jeśli w późniejszym czasie wersja ulegnie zmianie, pakiet trzeba będzie przebudować i
prawdopodobnie będą potrzebne też jakieś mniejsze zmiany, by spełnić wymogi nowszej wersji
standardu.</p>
<p>Opcje <code>Homepage</code> , <code>Vcs-Git</code> oraz <code>Vcs-Browser</code> określają położenie projektu w sieci i czy korzysta
z jakiegoś systemu kontroli wersji (VCS). Jeśli projekt nie korzysta z VCS, możemy usunąć te linijki
z pliku.</p>
<p>Część opisową źródeł mamy z głowy. Druga część pliku dotyczy tego co zostanie zbudowane, czyli jaki
pakiet opuści plac budowy.</p>
<p>Linijka z <code>Package</code> określa nazwę pakietu, domyślnie taka sama jak nazwa źródła.</p>
<p>Kolejna linijka to <code>Architecture</code> i tu możemy wpisać <code>all</code> albo <code>any</code> . Różnica między tymi dwoma
tkwi w rodzaju budowanych plików. Jeśli budujemy skrypty, wtedy tak naprawdę nie budujemy ich tylko
kopiujemy pliki do paczki, a taki skrypt może być odpalony na każdej architekturze i w takim
przypadku wybieramy <code>all</code> . Z kolei pliki wymagające kompilacji trzeba budować dla każdej
architektury osobno i tutaj dajemy zwykle <code>any</code> , chyba, że pakiet ma wyraźnie zaznaczone na stronie
projektu, że przeznaczony jest tylko dla np. amd64 czy i386 . Wtedy podajemy wedle opisu. Taka mała
uwaga jeszcze. Przyjdzie nam budować pakiety, które będą się składać ze skryptów, obrazków, mp3 i
całego mnóstwa innych rzeczy, którym normalnie byśmy nadali arch <code>all</code> ale dodatkowo będą zawierać
jeden lub kilka plików binarnych i z tego powodu arch <code>all</code> odpada ale też nie możemy zbudować
takiego pakietu z arch <code>any</code> , bo <code>lintian</code> będzie się rzucał, że marnujemy miejsce na serwerze, bo
przecie z jego perspektywy, jeśli jakiś pakiet zawiera znaczne ilości plików niezależnych od
architektury, to nie możemy dawać arch <code>any</code> i musimy dać <code>all</code> i jak z takiej sytuacji wybrnąć?
Trzeba pakiet podzielić na dwie części. W jednej z nich dać pliki wymagające kompilacji, a w drugiej
(zwykle paczka-common) dać wszystkie pliki niezależne od architektury i dodać odpowiednie zależności
do paczki trzymającej plik binarny -- o tym będzie więcej przy okazji omawiania pliku
<code>debian/rules</code> .</p>
<p>Następne linijki to <code>Depends</code> , <code>Suggests</code> , <code>Recommends</code> , <code>Conflicts</code> , <code>Breaks</code> , <code>Provides</code> i
<code>Replaces</code> i są to zależności, które muszą być spełnione przy instalacji pakietu. Nie wszystkie z
wyżej wymienionych opcji będziemy zawsze używać. Zwykle ograniczymy się do pierwszych trzech.
Różnice między nimi są następujące. Jeśli pakiet wymaga do działania innego pakietu, dajemy go w
<code>Depends</code> . Jeśli nasz pakiet może się obyć bez innego pakietu ale traci na tym trochę ze swojej
funkcjonalności, to dajemy tamten pakiet w <code>Recommends</code> . Jeśli jakiś pakiet przydaje się ale można
bez niego żyć, to dopisujemy go do <code>Suggests</code> . Jeśli nasz pakiet dostarcza pliki dostępne w innych
pakietach, dajemy ten drugi pakiet w <code>Conflics</code>. Z kolei <code>Breaks</code> będziemy używać przy przenoszeniu
plików z jednego pakietu do innego, np. przy podziale pakietu na kilka mniejszych. Jeśli nasz pakiet
jest alternatywą dla innego pakietu, np. firefox jest alternatywą dla chrome (i vice versa), możemy
wpisać w polu <code>Provides</code> www-browser i wtedy każdy inny pakiet, który ma w swoich zależnościach
www-browser , przy instalacji będzie prosił o zainstalowanie firefoxa albo chrome (ew. obu). Jeśli
chodzi o <code>Replaces</code> , to zwykle jest używany on (w połączeniu z <code>Conflicts</code>) przy zastępowaniu
starych i nieaktualnych już pakietów, np. jeśli mamy do czynienia z forkami jakichś projektów i
projekt główny nie jest już rozwijany ale w repozytorium wciąż jest dostępna paczka z nim.
Generalnie nie możemy mieć zainstalowanych obu tych pakietów jednocześnie.</p>
<p>Każde z tych pól może zawierać określoną wersję danego pakietu. Wykorzystujemy do tego następujące
operatory: <code>&lt;&lt;</code> , <code>&lt;=</code> , <code>=</code> , <code>&gt;=</code> oraz <code>&gt;&gt;</code> . Jeśli pakiet ma być w określonej wersji, to dajemy
<code>=</code> . Jeśli wersja ma być mniejsza lub równa, to wtedy używamy <code>&lt;=</code> . Z kolei jeśli większa lub
równa to <code>&gt;=</code> . Jeśli zaś wersja ma być mniejsza, to korzystamy z <code>&lt;&lt;</code> , a jeśli większa, to <code>&gt;&gt;</code> .</p>
<p>Jeśli chodzi zaś o same zależności wymagane do prawidłowego działania pakietu, to
<code>${shlibs:Depends}</code> i <code>${misc:Depends}</code> automatycznie ustalą czego paczka potrzebuje w oparciu o
zależności potrzebne do zbudowania tego pakietu. Niemniej jednak, czasem (jak w tym przypadku)
trzeba sprecyzować kilka dodatkowych pakietów. Ponadto, jeśli budujemy paczkę ze skryptami perl'a,
trzeba dopisać <code>${perl:Depends}</code> , jeśli jest to python'owy skrypt, to dajemy <code>${python:Depends}</code>
lub <code>${python3:Depends}</code> w zależności od wersji python'a. Wszystkie te dodatkowe listy z
generowanymi pakietami są wpisywane do pliku <code>debian/control</code> w paczce wynikowej i możemy te
zależności dokładnie obejrzeć i ewentualnie oszacować czy czegoś brakuje. Więcej informacji na
temat określania zależności między pakietami, można znaleźć <a href="https://www.debian.org/doc/debian-policy/ch-relationships.html">tutaj</a>. Wspomnieć też należy, że
to nie są jedyne opcje, które możemy wykorzystać przy podstawianiu zmiennych, więcej o pozostałych
można przeczytać w manie <a href="http://manpages.ubuntu.com/manpages/wily/man5/deb-substvars.5.html">deb-substvars</a>.</p>
<p>I ostatnia pozycja w tym pliku to <code>Description</code> , czyli opis pakietu. Ten po dwukropku zwykle jest
krótki i nie powinien przekraczać 65 znaków -- więcej zostanie obciętych. Jeśli zaś chodzi o dłuższy
opis, to wpisujemy go bezpośrednio pod tą linijką, z tym, że wcinamy tekst o jedną spację i długość
linijki nie może przekraczać 80 znaków. Każda nowa linia musi być wcięta. Jeśli chcemy zrobić odstęp
między paragrafami (pusta linia), to dajemy kropkę (również wciętą) i dalej nowy paragraf. Jeśli
chcemy skorzystać z list, czyli wypunktować różne rzeczy, wcinamy linijkę przy pomocy dwóch spacji i
dajemy myślnik albo gwiazdkę. Ja zwykle daję gwiazdki.</p>
<h3 id="debianrules">debian/rules</h3>
<p>Jak sama nazwa wskazuje, ten plik będzie zawierał szereg reguł, w oparciu o które pakiet zostanie
zbudowany. Generalnie rzecz biorąc jest to plik <code>makefile</code> tylko nieco inny.</p>
<p>Budowanie pakietu odbywa się w etapach. Wywoływany jest pierwszy etap i dokonywane są zdefiniowane w
nim reguły, po czym następuje przejście do kolejnego etapu i aplikowane są reguły określone tutaj i
tak dalej, aż do samego końca.</p>
<p>Poniżej znajduje się minimalny plik <code>debian/rules</code> :</p>
<pre><code>#!/usr/bin/make -f

export DH_VERBOSE = 1
export DH_OPTIONS = -v

%:
   dh $@
</code></pre>
<p>Dobrze jest wyeksportować te dwie dodatkowe zmienne <code>DH_VERBOSE</code> oraz <code>DH_OPTIONS</code> . Uwidocznią one
poszczególne etapy budowania pakietu i będziemy widzieć każde polecenie jakie będzie wykonywane,
dzięki czemu znacznie przyśpieszymy proces przyswajania sobie całej tej potrzebnej nam wiedzy z
zakresu budowania pakietów.</p>
<p>Dalej w pliku mamy <code>%:</code> i jest to wildcard oznaczający każdy target (etap) przy budowaniu pakietu, a
tych jest sporo. Poniżej jest zobrazowany proces budowania paczki <code>dnscrypt-proxy</code> :</p>
<pre><code> fakeroot debian/rules clean
dh clean --with systemd,autotools-dev
   dh_testdir
   dh_auto_clean
   dh_clean

 debian/rules build
dh build --with systemd,autotools-dev
   dh_testdir
   dh_auto_configure
   dh_auto_build
   dh_auto_test

 fakeroot debian/rules binary
dh binary --with systemd,autotools-dev
   dh_testroot
   dh_prep
   dh_installdirs
   dh_auto_install
   dh_install
   dh_installdocs
   dh_installchangelogs
   dh_installexamples
   dh_installman
   dh_installcatalogs
   dh_installcron
   dh_installdebconf
   dh_installemacsen
   dh_installifupdown
   dh_installinfo
   dh_systemd_enable
   dh_installinit
   dh_systemd_start
   dh_installmenu
   dh_installmime
   dh_installmodules
   dh_installlogcheck
   dh_installlogrotate
   dh_installpam
   dh_installppp
   dh_installudev
   dh_installwm
   dh_installgsettings
   dh_bugfiles
   dh_ucf
   dh_lintian
   dh_gconf
   dh_icons
   dh_perl
   dh_usrlocal
   dh_link
   dh_installxfonts
   dh_compress
   dh_fixperms
   dh_strip
   dh_makeshlibs
   dh_shlibdeps
   dh_installdeb
   dh_gencontrol
   dh_md5sums
   dh_builddeb
</code></pre>
<p>W każdym z powyższych targetów może znajdować się szereg akcji, np:</p>
<pre><code>dh_installman
   man --recode UTF-8 ./dnscrypt\-proxy\.8 &gt; dnscrypt\-proxy\.8\.new
   chmod 644 dnscrypt-proxy.8.new
   mv -f dnscrypt-proxy.8.new dnscrypt-proxy.8
   man --recode UTF-8 ./hostip\.8 &gt; hostip\.8\.new
   chmod 644 hostip.8.new
   mv -f hostip.8.new hostip.8
</code></pre>
<p>Każdy z etapów wywołuje określone narzędzie, które ma na celu coś zrobić. Z reguły są to skrypty
zaczynające się od <code>dh_</code> i każdy z nich ma swój własny manual. Warto poczytać jeśli potrzebujemy
informacji na temat pewnych opcji pojawiających się w logu podczas budowania. Nie zawsze będziemy
korzystać ze wszystkich wyżej wylistowanych targetów. To zależeć będzie od tego co tak naprawdę
będziemy budować. Jeśli budujemy pakiet mający pliki unitów dla systemd, to logiczne jest, że
będziemy przechodzić przez etap <code>dh_systemd_enable</code> i <code>dh_systemd_start</code> . Warto też wiedzieć, że
szereg z powyższych targetów ma swoje pliki konfiguracyjne w katalogu <code>debian/</code> , np. targetowi
<code>dh_install</code> przypisany jest plik <code>*.install</code> .</p>
<p>Wszelkie moduły, z których chcemy skorzystać przy budowie paczki, precyzujemy po <code>dh $@</code> . Poniżej
przykład skorzystania z modułu <code>dh_systemd</code> :</p>
<pre><code>...
%:
   dh $@ --with dh_systemd
...
</code></pre>
<p>Jeśli modułów było by więcej, dodajemy je kolejno oddzielając je od siebie za pomocą przecinka.
Musimy także pamiętać o dodaniu odpowiednich zależności w pliku <code>debian/control</code> .</p>
<p>Jeśli chodzi o dalszą część pliku <code>debian/rules</code>, to nasuwa się pytanie -- skąd ja mam wiedzieć co
tutaj wpisać i jakie reguły zaaplikować? Zwykle <code>debhelper</code> wykryje upstream'owy plik <code>makefile</code> i
powinien sobie z procesem budowania poradzić bez naszej ingerencji ale czasem szereg plików trzeba
będzie usunąć, a niektóre stworzyć lub przenieść w inne miejsce, tak by paczka miała ręce i nogi i
nie zawierała przy tym zbędnych śmieci.</p>
<p>Jeśli kiedyś zdarzyło nam się instalować pakiet ręcznie, tj. via <code>./configure</code> (dh_auto_configure),
<code>make</code> (dh_auto_build) i <code>make install</code> (dh_auto_install), to może nam to podsunąć kilka pomysłów,
bo tak na dobrą sprawę, to jak sama nazwa wskazuje <code>makefile</code> tworzy pliki. Zatem jest to prosta
instrukcja gdzie wgrać jakie pliki, by program działał jak trza. Zatem możemy podejrzeć plik
<code>makefile</code> dołączony do źródeł i prześledzić co tak naprawdę w nim się odbywa. Z reguły pliki
<code>makefile</code> są długie i nie będę tutaj przytaczał całości. Rzucimy jedynie okiem na najważniejsze
jego fragmenty:</p>
<pre><code>PN = monitorix

PREFIX ?= /usr
CONFDIR = /etc
BASEDIR = /var/lib/monitorix/www
LIBDIR = /var/lib/monitorix
INITDIR_SYSTEMD = $(PREFIX)/lib/systemd/system
INITDIR_OTHER = $(CONFDIR)/init.d
BINDIR = $(PREFIX)/bin
DOCDIR = $(PREFIX)/share/doc/$(PN)
MAN5DIR = $(PREFIX)/share/man/man5
MAN8DIR = $(PREFIX)/share/man/man8

RM = rm -f
RMD = rmdir
SED = sed
INSTALL = install -p
INSTALL_PROGRAM = $(INSTALL) -m755
INSTALL_SCRIPT = $(INSTALL) -m755
INSTALL_DATA = $(INSTALL) -m644
INSTALL_DIR = $(INSTALL) -d
</code></pre>
<p>Powyżej mamy nagłówek pliku <code>makefile</code> monitorix'a. Jak widać jest ustawianych szereg zmiennych.
Głównie precyzowane są katalogi, do których powędrują pliki, jak i same polecenia instalujące
pliki w tych katalogach.</p>
<p>Dalej mamy już zwykle operacje na plikach, np:</p>
<pre><code>install-bin:
    $(Q)echo -e '\033[1;32mInstalling script and modules...\033[0m'
    $(INSTALL_DIR) &quot;$(DESTDIR)$(BINDIR)&quot;
    $(INSTALL_PROGRAM) $(PN) &quot;$(DESTDIR)$(BINDIR)/$(PN)&quot;

    $(INSTALL_DIR) &quot;$(DESTDIR)$(BASEDIR)/cgi&quot;
    $(INSTALL_DIR) &quot;$(DESTDIR)$(BASEDIR)/imgs&quot;
    $(INSTALL_PROGRAM) $(PN).cgi &quot;$(DESTDIR)$(BASEDIR)/cgi/$(PN).cgi&quot;
    $(INSTALL_DATA) logo_bot.png &quot;$(DESTDIR)$(BASEDIR)/logo_bot.png&quot;
    $(INSTALL_DATA) logo_top.png &quot;$(DESTDIR)$(BASEDIR)/logo_top.png&quot;
    $(INSTALL_DATA) monitorixico.png &quot;$(DESTDIR)$(BASEDIR)/monitorixico.png&quot;

    $(INSTALL_DIR) &quot;$(DESTDIR)$(CONFDIR)/$(PN)&quot;
    $(INSTALL_DATA) $(PN).conf &quot;$(DESTDIR)$(CONFDIR)/$(PN)/$(PN).conf&quot;
...
</code></pre>
<p>I jak widać niczym się to zbytnio nie różni o zwykłego Ctrl-C z jednego miejsca i Ctrl-V w inne
miejsce. Zatem mamy już mniej więcej obraz tego co tak naprawdę się będzie działo podczas budowania
pakietu. <code>debhelper</code> przetworzy ten plik <code>makefile</code> i zainstaluje poszczególne pliki w
zdefiniowanych lokalizacjach, a potem z tego zrobi paczkę. Z tym, że trzeba wziąć pod uwagę jedną
rzecz. W tym przypadku mamy do czynienia ze skryptem perl'a i tutaj nie odbywa się żadna kompilacja.
Niemniej jednak, po kompilacji są tworzone pliki wynikowe i to w dużej mierze właśnie te pliki będą
upychane w odpowiednich katalogach.</p>
<p>Jeśli nie chce nam się zbytnio brodzić w pliku <code>makefile</code> , to z reguły informacje na temat
budowania pakietu będą podane w pliku <code>README</code> albo <code>INSTALL</code> , które są dołączone do paczki ze
źródłami. Przykładowo:</p>
<pre><code>INSTALLATION
===============================================================================
Running a 'make install-xxx' as root will distribute the files to the file
system. Most users will want to select from three options depending on target
init system (do not run all four)!

   # make install-systemd-all
   # make install-upstart-all
   # make install-debian-all
   # make install-redhat-all

Alternatively, users may override any of the in make targets.  For example:

   $ make DESTDIR=~/pub BASEDIR=/srv/http/monitorix install-systemd-all
...
</code></pre>
<p>I tu już wiemy dokładnie czego szukać w pliku <code>makefile</code> i jak zainstalować ten programik. Nam
potrzebne są 2 (max 3) z tych 4 wyżej wymienionych rzeczy. W końcu budujemy paczkę dla debiana,
zatem plik <code>debian/rules</code> powinien przybrać poniższą postać:</p>
<pre><code>#!/usr/bin/make -f

export DH_VERBOSE = 1

%:
   dh $@

override_dh_auto_install:
   dh_auto_install -- \
      install-systemd-all \
      install-upstart-all \
      install-debian-all
</code></pre>
<p>Normalnie proces budowy przechodząc przez poszczególne etapy dotrze do targetu <code>dh_auto_install</code> ,
który wykona instrukcje zawarte w pliku <code>makefile</code> , czyli zainstaluje wszystko co tam jest podane,
a tego nie zawsze chcemy. Dlatego też, mamy możliwość nadpisywania szeregu etapów budowania przez
dopisanie <code>override_*</code> . Powyżej nadpisaliśmy etap automatycznej instalacji przekazując do polecenia
<code>make</code> trzy parametry, uzyskując w ten sposób dokładnie taką samą sekwencję poleceń (za wyjątkiem
jednego), która była określona w pliku <code>README</code> .</p>
<p>Kluczowe w tej zwrotce z <code>dh_auto_install</code> jest zrozumienie po co na końcu tego polecenia dodawane
są <code>--</code> , bo można także podać parametry bez tych dwóch myślników. Jaka jest zatem różnica? Jeśli
wywołujemy jakiś target z <code>--</code> , to wszystkie parametry znajdujące się za tymi myślnikami są
dołączane do wynikowego polecenia. W przypadku, gdy nie podamy tych myślników, system zresetuje
wszystkie poprzednie opcje i zamiast nich użyje te, które zostaną podane bezpośrednio za wywoływanym
targetem.</p>
<p>Weźmy sobie przykład skryptu <code>configure</code> . Domyślnie ma on określone, dajmy na to, takie parametry
<code>--prefix=/usr --localstatedir=/var</code> . Jeśli chcielibyśmy dodać kolejny parametr, korzystamy z
myślników:</p>
<pre><code>dh_auto_configure -- --sysconfdir=/etc
</code></pre>
<p>Jeśli chcielibyśmy użyć kompletnie innych wartości dla skryptu configure, pomijamy <code>--</code> ,
przykładowo:</p>
<pre><code>dh_auto_configure --prefix=/usr/local --localstatedir=/usr/local/var --sysconfdir=/usr/local/etc
</code></pre>
<p>Mamy jeszcze kilka innych opcji tyczących się nadpisywania targetów. Jeśli, przykładowo,
odpowiadałby nam etap instalacji ale chcielibyśmy coś dodać do niego (przed albo po), wtedy musimy
wywołać jego target i dodać swoje polecenia przed lub po nim, przykładowo:</p>
<pre><code>...
override_dh_auto_install:
   dh_auto_install -- install install-gui
   rm debian/tmp/usr/share/doc/ansifilter/ChangeLog
   rm debian/tmp/usr/share/doc/ansifilter/COPYING
   rm debian/tmp/usr/share/doc/ansifilter/INSTALL
   rm debian/tmp/usr/share/man/man1/ansifilter.1.gz
...
</code></pre>
<p>Powyżej został wywołany <code>make</code> z dwoma parametrami <code>install</code> oraz <code>install-gui</code> , poza tym, część
plików automatycznie zainstalowanych, zostanie usunięta, tak by nie trafiła do wynikowego pakietu.</p>
<p>Jeśli natomiast chcielibyśmy nadpisać jakiś etap całkowicie, tak by nie wykonała się w nim żadna
akcja, to możemy to zrobić precyzując jedynie sam target + override, przykładowo:</p>
<pre><code>override_dh_auto_install:
</code></pre>
<p>A jeśli pasowałoby nam jedynie nadpisać standardowe akcje, wtedy nie wywołujemy <code>dh_auto_install</code> ,
tylko od razu precyzujemy własne linijki, przykładowo:</p>
<pre><code>...
override_dh_auto_install:
   install -d -m 755 debian/napi/usr/share/napi/
   install -d -m 755 debian/napi/usr/bin/
   install -m755 ./napi.sh debian/napi/usr/bin/
   install -m755 ./subotage.sh debian/napi/usr/bin/
   install -m755 ./napi_common.sh debian/napi/usr/share/napi/
...
</code></pre>
<p>Jeśli instalujemy jakieś pliki, ścieżki do nich podajemy względem głównego katalogu ze źródłami. Z
kolei jeśli chcemy jakiś plik usunąć, to zwykle podajemy ścieżki debian/tmp/ lub
debian/nazwa_pakietu/ + odpowiednia ścieżka w drzewie katalogu, np.
<code>debian/tmp/usr/share/doc/ansifilter/INSTALL</code> . Jeśli nie usunęlibyśmy tego pliku, w paczce
znalazłby się on pod <code>/usr/share/doc/ansifilter/INSTALL</code> .</p>
<h3 id="debianchangelog-i-debianupstreamchangelog">debian/changelog i debian/upstream.changelog</h3>
<p>Każdy projekt musi mieć listę wprowadzanych zmian, a te z kolei dzielimy na takie, które sami
wprowadzamy lub też zostały uwzględnione w upstream'ie. Generalnie rzecz biorąc, większość projektów
utrzymuje swój plik changelog (z reguły zlokalizowany w głównym katalogu źródeł) i nie musimy się o
niego martwić. Niemniej jednak, spotkamy się z takimi projektami, które nie mają pliku changelog'a,
lub w ogóle nie posiadają żadnej historii zmian za wyjątkiem kolejnego numerku wersji.</p>
<p>Jeśli jest to przypadek pierwszy, czyli projekt ma changelog, np. na swojej stronie, ale nie
dostarcza pliku, w którym zmiany by były uwzględnione, możemy taki plik zrobić i do niego skopiować
zawartość strony www. Plik taki nazywamy <code>upstream.changelog</code> . Format tego pliku jest chyba
dowolny, np. może wyglądać tak:</p>
<pre><code>Version 2.2
-------------
 * Fix problems with small displays like 80×25
 * Fix ATA compliance recognition (see bug #57)
 * Replace “Press any key” with “Press ‘m’ for menu”
 * Rework signal handling during procedure for stability
 * Improve build system

Version 2.1
-------------
 * Enhanced smart, smart_noreverse copying strategies;
 * Introduced new copying strategies skipfail, skipfail_noreverse;
 * Introduce journaling of copying and automatic resuming of interrupted copying;
 * Support procedure parameters overriding by ~/.whddrc config file;
 * Several bug fixes.
...
</code></pre>
<p>Trzeba tylko poinformować debhelper'a by przepisał nazwę pliku, pod którą ten changelog będzie
widoczny w wynikowej paczce, przykładowo:</p>
<pre><code>override_dh_installchangelogs:
   dh_installchangelogs -k debian/upstream.changelog
</code></pre>
<p>Powyższy kod wpisujemy oczywiście do pliku <code>debian/rules</code> i stworzy on linka <code>changelog</code> do pliku
<code>upstream.changelog</code> . Więcej informacji na temat <code>dh_installchangelogs</code> można znaleźć w
<a href="http://manpages.ubuntu.com/manpages/wily/en/man1/dh_installchangelogs.1.html">manie</a>.</p>
<p>Jeśli chodzi zaś o te zmiany, które sami wprowadzamy, to dopisujemy je do pliku <code>debian/changelog</code> ,
który na początku ma poniższą postać:</p>
<pre><code>monitorix (3.6.0-1) unstable; urgency=low

  * Initial release (Closes: #nnnn)

 -- Mikhail Morfikov &lt;morfik@nsa.com&gt;  Thu, 19 Feb 2015 14:00:01 +0100
</code></pre>
<p>Oczywiście nie edytujemy tego pliku ręcznie (choć można). Do jego obsługi mamy narzędzie <code>dch</code> , do
którego doklejamy tylko odpowiedni parametr i zwykle to będzie <code>-a</code> (dodanie nowej pozycji w
istniejącym już wpisie), <code>-i</code> (utworzenie nowego wpisu), <code>-r</code> (zaktualizowanie sygnatury czasowej),
oraz <code>-v</code> (zmiana wersji).</p>
<p>Przy zmianie wersji trzeba jednak uważać, bo zostanie zmieniona nazwa katalogu roboczego,
przykładowo:</p>
<pre><code>morfik:~/debian_build/monitorix-3.5.0$ dch -v 3.6.0
dch warning: New package version is Debian native whilst previous version was not
dch warning: your current directory has been renamed to:
../monitorix-3.6.0

morfik:~/debian_build/monitorix-3.5.0$ cd ..

morfik:~/debian_build$ cd monitorix-3.6.0/

morfik:~/debian_build/monitorix-3.6.0$
</code></pre>
<p>W przypadku, gdy będziemy chcieli włączyć pakiet do repozytorium debiana, trzeba będzie założyć
stosowny wątek na bugtracker, któremu zostanie przypisany odpowiedni numer identyfikacyjny i to
ten numer będziemy musieli podać w pliku <code>debian/changelog</code> , np. <code>(Closes: #123456</code> . Ma to na celu
zautomatyzowanie procesu śledzenia i zamykania błędów, bo plik <code>debian/changelog</code> jest skanowany w
poszukiwaniu pewnych wyrażeń i np. BTS po dodaniu powyższego pakietu automatycznie zamknie zawarte w
nim kody błędów, oczywiście o ile wpiszemy poprawne numerki. To samo tyczy się zgłaszania kolejnych
błędów. Jeśli uda nam się je poprawić albo zostaną poprawione w upstream'ie, to wystarczy dopisać w
changelog'u numerki zgłoszonych przez kogoś błędów i po przesłaniu paczki, system zamknie je
automatycznie. Bez tego automatu, sami musielibyśmy to robić.</p>
<p>Jeśli chcielibyśmy się bawić w maintainera z prawdziwego zdarzenia, trzeba będzie nam przyswoić
umiejętność operowania na listach mailingowych debiana. To tam będziemy mieć dostęp do bugtracker'a,
gdzie będą zgłaszane i omawiane błędy w pakietach, którymi będziemy musieli się zająć. Debian ma
także kilka użytecznych narzędzi, które pomogą nam w tym zadaniu i jednym z nich jest
<a href="https://www.debian.org/Bugs/Reporting">reportbug</a>. Przydaje się ono nie tylko do zgłaszania błędów. Zbiór list mailingowych debiana
można znaleźć <a href="https://lists.debian.org/">tutaj</a>, z kolei <a href="https://www.debian.org/MailingLists/">pod tym linkiem</a> można znaleźć garść użytecznych informacji
na temat tego jak używać samych list.</p>
<p>Skrypt <code>dch</code> jest dość rozbudowany i ma sporo opcji. Jeśli ktoś chciałby w pełni zgłębić możliwości
tego narzędzia, to informacje znajdzie w <a href="http://manpages.ubuntu.com/manpages/wily/en/man1/dch.1.html">manie</a>. Więcej informacji na temat formatu samego
pliku <code>debian/changelog</code> można znaleźć <a href="https://www.debian.org/doc/debian-policy/ch-source.html#s-dpkgchangelog">tutaj</a>.</p>
<h4 id="debiannews">debian/NEWS</h4>
<p>Wszystkie ważne informacje na temat zmian w pakiecie możemy wrzucić również do tego pliku. Podczas
instalacji nowszej wersji takiego pakietu, narzędzie takie jak <code>apt-listchanges</code> wyrzuci monit z
tekstem, który tam umieścimy. Więcej informacji na temat dokładnej zasady działania tego mechanizmu
można znaleźć w <a href="http://manpages.ubuntu.com/manpages/wily/man1/apt-listchanges.1.html">manualu</a>.</p>
<p>Format tego pliku jest podobny do formatu pliku <code>debian/changelog</code> , z tym, że nie zawiera gwiazdek.
Przy pomocy narzędzia <code>dpkg-parsechangelog</code> możemy sprawdzić poprawność tego pliku:</p>
<pre><code>$ dpkg-parsechangelog -ldebian/NEWS
Source: ansifilter
Version: 1.11-1
Distribution: unstable
Urgency: low
Maintainer: Mikhail Morfikov &lt;morfik@nsa.com&gt;
Date: Tue, 03 Feb 2015 09:19:10 +0100
Changes:
 ansifilter (1.11-1) unstable; urgency=low
 .
   Some important news
   Some important news
   Some important news
   Some important news
</code></pre>
<h3 id="debiancopyright">debian/copyright</h3>
<p>Licencja jest chyba jedną z tych rzeczy na jaką debian kładzie największy nacisk. Samych licencji
mamy całe mnóstwo ale cześć z nich jest odrzucana przez politykę debiana i jeśli będziemy pakować
jakąś aplikację na jednej z takich licencji, ten pakiet nigdy nie trafi do głównego repozytorium
debiana.</p>
<p>Licencje akceptowalne przed debiana można odczytać z <code>dh_make</code> przy tworzeniu pakietu:</p>
<pre><code>$ dh_make --help
  -c, --copyright &lt;type&gt;    use &lt;type&gt; of license in copyright file
                            (apache|artistic|bsd|gpl|gpl2|gpl3|lgpl|lgpl2|
                             lgpl3|mit)
</code></pre>
<p>Pliki licencji są zlokalizowane w katalogu <code>/usr/share/common-licenses/</code> i mamy tam do dyspozycji
licencje takie jak Apache-2.0, GPL, LGPL, czy BSD.</p>
<p>Nie musimy całej treści tych plików kopiować do <code>debian/copyright</code> . Możemy jedynie dać nagłówek i
zawrzeć odnośnik do jednego z powyższych plików. Tak jak to robi standardowo <code>dh_make</code> . Są też
licencje, które nie widnieją w powyższym katalogu i równocześnie są akceptowane przez debiana, np.
MIT, i w takim przypadku trzeba podać treść całej licencji w pliku <code>debian/copyright</code> .</p>
<p>Zwykle każdy plik ma w nagłówku u siebie licencje (przynajmniej powinien mieć) ale przeglądanie
dziesiątek czy setek plików w celu ustalenia, który jest na jakiej licencji może być lekko męczące.
Na szczęście mamy do dyspozycji narzędzie <code>licensecheck</code> , które wywołane z opcją <code>-r</code> w głównym
katalogu, zwróci nam listę plików wraz z ich licencją, przykładowo:</p>
<pre><code>$ licensecheck -r *
docs/monitorix-alert.sh: *No copyright* UNKNOWN
docs/htpasswd.pl: *No copyright* UNKNOWN
lib/fail2ban.pm: GPL (v2 or later)
lib/HTTPServer.pm: GPL (v2 or later)
...
</code></pre>
<p>Czasem nie wszystkie pliki zostaną uwzględnione w powyższym listingu, domyślnie będą to te pasujące
do następującego
wzorca:</p>
<pre><code>'\.(c(c|pp|xx)?|h(h|pp|xx)?|f(77|90)?|go|p(l|m)|xs|sh|php|py(|x)|rb|java|js|vala|el|sc(i|e)|cs|pas|inc|dtd|xsl|mod|m|tex|mli?|(c|l)?hs)$'
</code></pre>
<p>Jeśli któryś z plików w naszym pakiecie się nie łapie pod ten wzorzec, możemy ręcznie określić
własny przy pomocy opcji <code>-c</code> .</p>
<p>O te pliki, które nie mają licencji, trzeba będzie się dopytać, chyba, że na stronie projektu jest
informacja, że &quot;pliki są na GPL-2&quot;, wtedy wszystko jest już jasne.</p>
<p>Poniżej przykład pliku <code>debian/copyright</code> wygenerowanego przez dh_make :</p>
<pre><code>Format: http://www.debian.org/doc/packaging-manuals/copyright-format/1.0/
Upstream-Name: monitorix
Source: http://www.monitorix.org

Files: *
Copyright: 2005-2014 Jordi Sanfeliu &lt;jordi@fibranet.cat.&gt;
License: GPL-2.0+

Files: debian/*
Copyright: 2015 Mikhail Morfikov &lt;morfik@nsa.com&gt;
License: GPL-2.0+

License: GPL-2.0+
 This package is free software; you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation; either version 2 of the License, or
 (at your option) any later version.
 .
 This package is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.
 .
 You should have received a copy of the GNU General Public License
 along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;
 .
 On Debian systems, the complete text of the GNU General
 Public License version 2 can be found in &quot;/usr/share/common-licenses/GPL-2&quot;.
</code></pre>
<p>Jeśli chodzi o samą strukturę tego pliku, to w pierwszej linijce mamy <code>Format</code> i zwykle jest taki
jak wyżej. Uzupełniamy <code>Upstream-Name</code> i <code>Source</code> , odpowiednio, nazwę pakietu oraz skąd zostały
pobrane źródła.</p>
<p>Dalej mamy określanie praw do plików. Jeśli wszystkie pliki w źródłach pochodzą od jednej osoby,
wtedy w linijce z <code>Files</code> dajemy <code>*</code> . Jeśli autorów jest więcej i każdy z nich rości sobie prawa do
innego pliku lub plików w danym katalogu, musimy te pliki wypunktować oddzielając je spacją,
przykład:</p>
<pre><code>Files: src/libsodium/crypto_auth/hmacsha256/cp/hmac_hmacsha256.c
 src/libsodium/crypto_auth/hmacsha512256/cp/hmac_hmacsha512256.c
 src/libsodium/crypto_hash/sha256/cp/hash_sha256.c
 src/libsodium/crypto_hash/sha512/cp/hash_sha512.c
 src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.h
 src/libsodium/crypto_pwhash/scryptsalsa208sha256/pbkdf2-sha256.c
Copyright: 2005,2007,2009 Colin Percival
License: BSD-2-clause
</code></pre>
<p>Sekcji z <code>Files</code> może być dowolna ilość, tak by każdy plik miał określoną licencję. Jeśli któryś z
nich zostanie pominięty, <code>lintian</code> będzie miał z tym problem i nam to oświadczy. Z reguły to my
będziemy mieć prawa do plików w katalogu <code>debian/</code> , bo je tworzymy.</p>
<p>W linijce z <code>Copyright</code> podajemy informacje na temat tego kto jest właścicielem praw autorskich do
plików w formie &quot;data nazwisko email&quot; (email nie jest obowiązkowy). Jeśli autorów by było więcej,
wtedy definiujemy ich jeden pod drugim np:</p>
<pre><code>Files: src/libsodium/crypto_pwhash/scryptsalsa208sha256/crypto_scrypt.h
 src/libsodium/crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c
 src/libsodium/crypto_pwhash/scryptsalsa208sha256/sse/pwhash_scryptsalsa208sha256_sse.c
Copyright: 2009 Colin Percival
 2012, 2013 Alexander Peslyak
License: BSD-2-clause
</code></pre>
<p>Ostatnia rzecz, o której trzeba wspomnieć to <code>License</code> i bynajmniej nie chodzi tutaj o rodzaj
licencji tylko o sposób jej definiowania. Generalnie można to robić na dwa sposoby. Jeden z nich
zakłada dołączania pod linijką z <code>License</code> treści licencji ale to troszeczkę psuje całą estetykę i
lepiej jest tego nie robić. Alternatywne rozwiązanie zakłada zdefiniowanie poszczególnych bloków
plików jeden pod drugim i dopiero na końcu podanie treść licencji, przykładowo:</p>
<pre><code>Files: *
Copyright: © 2015 William Jon McCann
           © 2015 Peter de Ridder
           © 2015 Simon Steinbeiß
License: GPL-2

Files: debian/*
Copyright: © 2013 Yves-Alexis Perez
License: GPL-2
...
Files: data/*.1
Copyright: 2007 Sven Arvidsson
  2014 Peter de Ridder
License: GPL-2+

License: GPL-2
 On Debian systems, the complete text of the GNU General Public License version
 2 can be found in '/usr/share/common-licenses/GPL-2'.

License: GPL-2+
 On Debian systems, the complete text of the GNU General Public License can be
 found in '/usr/share/common-licenses/GPL-2'.
</code></pre>
<p>Formatowanie pliku odbywa się dokładnie na takich samych zasadach co w przypadku pliku
<code>debian/control</code> , czyli paragrafy (np. w licencjach) są oddzielone kropkami, a nowe linie są wcięte
minimum o jedną spację.</p>
<h3 id="debianwatch-i-debianupstreamsigning-keyasc">debian/watch i debian/upstream/signing-key.asc</h3>
<p>W oparciu o te pliki, narzędzie <code>uscan</code> potrafi zweryfikować czy pojawiła się nowsza wersja jakiejś
aplikacji. Plik <code>debian/watch</code> będzie wyglądał mniej więcej tak:</p>
<pre><code>version=3
opts=filenamemangle=s/.+\/v?(\d\S*)\.tar\.gz/Monitorix-$1\.tar\.gz/ \
  https://github.com/mikaku/Monitorix/tags .*/v?(\d\S*)\.tar\.gz
</code></pre>
<p>Linijka z <code>version</code> obecnie przyjmuje wartość <code>3</code> . Natomiast kolejna linijka jest nieco
skomplikowana. Mamy tam wyrażenia regularne perl'a. Nie będziemy zajmować się tutaj samymi
wyrażeniami i skupimy się na wzorcach, które jedynie będziemy dostosowywać. Więcej informacji o
samych wyrażeniach regularnych można znaleźć <a href="http://perldoc.perl.org/perlre.html">tutaj</a>.</p>
<p>Większość projektów jest hostowana na GitHub czy sourceforge i w ich przypadku możemy skorzystać z
czyjejś pracy, czyli skopiować sobie tę powyższą linijkę i odpowiednio dostosować. Powyżej mamy
przykład projektu hostowanego na GitHub i raczej przerobienie linku nie powinno przysporzyć
problemów.</p>
<p>Wszystkie inne większe strony z projektami opensource mają swoje regułki zebrane <a href="https://wiki.debian.org/debian/watch/">pod tym
linkiem</a>. Jeśli tam nie znajdziemy strony, z której pobraliśmy źródła, będziemy musieli sami
naskrobać odpowiednią regułkę. Wprawdzie nie jest to obowiązkowe ale znacząco ułatwia późniejsze
aktualizowanie źródeł, bo wystarczy, że w katalogu ze źródłami wydamy polecenie <code>uscan</code> i ten już
sprawdzi czy pojawiła się nowsza wersja w upstream'ie. Jeśli tak, pobierze ją i automatycznie
dostosuje nazwy plików, co przyśpieszy migrację pakietu do nowszej wersji.</p>
<p>Po uzupełnieniu pliku, aktualizację przeprowadzamy w poniższy sposób:</p>
<pre><code>$ uscan --verbose
-- Scanning for watchfiles in .
-- Found watchfile in ./debian
-- In debian/watch, processing watchfile line:
   opts=filenamemangle=s/.+\/v?(\d\S*)\.tar\.gz/Monitorix-$1\.tar\.gz/   https://github.com/mikaku/Monitorix/tags .*/v?(\d\S*)\.tar\.gz
-- Found the following matching hrefs:
     /mikaku/Monitorix/archive/v3.6.0.tar.gz (3.6.0)
     /mikaku/Monitorix/archive/v3.5.1.tar.gz (3.5.1)
     /mikaku/Monitorix/archive/v3.5.0.tar.gz (3.5.0)
Newest version on remote site is 3.6.0, local version is 3.6.0
 =&gt; Package is up to date
-- Scan finished
</code></pre>
<p>Jak widzimy wyżej, plik <code>debian/watch</code> został odnaleziony i przetworzony, zwracając 3 pliki o
różnych wersjach. Jako, że posiadam najnowszą wersję źródeł, żadna akcja mająca na celu dokonanie
aktualizacji nie została podjęta.</p>
<h4 id="podpisy-cyfrowe-źródeł">Podpisy cyfrowe źródeł</h4>
<p>Trzeba jeszcze wspomnieć o jeden ważnej rzeczy, mianowicie o podpisach cyfrowych. Jeśli budujemy
projekt, który ma podpisane źródła, koniecznie musimy weryfikować ich podpis, z tym, że będziemy
potrzebować klucza publicznego osoby składającej sygnaturę. Poniżej jest przedstawiony proces
pozyskiwania klucza publicznego.</p>
<p>Na sam początek odwiedzamy stronę projektu i patrzymy co za pliki są do pobrania. W tym przypadku
mamy min. <code>dnscrypt-proxy-1.4.3.tar.gz</code> oraz <code>dnscrypt-proxy-1.4.3.tar.gz.sig</code> . Pobieramy oba pliki
i przechodzimy do katalogu gdzie zostały pobrane. Próbujemy póki co ręcznie zweryfikować podpis:</p>
<pre><code>$ gpg --verify dnscrypt-proxy-1.4.3.tar.gz.sig
gpg: assuming signed data in 'dnscrypt-proxy-1.4.3.tar.gz'
gpg: Signature made Tue 10 Feb 2015 12:00:24 PM CET
gpg:                using RSA key 0x62F25B592B6F76DA
gpg: Can't check signature: public key not found
</code></pre>
<p>Jak widzimy, nie można zweryfikować sygnatury, bo nie posiadamy klucza publicznego. Szukamy go zatem
i importujemy:</p>
<pre><code>$ gpg --search-keys 0x62F25B592B6F76DA
</code></pre>
<p>Klucz został zaimportowany do naszego lokalnego keyring'a. Jeśli teraz byśmy spróbowali sprawdzić
sygnaturę, podpis powinien zostać zweryfikowany. Musimy teraz wydobyć ten klucz z keyring'a i
zapisać go do pliku w formacie ascii:</p>
<pre><code>$ mkdir debian/upstream/

$ gpg --armor --export 0x62F25B592B6F76DA &gt; debian/upstream/signing-key.asc
</code></pre>
<p>Zatem klucz publiczny jest już na swoim miejscu. Musimy jeszcze nieco dostosować linijkę w pliku
<code>debian/watch</code> , tak by <code>uscan</code> automatycznie weryfikował podpis bez naszej ingerencji:</p>
<pre><code>version=3
opts=pgpsigurlmangle=s/$/.sig/ \
  http://download.dnscrypt.org/dnscrypt-proxy/dnscrypt-proxy-([0-9].+).tar.gz
</code></pre>
<p>Od tej pory, gdy się pojawi nowsza wersja pakietu, zostanie ona pobrana po wywołaniu polecenia
<code>uscan</code> , natomiast sygnatura zostanie zweryfikowana automatycznie.</p>
<h3 id="debianmanpage-i-debianmanpages-dh_installman">debian/manpage.* i debian/*.manpages (dh_installman)</h3>
<p>Dokumentacja projektu to bardzo ważna rzecz i bez niej ani rusz. To właśnie na jej podstawie wiemy
jakie zadania ma realizować dany program. Zwykle jest nieco bardziej obszerna niż parametr <code>--help</code>
doczepiony do wywołanego programu. Jeśli dany projekt się szanuje, powinien wypuścić przyzwoitą
dokumentację i dołączyć ją paczki ze źródłami. Nie zawsze jednak taki manual ma odpowiednią formę.
<a href="http://liw.fi/manpages/">Pod tym linkiem</a> znajduje się krótki tutorial na temat składni stosowanej w plikach manuala
wykorzystywanych w debianie. Będziemy musieli się tego nauczyć, w przeciwnym wypadku, może się
zdarzyć tak, że nasze paczki zostaną bez dokumentacji, a to niedobrze.</p>
<p>Z grubsza będziemy mieli styczność z trzema rodzajami przypadków. W pierwszym z nich nie będzie
żadnej dokumentacji. W drugim będzie dokumentacja ale trzeba będzie ją przeformatować. Zaś w
trzecim będziemy musieli poprawić błędy w formatowaniu, które wypunktuje nam <code>lintian</code> . Pomijam
oczywiście ten rzadki przypadek, w którym wszystko będzie jak trza i nie będziemy musieli nic robić.</p>
<p>Manuale tyczą się głównie plików wykonywalnych i według polityki debiana, każdy taki plik musi mieć
manual, nawet jeśli jest to jakaś aplikacja GUI z dwoma przyciskami na krzyż, z których jeden to OK,
a drugi to ANULUJ. Nazwy plików manuali mają również swój format np. <code>napi.1</code> . Numerki są od 1-9 ,
w zależności od tego o czym jest konkretna strona manuala. Najczęściej jednak będziemy się spotykać
z numerkami <code>1</code> (info o opcjach, które program może przyjąć) i <code>5</code> (pliki konfiguracyjne). Jeśli
kogoś interesują pozostałe numerki, może o nich poczytać w <code>man man</code> .</p>
<p>Bardzo rzadko będziemy tworzyć plik manuala od podstaw. Jeśli się jednak na to zdecydujemy, to
istnieją graficzne narzędzia, które mogą nam ułatwić to zadanie. Jednym z nich jest <code>gmanedit</code> . W
pozostałych przypadkach będziemy szli na skróty. Samo poprawianie poszczególnych linijek w pliku nie
powinno sprawić problemów, zwłaszcza jeśli się opanuje składnię pliku manuala. Możemy także
korzystać z polecenia <code>man -l plik-mana.1</code> aby podejrzeć jak wyglądać będzie ten manual w systemie.</p>
<h4 id="automatyczne-generowanie-manuali">Automatyczne generowanie manuali</h4>
<p>Watro też wspomnieć iż istnieje możliwość wygenerowania pliku manuala w oparciu o polecenie
<code>--help</code> , z tym, że nie zawsze wszystkie aplikacje posiadają w swoim wyposażeniu ten parametr.
Poza tym, jeśli chodzi o aplikacje GUI, muszą one mieć dostęp do sesji graficznej, by taki manual
wygenerować. I takim automatycznym generowaniem plików manuali zajmuje się <code>help2man</code> . Można go
wywołać bezpośrednio przy budowaniu paczki, z tym, że to pociąga za sobą dodatkowe zależności oraz
kilka linijek w pliku <code>debian/rules</code> , a konkretnie trzeba będzie nadpisać target <code>dh_installman</code>
oraz uwzględnić ten nowy plik przy czyszczeniu w targecie <code>dh_clean</code>. Poniżej przykład:</p>
<pre><code>override_dh_installman:
    help2man -N --no-discard-stderr --version-string='0.3.3' -n 'feature-rich screen recorder that supports X11 and OpenGL' debian/simplescreenrecorder/usr/bin/simplescreenrecorder &gt; simplescreenrecorder.1
    help2man -N --no-discard-stderr --version-string='0.3.3' -n 'inject the GLInject library into a given command' debian/simplescreenrecorder/usr/bin/ssr-glinject &gt; ssr-glinject.1
    dh_installman simplescreenrecorder.1 ssr-glinject.1

override_dh_clean:
    dh_clean -- simplescreenrecorder.1 ssr-glinject.1
</code></pre>
<p>Możemy także wygenerować plik manuala po zbudowaniu paczki i wrzucić go później do katalogu
<code>debian/</code> .</p>
<p>Jeśli zdecydujemy się na to drugie wyjście, to manual generujemy w poniższy sposób:</p>
<pre><code>$ which napi
/usr/bin/napi

$ help2man /usr/sbin/napi &gt; napi.1
</code></pre>
<p>Tak wygenerowany plik dobrze jest przejrzeć i poprawić ewentualne błędy.</p>
<p>Mając już pliki manuali, musimy uwzględnić je w <code>debian/*.manpages</code> , gdzie gwiazdka zwykle
odpowiada nazwie pakietu, do którego ten manual ma trafić. Generalnie chodzi o to, że w przypadku,
gdy budujemy większy projekt, który ma kilka paczek, to raczej chcielibyśmy aby manual od jednego
pliku trafił do konkretnej paczki, podobnie z pozostałymi. Poniżej przykład pliku <code>napi.manpages</code> :</p>
<pre><code>debian/napi.1
debian/subotage.1
</code></pre>
<p>Format tego pliku jest prosty. Każda linijka to jeden plik manuala i określamy w niej położenie
samego pliku w katalogu ze źródłami. Jako, że stworzyliśmy dopiero co nowe pliki manuala, to
umieściliśmy je w podkatalogu <code>debian/</code> . Nie używamy tutaj początkowego <code>/</code> , bo ścieżki są
względne.</p>
<p>Istnieje także możliwość zmiany położenia i wtedy po spacji dodajemy kolejną ścieżkę, która określa
lokalizację pliku w wynikowej paczce i też nie używamy początkowego <code>/</code> , przykładowo:</p>
<pre><code>debian/napi.1 usr/share/man/man1/
</code></pre>
<p>Z reguły nie ma takiej potrzeby i wystarczy określić tylko pierwszą ścieżkę, druga zostanie dobrana
automatycznie na podstawie numerka.</p>
<h3 id="debiandocs-dh_installdocs">debian/*.docs (dh_installdocs)</h3>
<p>Ten plik będzie zawierał ścieżki do plików, które niosą ze sobą jakąś przydatną z punktu widzenia
projektu informację ale nie są to manuale. Zwykle ich nazwy będą pisane dużymi lietrami, np.
<code>README</code> . Ze wszystkich takich plików robimy listę. Trzeba tylko się pilnować, by nie umieszczać
śmieci, np. nie potrzebujemy pliku <code>INSTALL</code>, czy plików związanych z innymi dystrybucjami linux'a.
Pakujemy tu tylko co się tyczy debiana. Poniżej przykład pliku:</p>
<pre><code>AUTHORS
BUGS
COLABORATION
README.md
</code></pre>
<p>Z reguły system powinien wykryć cześć plików ale dobrze jest przejrzeć główny katalog źródeł i
posprawdzać czy coś nie zostało pominięte.</p>
<h3 id="pliki-demonów-dh_installinit">Pliki demonów (dh_installinit)</h3>
<p>Nie będę tutaj przytaczał żadnych skryptów -- chodzi o skrypty sysvinit, unity systemd i podobne
pliki związane z odpalaniem usług systemowych, bo to jest poza zakresem tego poradnika. Niemniej
jednak, zostanie załączony link do dokumentacji poszczególnych plików, tak by mieć jakiś punkt
zaczepienia.</p>
<h4 id="debianinit">debian/*.init</h4>
<p>Niby <code>debhelper</code> tworzy plik <code>*.init.d</code> ale wszędzie w paczkach spotkałem się tylko z samym
<code>*.init</code> . W każdym razie, nie ma to większego znaczenia, z której nazwy skorzystamy. Oba pliki
odpowiadają za instalowanie skryptów startowych sysvinit, tych w katalogu <code>/etc/init.d/</code> . By
sprawnie tworzyć takie skrypty, trzeba zrozumieć sam nagłówek <a href="https://wiki.debian.org/LSBInitScripts">LSB</a> oraz ogarnąć narzędzie
<a href="http://manpages.ubuntu.com/manpages/wily/man8/start-stop-daemon.8.html">start-stop-daemon</a>. Dodatkowo trzeba również opanować obsługę <code>sh</code> ( <code>dash</code> ), tak by
<a href="http://mywiki.wooledge.org/Bashism">uniknąć</a> <a href="https://wiki.ubuntu.com/DashAsBinSh">bashismów</a>.</p>
<p>Skrypty init dobrze jest także potraktować poleceniem <code>sh -n</code> , które zwróci ewentualne problemy ze
składnią, przykładowo:</p>
<pre><code>$ sh -n dnscrypt-proxy
</code></pre>
<p>Jeśli jakieś błędy się pojawią, trzeba będzie je poprawić.</p>
<h4 id="debiandefault">debian/*default</h4>
<p>Plik <code>*.default</code> odpowiada za konfigurację skryptu init trzymaną w katalogu <code>/etc/default/</code>.
Generalnie chodzi o możliwość zachowania części z ustawionych opcji, które zwykle powinny być stałe
i nie ulegać resetowaniu podczas aktualizacji pakietu. Sam skrypt init może ulec zmianie ale w
stopniu, w którym nie powinien ingerować w opcje określone tutaj w tym pliku, przynajmniej taka jest
teoria.</p>
<p>Ten plik zawiera jedynie szereg zmiennych i trochę komentarzy, a do tego raczej nie potrzebujemy
manuala.</p>
<h4 id="debianservice-dh_systemd_enable-dh_systemd_start">debian/*service (dh_systemd_enable, dh_systemd_start)</h4>
<p>W tym pliku jest trzymana konfiguracja unitów dla systemd. By z nich skorzystać musimy w pliku
<code>debian/rules</code> uwzględnić moduł <code>dh_systemd</code> . Dokładne informacje na temat opcji, które możemy użyć
w plikach unitów, możemy znaleźć w dokumentacji systemd dostępnej <a href="https://www.freedesktop.org/software/systemd/man/systemd.index.html">tutaj</a>. Jest tego dość sporo
i dla ułatwienia podpowiem tylko, że interesować nas będą głównie strony od <a href="https://www.freedesktop.org/software/systemd/man/systemd.service.html">systemd.service</a>
oraz <a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html">systemd.unit</a>.</p>
<h4 id="debiantmpfile">debian/*tmpfile</h4>
<p>W tym pliku jest trzymana konfiguracja plików tymczasowych, które są niezbędne do działania danego
programu. Wszystkie pliki i katalogi określone tutaj będą tworzone i konfigurowane automatycznie na
starcie systemu. Dokładne informacje na temat formatu samego pliku można znaleźć <a href="https://www.freedesktop.org/software/systemd/man/tmpfiles.d.html">tutaj</a>.</p>
<h3 id="debiansymbols">debian/*.symbols</h3>
<p>Z tym plikiem spotkamy się jedynie przy budowaniu bibliotek, co nie jest prostym zadaniem.
Zakładając, że udało nam się zbudować bibliotekę, będziemy musieli wygenerować dla niej plik
<code>*.symbols</code> , a tego możemy dokonać jedynie mając do dyspozycji paczkę wynikową. Także zbudowanie
biblioteki wymaga przepakowania jej co najmniej jeden dodatkowy raz.</p>
<p>Do generowania symboli posłuży nam narzędzie <code>dpkg-gensymbols</code> , zaś do wypakowania paczki
<code>dpkg-deb</code> . Sam proces przebiega mniej więcej w poniższy sposób:</p>
<pre><code>$ dpkg-deb -x /media/Kabi/pbuilder/result/libssr-glinject_0.3.3-1_amd64.deb /tmp/libssr-glinject
$ dpkg-gensymbols -v0.3.3 -plibssr-glinject -P/tmp/libssr-glinject -Olibssr-glinject.symbols
$ sed -i s/0\.3\.3$/0\.3\.3\~/g libssr-glinject.symbols
</code></pre>
<p>Pierwsza linijka wypakowuje paczkę z biblioteką, druga generuje symbole, a trzecia dopisuje do
wersji znaczek <code>~</code> , o który domagał się <code>lintian</code> . Tak stworzony plik przenosimy do katalogu
<code>debian/</code> i budujemy paczkę jeszcze raz.</p>
<p>Czasem też się zdarzy tak, że nazwa, którą nadaliśmy paczce z biblioteką, jest niewłaściwa. Jak
zatem ustalić odpowiednią nazwę? Do tego celu posłuży nam narzędzie <code>readelf</code> , poniżej przykład:</p>
<pre><code>$ readelf -d  /usr/lib/x86_64-linux-gnu/libssr-glinject.so | grep SONAME
 0x000000000000000e (SONAME)             Library soname: [libssr-glinject.so]
</code></pre>
<p>I już wiemy, że paczka ma się nazywać <code>libssr-glinject</code> . Więcej informacji na temat symboli można
znaleźć <a href="https://www.debian.org/doc/manuals/maint-guide/advanced.en.html#librarysymbols">tutaj</a> i <a href="https://www.debian.org/doc/debian-policy/ch-sharedlibs.html#s-sharedlibs-symbols">tutaj</a>.</p>
<h3 id="debiandirs-dh_installdirs">debian/*.dirs (dh_installdirs)</h3>
<p>Jeśli do zbudowania pakietu potrzebne nam są dodatkowe katalogi, które standardowo nie są tworzone,
oznaczać to może najprawdopodobniej błąd w pliku <code>makefile</code> . Możemy te katalogi wpisać do tego
pliku i poprawić tym samym ten błąd. Jeśli dodajemy pliki do <code>debian/*.install</code> , to nie musimy
tutaj uwzględniać tych katalogów.</p>
<h3 id="debianinstall-dh_install">debian/*.install (dh_install)</h3>
<p>Jeśli z jakiegoś powodu pewne pliki nie są brane pod uwagę przez <code>makefile</code> i zwyczajnie nie zostaną
utworzone w paczce wynikowej, musimy je tutaj określić.</p>
<p>Ten plik będziemy także wykorzystywać do rozdzielania plików na mniejsze paczki ale tutaj taka mała
uwaga. Pierw musimy zbudować pakiet bez jakiegokolwiek rozdzielania na mniejsze i zobaczyć jakie
pliki uzyskamy w paczce wynikowej. Jeśli na samym początku zaczniemy bawić wpisami w <code>*.install</code> ,
jest wysokie prawdopodobieństwo, że pogubimy część potrzebnych plików, bo nie zostaną one w tych
plikach <code>*.install</code> uwzględnione.</p>
<p>Jeśli z jednego źródła chcemy zbudować dwie paczki, potrzebne będą nam dwa pliki <code>.install</code> . Każdy
z nich będzie miał nazwę wynikowego pakietu. Poniżej jest przykład budowania pakietu
<code>simplescreenrecorder</code> i biblioteki <code>libssr-glinject</code> . Oba są budowane z tych samych źródeł. By
odseparować pewne pliki od siebie i upchnąć je w osobnych paczkach, tworzymy poniższe pliki:</p>
<p>Plik debian/simplescreenrecorder.install :</p>
<pre><code>usr/share/
usr/bin/
</code></pre>
<p>Plik debian/libssr-glinject.install :</p>
<pre><code>usr/lib/*/libssr-glinject.so
</code></pre>
<p>W powyższym przykładzie jest podana tylko jedna ścieżka. Druga może być podana po spacji. Pierwsza z
nich określa skąd kopiować plik, druga gdzie go wrzucić (w drzewie katalogu pakietu). Jeśli nie
podamy tej drugiej ścieżki, zostanie przyjęta domyślnie i będzie taka sama jak pierwsza. Co do
samych plików, to możemy precyzować każdy z osobna uwzględniając przy tym nazwę pliku w pierwszej
ścieżce albo też możemy podawać ścieżki do całych katalogów, tak jak to widać wyżej. Trzeba
pamiętać o tym, że przy pomocy <code>*.install</code> nie damy rady przepisać nazwy pliku, a druga ścieżka
zawsze ma postać katalogu.</p>
<p>Jeśli chodzi o same biblioteki, to przy instalowaniu plików trzeba uważać, bo w systemie są różne
ścieżki w zależności od jego architektury. Zamiast podawać dokładną ścieżkę, można użyć wildcard'a,
tak by dopasować pewną jej części i sprawić tym samym, że pakiet zbuduje się na innej architekturze
niż był pierwotnie budowany. Zwykle będzie to wyglądać tak: <code>usr/lib/*/</code> , kluczowa jest tutaj ta
gwiazdka w trzecim członie i to ona upchnie plik biblioteki w odpowiednim folderze (normalnie byśmy
tam podali np. x86_64-linux-gnu).</p>
<p>Po rozdzieleniu paczek, trzeba będzie także odpowiednio uzupełnić plik <code>debian/control</code> tak by dodać
opisy i zależności, przykładowo:</p>
<pre><code>...
Package: simplescreenrecorder
Architecture: i386 amd64
Pre-Depends: ${misc:Pre-Depends}
Depends: ${shlibs:Depends}, ${misc:Depends}
Recommends: libssr-glinject
Description: Feature-rich screen recorder (main program)
 SimpleScreenRecorder is a feature-rich screen recorder that supports X11 and
 OpenGL. It has a Qt-based graphical user interface. It can record the entire
 creen or part of it, or record OpenGL applications directly. The recording
 can be paused and resumed at any time. Many different file formats and
 codecs are supported
 .
 This package contains the main program.

Package: libssr-glinject
Architecture: i386 amd64
Multi-Arch: same
Pre-Depends: ${misc:Pre-Depends}
Depends: ${shlibs:Depends}, ${misc:Depends}, simplescreenrecorder
Description: Feature-rich screen recorder (GLInject library)
 SimpleScreenRecorder is a feature-rich screen recorder that supports X11 and
 OpenGL. It has a Qt-based graphical user interface. It can record the entire
 screen or part of it, or record OpenGL applications directly. The recording
 can be paused and resumed at any time. Many different file formats and
 codecs are supported
 .
 This package contains the GLInject library.
</code></pre>
<h3 id="debiancompat">debian/compat</h3>
<p>Ten plik określa poziom kompatybilności debhelper'a i obecnie ma zawierać cyfrę <code>9</code> . Za co
odpowiada ten poziom kompatybilności, to chyba nikt nie wie</p>
<h3 id="debianlinks-dh_link">debian/*.links (dh_link)</h3>
<p>Ten plik ma na celu tworzenie linków do plików, których nie chcemy bezpośrednio kopiować, bo, jakby
nie patrzeć, to zajmuje cenne zasoby dyskowe, poza tym mniej danych trzeba przesłać przez sieć.
Poniżej jest przykład takiego linku:</p>
<pre><code>usr/share/man/man1/ansifilter.1.gz usr/share/man/man1/ansifilter-gui.1.gz
</code></pre>
<p>Ta linijka stworzy link <code>ansifilter-gui.1.gz</code> do pliku <code>/usr/share/man/man1/ansifilter.1.gz</code> w
wynikowym pakiecie.</p>
<h3 id="debianlintian-overrides-i-debiansourcelintian-overrides">debian/*.lintian-overrides i debian/source/lintian-overrides</h3>
<p>Te dwa pliki są wykorzystywane przez narzędzie <code>lintian</code> , które po przeskanowaniu paczek/źródeł
wyrzuca komunikaty w przypadku, gdy coś odbiega od ustalonego standardu. Niemniej jednak, czasem się
zdarza tak, że <code>lintian</code> będzie miał buga, albo też jego błąd tak naprawdę nie będzie żadnym błędem
i będzie można cały komunikat zakwalifikować jako false-positive.</p>
<p>W obu przypadkach mamy możliwość ukrycia tych komunikatów, tak by nas już więcej nie niepokoiły.
Jeśli problem dotyczy źródeł, będziemy wykorzystywać plik <code>debian/source/lintian-overrides</code> .
Natomiast jeśli <code>lintian</code> ma problem z jakąś paczką wynikową, wtedy trzeba będzie stworzyć osobny
plik z nazwą paczki i sufiksem <code>.lintian-overrides</code> .</p>
<p>Źródła powinny zostać zweryfikowane, a to zwykle odbywa się przez sprawdzenie sygnatury GPG. Nie
każdy serwis daje nam taką możliwość i nie mamy tak naprawdę żadnego pola manewru w sytuacji, gdy
twórca źródeł nie podpisał swojego dzieła cyfrowo. Jeśli napotkamy podobny problem, to jako że
komunikat dotyczy źródeł pakietu, wrzucamy poniższą linijkę do pliku
<code>debian/source/lintian-overrides</code> :</p>
<pre><code>light-locker source: debian-watch-may-check-gpg-signature
</code></pre>
<p>Spora część komunikatów będzie jednak dotyczyć paczek wynikowych. Poniżej jest przykład ukrycia
błędu w paczce <code>libssr-glinject</code> . W katalogu <code>debian/</code> tworzymy plik
<code>libssr-glinject.lintian-overrides</code> i wrzucamy do niego np. coś takiego:</p>
<pre><code>libssr-glinject: shlib-without-versioned-soname usr/lib/*/libssr-glinject.so libssr-glinject.so
libssr-glinject: pkg-has-shlibs-control-file-but-no-actual-shared-libs
</code></pre>
<p>By stworzyć takie pliki musimy znać komunikat błędu, nazwę paczki oraz nazwę pliku, którego błąd
dotyczy. Wszystkie te informacje wypisze nam <code>lintian</code> po przeskanowaniu paczek. Poniżej jest
przykład:</p>
<pre><code>W: libssr-glinject: shlib-without-versioned-soname usr/lib/x86_64-linux-gnu/libssr-glinject.so libssr-glinject.so
E: libssr-glinject: pkg-has-shlibs-control-file-but-no-actual-shared-libs
</code></pre>
<p>Jak widać, praktycznie niczym się te linijki z błędami nie różnią od tego co wpisaliśmy wyżej w
pliku, no za wyjątkiem początkowych <code>W:</code> i <code>E:</code> . Struktura obu powyższych plików jest taka sama i
dokładnie opisana jest <a href="https://lintian.debian.org/manual/section-2.4.html">tutaj</a>.</p>
<h3 id="sourceformat">source/format</h3>
<p>Ten plik określa format źródeł pakietu i z reguły wpisujemy w nim <code>3.0 (native)</code> dla natywnych
debianowych pakietów, oraz <code>3.0 (quilt)</code> dla wszystkiego innego i zwykle będziemy budować właśnie
ten drugi rodzaj, gdzie wszystkie zmiany dokonywane przez nas na źródłach będą rejestrowane i
zapisywane w plikach w katalogu <code>debian/patches/</code> (o nim później). Takie zmiany po wypakowaniu
źródeł będą automatycznie nakładane przez <code>dpkg-source</code> .</p>
<h3 id="sourcelocal-options-i-sourceoptions">source/local-options i source/options</h3>
<p>W tych plikach możemy zdefiniować opcje dla narzędzia <code>dpkg-source</code> wywoływanego z parametrami <code>-b</code>
lub <code>--print-format</code> . Użyteczne mogą się okazać <code>--compression</code> czy <code>--compression-level</code> , z tym,
że dodajemy je do pliku bez tych dwóch myślników na początku, przykładowo:</p>
<pre><code>compression = &quot;bzip2&quot;
compression-level = 9
</code></pre>
<p>Jedyną różnicą między tymi dwoma plikami jest to, że <code>source/local-options</code> nie będzie dołączany w
zbudowanych źródłach. Wszystkie dostępne opcje dla <code>dpkg-source</code> są przystępnie opisane w
<a href="http://manpages.ubuntu.com/manpages/wily/en/man1/dpkg-source.1.html">manualu</a>.</p>
<h3 id="debianpatches-i-debianpatchesseries">debian/patches/ i debian/patches/series</h3>
<p>Jako, że nie możemy bezpośrednio zmieniać upstream'owych źródeł, musimy robić łatki, by przy ich
pomocy nanieść pożądane zmiany. Jeśli zmienimy pewnie pliki w źródłach, po czym spróbujemy zbudować
taki pakiet, zostanie nam wypisany poniższy komunikat:</p>
<pre><code>...
dpkg-source -b monitorix-3.6.0
dpkg-source: info: using source format '3.0 (quilt)'
dpkg-source: info: building monitorix using existing ./monitorix_3.6.0.orig.tar.gz
dpkg-source: info: local changes detected, the modified files are:
 monitorix-3.6.0/monitorix
dpkg-source: error: aborting due to unexpected upstream changes, see /tmp/monitorix_3.6.0-1.diff.6zxg54
dpkg-source: info: you can integrate the local changes with dpkg-source --commit
dpkg-buildpackage: error: dpkg-source -b monitorix-3.6.0 gave error exit status 2
debuild: fatal error at line 1376:
dpkg-buildpackage -rfakeroot -d -us -uc -S -sa failed
</code></pre>
<p>By zbudować taki pakiet musimy stworzyć łatę przy pomocy <code>dpkg-source --commit</code> .</p>
<p>Jest też jeszcze inne narzędzie, które ułatwia zarządzanie uprzednio stworzonymi patch'ami i jest to
<code>quilt</code> . Pomoże nam on nie tylko w zakładaniu/ściąganiu łat ale również w ich edycji.</p>
<p>Musimy wiedzieć jak działa <code>quilt</code> , by sprawnie operować na łatach. Przede wszystkim, mamy do
dyspozycji plik <code>debian/patches/series</code> i to w nim są zawarte informacje na temat tego jakie patch'e
i w jakiej kolejności mają być założone na źródła. Poniżej przykładowy plik:</p>
<pre><code>disable-update-check
#proper-tempfiles
assure-quit-keybinding
fix_desktop_file.patch
</code></pre>
<p>W katalogu <code>debian/patches/</code> mamy zaś:</p>
<pre><code>morfik:~/debian_build/minitube-2.3.1$ ls -al debian/patches/
total 28K
drwxr-xr-x 2 morfik morfik 4.0K 2015-02-12 20:13:12 ./
drwxr-xr-x 4 morfik morfik 4.0K 2015-02-15 04:55:45 ../
-rw-r--r-- 1 morfik morfik  968 2014-09-05 23:02:33 assure-quit-keybinding
-rw-r--r-- 1 morfik morfik  427 2014-09-05 23:02:33 disable-update-check
-rw-r--r-- 1 morfik morfik  396 2015-02-12 20:13:12 fix_desktop_file.patch
-rw-r--r-- 1 morfik morfik 2.5K 2014-09-05 23:02:33 proper-tempfiles
-rw-r--r-- 1 morfik morfik   85 2015-02-12 19:34:19 series
</code></pre>
<p>Patch'e są zakładane w kolejności od góry do dołu z perspektywy pliku <code>debian/patches/series</code> .
Zatem pierw zostanie założony patch <code>disable-update-check</code> , potem by został założony
<code>proper-tempfiles</code> ale, że jest wykomentowany, to zostanie pominięty, następnie jest zakładany
<code>assure-quit-keybinding</code> i tak dalej, aż do końca pliku.</p>
<p>By założyć kolejny patch, korzystamy z <code>quilt push</code>, by ściągnąć obecny patch, dajemy <code>quilt pop</code> .
Parametr <code>-a</code> dopisany do obu z powyższych poleceń, odpowiednio założy i ściągnie wszystkie łaty.
Jeśli przez przypadek usunęliśmy pliki z patch'ami ale przy tym uprzednio ich nie ściągnęliśmy,
będziemy musieli posłużyć się opcją <code>-f</code> . By sprawdzić, jaki patch jest aktualnie założony,
wydajemy <code>quilt applied</code> . Możemy także przeprowadzać różne operacje na samych łatach, np. zmieniać
ich nazwy. Dobrze jest rzucić okiem na <a href="http://manpages.ubuntu.com/manpages/wily/man1/quilt.1.html">manual quilt'a</a>, gdzie znajdziemy opis wszystkich
przydatnych funkcji. Można również zajrzeć pod <a href="https://raphaelhertzog.com/2012/08/08/how-to-use-quilt-to-manage-patches-in-debian-packages/">ten adres</a>, gdzie znajdziemy opis praktycznego
zastosowania tego narzędzia.</p>
<h4 id="nagłówek-łaty">Nagłówek łaty</h4>
<p>Z bardziej przydatnych rzeczy musimy jeszcze wiedzieć co nieco o edycji nagłówków plików łat. Każdy
patch musi bowiem spełniać <a href="http://dep.debian.net/deps/dep3/">standard DEP-3</a>, który definiuje szereg pół wykorzystywanych w
nagłówkach. Nagłówek wygenerowany przez <code>dpkg-source --commit</code> jest dość rozbudowany. Jeśli nie
chce nam się wypełniać wszystkich linijek albo zwyczajnie nie jesteśmy w posiadaniu informacji,
które moglibyśmy tam umieścić, to możemy ograniczyć się do dwóch obowiązkowych pól, czyli
<code>Description:</code> oraz <code>Author</code> (opis i autor). Resztę natomiast można bez problemu skasować.</p>
<p>Spotkamy się także z sytuacjami, gdzie ktoś stworzy lub podeśle patch ale nie poda w nim żadnego
nagłówka lub informacje w nim będą błędne. Być może nawet sami zapomnimy zmienić powyższy nagłówek,
lub zwyczajnie go przeoczymy i nie uwzględnimy w łacie. W takich przypadkach możemy oczywiście
dokonać edycji nagłówka, z tym, że dobrze jest to zrobić via <code>quilt header --dep3 -e</code> . Spowoduje to
utworzenie domyślnego nagłówka, co ułatwi nam nieco robotę.</p>
<h3 id="debianexamples-dh_installexamples">debian/*.examples (dh_installexamples)</h3>
<p>Pozycje w tym pliku będą instalowane pod <code>/usr/share/docs/nazwa_paczki/examples/</code> i generalnie
będziemy tutaj umieszczać pliki zawierające przykłady, np. konfiguracji.</p>
<h3 id="debiantemplates">debian/*.templates</h3>
<p>Ten plik jest używany do interakcji z użytkownikiem przy instalacji pakietu i odbywa się to przez
zadawanie pytań, na które trzeba udzielić odpowiedzi i w oparciu o nie można skonfigurować pakiet.
Generalnie rzecz biorąc nie spotkałem się z tym plikiem i za bardzo nic na jego temat nie napiszę.
Za to, <a href="https://www.leaseweb.com/labs/2013/06/creating-custom-debian-packages/">pod tym linkiem</a> jest przykład jego wykorzystania.</p>
<h3 id="debianconffiles-dh_installdeb">debian/conffiles (dh_installdeb)</h3>
<p>Debian automatycznie oznacza wszystkie pliki w katalogu <code>/etc/</code> jako pliki konfiguracyjne i ich
domyślnie ani nie usuwa przy pozbywaniu się pakietu z systemu ani też nie nadpisuje ich przy
instalacji/aktualizacji pakietu. Jeśli się przyjrzymy procesowi budowania paczki, dostrzeżemy tam
coś takiego:</p>
<pre><code>...
   dh_installdeb
...
        find debian/monitorix/etc -type f -printf '/etc/%P' | LC_ALL=C sort &gt;&gt; debian/monitorix/DEBIAN/conffiles
        chmod 644 debian/monitorix/DEBIAN/conffiles
...
</code></pre>
<p>Dlatego też, nie musimy tworzyć pliku <code>debian/conffiles</code> , by powpisywać tam wszystkie pliki
konfiguracyjne z katalogu <code>/etc/</code> . Natomiast, jeśli zajrzymy do paczki wynikowej, zobaczymy tam, że
został utworzy plik <code>debian/connfiles</code> i jest tam lista plików, np:</p>
<pre><code>/etc/init.d/monitorix
/etc/logrotate.d/monitorix
/etc/monitorix/conf.d/debian.conf
/etc/monitorix/monitorix.conf
/etc/sysconfig/monitorix
</code></pre>
<p>By usunąć te pliki trzeba korzystać z opcji <code>purge</code> (np. przy <code>aptitude</code>). Z kolei jeśli chodzi o
nowsze wersje tych plików, to sprawdzane są sumy kontrolne i jeśli się różnią, wtedy dostajemy
stosowne powiadomienie i podejmujemy akcję dotyczącą ewentualnego nadpisania tego pliku, choć i tak
stary (ew. nowy) plik będzie backup'owany. Jeśli sumy są takie same, pliki nadpisywane są bez
jakiegokolwiek powiadamiania nas o tym, no bo w sumie i tak nie dokonywaliśmy żadnych zmian w tych
plikach.</p>
<p>Plik <code>debian/conffiles</code> znajduje jedynie zastosowanie w przypadku, gdy konfiguracja budowanego
pakietu znajduje się poza katalogiem <code>/etc/</code> , co zwykle nie powinno mieć miejsca.</p>
<h3 id="debiancron-dh_installcron">debian/<em>.cron.</em> (dh_installcron)</h3>
<p>Czasami zdarzy się tak, że pewna funkcjonalność dostarczana wraz z budowanym pakietem będzie wymagać
okresowego wywoływania jakichś operacji. Możemy to osiągnąć przez stworzenie jednego z pięciu (ew.
kilku) plików: <code>debian/*.cron.hourly</code> , <code>debian/*.cron.daily</code> , <code>debian/*.cron.weekly</code> ,
<code>debian/*.cron.monthly</code> , <code>debian/*.cron.d</code> . Każdy z tych plików powędruje w określone miejsce w
systemie, odpowiednio będzie to katalog <code>/etc/cron.hourly/</code> , <code>/etc/cron.daily/</code> ,
<code>/etc/cron.monthly/</code> , <code>/etc/cron.weekly/</code> oraz <code>/etc/cron.d/</code> . Do pierwszych czterech wrzuca się
skrypty, zaś do ostatniego plik, który musi ma być w formacie określonym przez <a href="http://manpages.ubuntu.com/manpages/wily/en/man5/crontab.5.html">crontab</a>.</p>
<h3 id="debianlogrotate-dh_installlogrotate">debian/*.logrotate (dh_installlogrotate)</h3>
<p>Jeśli nasza paczka będzie zawierać demony, które będą logować zdarzenia, dobrze jest także zadbać o
rotację logów, tak by jeden plik nie rozrastał się w nieskończoność. Wszystkie pliki określone w
<code>debian/*.logrotate</code> powędrują do <code>/etc/logrotate.d/</code> , zaś sam format tych plików określony jest w
<a href="http://manpages.ubuntu.com/manpages/wily/en/man8/logrotate.8.html">manie</a>.</p>
<h3 id="debianpostinst-debianpostrm-debianpreinst-debianprerm">debian/<em>.postinst, debian/</em>.postrm, debian/<em>.preinst, debian/</em>.prerm</h3>
<p>Te cztery pliki to skrypty maintainera i nie biorą one udziału przy budowaniu pakietu. Za to,
potrafią robić pewne rzeczy przy instalowaniu, usuwaniu i aktualizowaniu paczki. To właśnie tutaj
dodajemy, np. nowego użytkownika, czy nadajemy uprawnienia pewnym plikom. Zwykle nie będziemy
musieli tworzyć tych skryptów. Jeśli jednak zdecydujemy się na nie, to musimy bardzo uważać, by
czasem nie skasować sobie połowy systemu.</p>
<p>Skrypt <code>preinst</code> jest wywoływany przed rozpakowaniem paczki, z kolei skrypt <code>postinst</code> po jej
rozpakowaniu. Podobnie z dwoma pozostałymi skryptami. <code>prerm</code> jest wywoływany przed usunięciem
pakietu, a <code>postrm</code> po usunięciu.</p>
<p>Dokładny proces instalowania/deinstalowania/aktualizowania pakietu jest opisany <a href="https://www.debian.org/doc/debian-policy/ch-maintainerscripts.html">tutaj</a>. Są tam
wyszczególnione wszystkie akcje podejmowane podczas powyższych czynności. Z kolei zaś, <a href="https://wiki.debian.org/ConfigPackages">pod tym
linkiem</a> można znaleźć przykłady samych skryptów. Dobrze jest też zajrzeć w katalog <code>debian/</code>
innych pakietów, by podejrzeć jak inni maintainerzy tworzą te skrypty.</p>
<h3 id="desktop">*.desktop</h3>
<p>Ten plik nie jest bezpośrednio związany z katalogiem <code>debian/</code> ale jest bardzo użyteczny w przypadku
aplikacji graficznych, bo na jego podstawie mogą zostać utworzone skróty w menu, w które można
kliknąć myszą. Format tego pliku jest opisany <a href="https://standards.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#entries">tutaj</a>. Warto wiedzieć, że istnieje także
narzędzie, które może pomóc nam w weryfikacji składni tego pliku. Jest to <code>desktop-file-validate</code>
(pakiet <code>desktop-file-utils</code> ).</p>
<h2 id="hardening-pakietów">Hardening pakietów</h2>
<p>Jeśli nasz pakiet zawierać będzie pliki wykonywalne, trzeba będzie je skompilować i trzeba będzie to
zrobić z pewnymi określonymi flagami. Większość projektów ma już ustawione pewne flagi domyślne.
Czasem może się zdarzyć tak, że akurat to są te flagi, których my potrzebujemy. Niemniej jednak, mi
się przytrafił taki projekt, którego nie szło z początku niczym ruszyć. W przypadku jednej z paczek
trzeba było edytować plik <code>makefile</code> , z kolei w przypadku drugiej trzeba było odprawić większe
czary ale o tym za moment.</p>
<p>Na sam początek prześledźmy część pliku <code>makefile</code>:</p>
<pre><code>...
###### Compiler, tools and options

CC            = gcc
CXX           = g++
DEFINES       = -DO2 -DQT_NO_DEBUG -DQT_GUI_LIB -DQT_CORE_LIB -DQT_SHARED
CFLAGS        = -pipe -march=x86-64 -mtune=generic -O2 -pipe -fstack-protector --param=ssp-buffer-size=4 -Wall -W -D_REENTRANT $(DEFINES)
CXXFLAGS      = -pipe -march=x86-64 -mtune=generic -O2 -pipe -fstack-protector --param=ssp-buffer-size=4 -Wall -W -D_REENTRANT $(DEFINES)
INCPATH       = -I/usr/share/qt4/mkspecs/linux-g++ -I. -I/usr/include/qt4/QtCore -I/usr/include/qt4/QtGui -I/usr/include/qt4 -I. -I.. -I. -I.
LINK          = g++
LFLAGS        = -Wl,-O1,--sort-common,--as-needed,-z,relro -Wl,-O1
LIBS          = $(SUBLIBS)  -L/usr/lib -lQtGui -lQtCore -lpthread
AR            = ar cqs
RANLIB        =
QMAKE         = /usr/bin/qmake-qt4
TAR           = tar -cf
COMPRESS      = gzip -9f
COPY          = cp -f
SED           = sed
COPY_FILE     = $(COPY)
COPY_DIR      = $(COPY) -r
STRIP         = strip
INSTALL_FILE  = install -m 644 -p
INSTALL_DIR   = $(COPY_DIR)
INSTALL_PROGRAM = install -m 755 -p
DEL_FILE      = rm -f
SYMLINK       = ln -f -s
DEL_DIR       = rmdir
MOVE          = mv -f
CHK_DIR_EXISTS= test -d
MKDIR         = mkdir -p
...
</code></pre>
<p>Mamy tam takie linijki jak <code>CFLAGS</code> , <code>CXXFLAGS</code> oraz <code>LFLAGS</code> . To właśnie te pozycje musimy
zmienić. To jakie flagi musimy ustawić, możemy odnaleźć na wiki debiana, do poczytania <a href="https://wiki.debian.org/HardeningWalkthrough">tutaj</a>,
<a href="https://wiki.debian.org/ReleaseGoals/SecurityHardeningBuildFlags">tutaj</a> i <a href="https://wiki.debian.org/Hardening">tutaj</a> . Nie zagłębiając się w szczegóły, zwykle wystarczy dopisać na początku
pliku <code>debian/rules</code> , te poniższe linijki:</p>
<pre><code>export DEB_BUILD_MAINT_OPTIONS = hardening=+all
DPKG_EXPORT_BUILDFLAGS = 1
include /usr/share/dpkg/buildflags.mk
</code></pre>
<p>Po zbudowaniu paczki, możemy sprawdzić czy powyższe rozwiązanie zadziałało i wykorzystujemy do tego
celu polecenie <code>hardening-check</code> (pakiet <code>hardening-includes</code> ), przykładowo:</p>
<pre><code>$ hardening-check  /usr/bin/ansifilter-gui
/usr/bin/ansifilter-gui:
 Position Independent Executable: no, normal executable!
 Stack protected: no, not found!
 Fortify Source functions: no, only unprotected functions found!
 Read-only relocations: no, not found!
 Immediate binding: no, not found!
</code></pre>
<p>Jeśli widzimy log jak powyżej, oznacza to, że flagi nie zostały poprawnie ustawione i trzeba
kombinować jak je poprawić. Najłatwiejszym sposobem jest oczywiście edycja flag w plikach
źródłowych, z tym, że nie zawsze to działa, np. projekty, które są budowane przy pomocy <code>qmake</code>
generują sobie plik makefile i co z tego, że przepiszemy flagi, jak podczas budowania, ten plik
zostanie nadpisany. Na <a href="https://wiki.debian.org/Hardening#dpkg-buildflags">wiki debiana</a> jest kilka przykładów opisujących min. <code>qmake</code> czy
<code>cmake</code> i możemy z nich skorzystać. W tym przypadku ( <code>qmake</code> ) trzeba było edytować plik <code>.pro</code> i
ustawić w nim:</p>
<pre><code>QMAKE_CPPFLAGS *= -g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -fPIE -pie -Wl,-z,relro -Wl,-z,now
QMAKE_CFLAGS   *= -g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -fPIE -pie -Wl,-z,relro -Wl,-z,now
QMAKE_CXXFLAGS *= -g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -fPIE -pie -Wl,-z,relro -Wl,-z,now
QMAKE_LFLAGS   *= -g -O2 -fPIE -fstack-protector-strong -Wformat -Werror=format-security -D_FORTIFY_SOURCE=2 -fPIE -pie -Wl,-z,relro -Wl,-z,now
</code></pre>
<p>W każdej linijce zostały zawarte flagi, które zwracał <code>dpkg-buildflags</code> przy ustawieniu
<code>hardening=+all</code>, przykładowo:</p>
<pre><code>dpkg-buildflags --status
dpkg-buildflags: status: environment variable DEB_BUILD_OPTIONS=parallel=2
dpkg-buildflags: status: environment variable DEB_HOST_ARCH=amd64
dpkg-buildflags: status: vendor is Debian
dpkg-buildflags: status: hardening features: bindnow=no format=yes fortify=yes pie=no relro=yes stackprotector=yes stackprotectorstrong=yes
dpkg-buildflags: status: qa features: bug=no canary=no
dpkg-buildflags: status: reproducible features: timeless=no
dpkg-buildflags: status: CFLAGS [vendor]: -g -O2 -fstack-protector-strong -Wformat -Werror=format-security
dpkg-buildflags: status: CPPFLAGS [vendor]: -D_FORTIFY_SOURCE=2
dpkg-buildflags: status: CXXFLAGS [vendor]: -g -O2 -fstack-protector-strong -Wformat -Werror=format-security
dpkg-buildflags: status: FCFLAGS [vendor]: -g -O2 -fstack-protector-strong
dpkg-buildflags: status: FFLAGS [vendor]: -g -O2 -fstack-protector-strong
dpkg-buildflags: status: GCJFLAGS [vendor]: -g -O2 -fstack-protector-strong
dpkg-buildflags: status: LDFLAGS [vendor]: -Wl,-z,relro
dpkg-buildflags: status: OBJCFLAGS [vendor]: -g -O2 -fstack-protector-strong -Wformat -Werror=format-security
dpkg-buildflags: status: OBJCXXFLAGS [vendor]: -g -O2 -fstack-protector-strong -Wformat -Werror=format-security
</code></pre>
<p>Sprawdzając plik wykonywalny przy pomocy <code>hardening-check</code> , log zmienił się nieco:</p>
<pre><code>$ hardening-check  /usr/bin/ansifilter-gui
/usr/bin/ansifilter-gui:
 Position Independent Executable: yes
 Stack protected: yes
 Fortify Source functions: yes (some protected functions found)
 Read-only relocations: yes
 Immediate binding: yes
</code></pre>
<p>I dokładnie o takie coś nam chodzi.</p>
<p>Jeśli mamy problem z ustaleniem jakich flag brakuje, pomocne może okazać się narzędzie <code>blhc</code> .
Wszystko czego nam potrzeba by z niego skorzystać, to log z budowania pakietu. Jeśli dysponujemy
takowym, brakujące flagi sprawdzamy w poniższy sposób:</p>
<pre><code>$ blhc --color --build build_log
W-dpkg-buildflags-missing|CPPFLAGS 16 (of 32) missing|

$ blhc --color build_log
CXXFLAGS missing (-g): g++ -c -O2 -fstack-protector-strong -Wformat -Werror=format-security arg_parser.cpp -o arg_parser.o
CPPFLAGS missing (-D_FORTIFY_SOURCE=2): g++ -c -O2 -fstack-protector-strong -Wformat -Werror=format-security arg_parser.cpp -o arg_parser.o
CXXFLAGS missing (-g): g++ -c -O2 -fstack-protector-strong -Wformat -Werror=format-security stringtools.cpp -o stringtools.o
...
</code></pre>
<p>Jak widzimy wyżej, kilku obiektom brakuje flagi <code>-g</code> oraz <code>-D_FORTIFY_SOURCE=2</code> . Trzeba mieć też na
uwadze fakt, że przez taki hardening można nieco popsuć funkcjonalność pakietu.</p>
<h2 id="budowanie-źródeł">Budowanie źródeł</h2>
<p>Jeśli już dostosowaliśmy wszystkie pliki w katalogu <code>debian/</code> , przyszedł czas na zbudowanie źródeł.
W tym celu przechodzimy do głównego katalogu ze źródłami i wydajemy poniższe polecenie:</p>
<pre><code>morfik:~/debian_build/monitorix-3.6.0$ debuild -S -sa -d
</code></pre>
<p>Skrypt <code>dbuild</code> , w zależności od konfiguracji, zainicjuje <code>dpkg-buildpackage</code> oraz kilka
dodatkowych narzędzi Podczas całego procesu, wszystkie łaty, które założyliśmy, zostaną
automatycznie ściągnięte ( <code>quilt</code> ), a sam katalog <code>debian/</code> zostanie oddzielony od źródeł i
upchnięty w osobnej paczce ( <code>dpkg-source</code> ). Takie rozwiązanie ma na celu zmniejszenie ruchu
sieciowego repozytorium, no bo jeśli aktualizujemy paczkę, to wystarczy pobrać tylko katalog
<code>debian/</code> i nie ma potrzeby przy tym pobierać samych źródeł z repozytorium, które czasami mogą ważyć
nawet i dziesiątki czy setki MiB. Same źródła zostaną sprawdzone pod kątem ewentualnych błędów (
<code>lintian</code> ). Zostaną także wygenerowane trzy dodatkowe pliki: <code>.build</code> , <code>.dsc</code> oraz <code>changes</code> . Po
całym procesie pliki <code>.dsc</code> i <code>.changes</code> zostaną podpisane cyfrowo ( <code>gpg</code> ).</p>
<p>W pliku <code>.build</code> będzie umieszczony log z operacji budowania źródeł, czyli dokładnie to samo co
zostanie wydrukowane w terminalu. Plik <code>.dsc</code> zawiera min. sumy kontrole spakowanych źródeł i
katalogu <code>debian</code> . Na tym etapie, plik <code>.changes</code> zbytnio się nie różni od pliku <code>.dsc</code> ale to w
nim będą zawarte sumy kontrole wszystkich wyprodukowanych przez nas paczek <code>.deb</code> . Jest tam również
kilka dodatkowych informacji, takich jak np. numery błędów, które ten pakiet ma zamykać.</p>
<h2 id="budowanie-pakietu">Budowanie pakietu</h2>
<p>Po zbudowaniu źródeł, przyszedł czas na zbudowanie pakietu. W tym celu przechodzimy do katalogu
nadrzędnego (tam gdzie jest plik <code>.dsc</code> ) i zaprzęgamy pbuilder'a do roboty:</p>
<pre><code>$ sudo pbuilder --build ./monitorix_3.6.0-1.dsc
</code></pre>
<p>W tej chwili <code>pbuilder</code> wypakowuje przygotowanego wcześniej chroot'a. Po wypakowaniu są sprawdzane i
instalowane zależności. Po tym etapie, pliki źródłowe są kopiowane do środowiska chroot, po czym są
one wypakowywane. Jeśli robiliśmy jakieś łaty, to zostaną one następnie automatycznie założone na
źródła. Po tym procesie rozpoczyna się właściwa faza budowania pakietu. Dalej już tylko są
wywoływane poszczególne targety debhelper'a (linijki z <code>dh_</code> ) i jeśli proces zakończy się bez
błędów, zbudowane w ten sposób paczki wędrują do katalogu docelowego. Jest także generowany plik
<code>.changes</code> . Po zakończeniu, środowisko chroot jest usuwane. Paczki powinny się znaleźć w tym
katalogu, który określiliśmy w konfiguracji pbuilder'a.</p>
<p>W pliku <code>.changes</code> powinny być teraz uwzględnione paczki <code>.deb</code> :</p>
<pre><code>...
Checksums-Sha1:
...
 aed14e43b9604dc0bdfdc54ea05df91edb33d50b 156398 monitorix_3.6.0-1_amd64.deb
Checksums-Sha256:
...
 951ddd2ace33cac27cd1c02ec695ffce9cd5e6e2d6758676851003e72969ae83 156398 monitorix_3.6.0-1_amd64.deb
Files:
...
 adede69324183ba2248c093263e06934 156398 net optional monitorix_3.6.0-1_amd64.deb
</code></pre>
<p>Niemniej jednak, ten plik <code>.changes</code> nie został jeszcze podpisany. Musimy go podpisać ręcznie przy
pomocy tego poniższego polecenia:</p>
<pre><code>$ debsign /media/Kabi/pbuilder/result/monitorix_3.6.0-1_amd64.changes
</code></pre>
<p>Została nam jeszcze ostania rzecz, czyli zweryfikowanie czy stworzona przez nas paczka zawiera
jakieś błędy. Wołamy zatem lintian'a by sprawdził wszystkie paczki, które znajdzie w wygenerowanym
przed chwilą pliku <code>.changes</code> :</p>
<pre><code>$ rm -R /media/Kabi/pbuilder/lintian/*

$ lintian --setup-lab

$ lintian /media/Kabi/pbuilder/result/monitorix_3.6.0-1_amd64.changes
</code></pre>
<p>Jeśli chodzi o samego lintian'a jeszcze, to dobrze jest usunąć poprzednie katalogi robocze, bo
śmieci tam zgromadzone, mogą wpłynąć na wyniki skanowania.</p>
<p>W tym przypadku nie ma żadnych błędów ani ostrzeżeń, zatem paczka została zbudowana pomyślnie i
pewnie spełnia wszystkie standardy debiana, co otwiera drogę do umieszczenia jej w oficjalnym
repozytorium dystrybucji.</p>
<h3 id="manualne-budowanie-pakietów">Manualne budowanie pakietów</h3>
<p>Prawdopodobnie zdarzy się tak, że z jakiegoś powodu utkniemy i trzeba będzie przetestować szereg
rzeczy, tak by doprowadzić proces budowania pakietu do końca. Jeśli będziemy z każdą drobną poprawką
wywoływać pbuilder'a, to nas szlag trafi w oczekiwaniu na zainstalowanie wszystkich tych zależności
w środowisku chroot. Nie chcemy też sobie zaśmiecać systemu tymi zbędnymi pakietami używanymi
jedynie przy budowaniu paczki. Mamy do wyboru dwie opcje, z których jedna została opisana już na
początku. Druga opcja to skorzystanie z hook'a, który jest dostępny w katalogu
<code>/usr/share/doc/pbuilder/examples/</code> . Mowa o <code>C10shell</code> . Umożliwia on przerwanie operacji przy
ewentualnych błędach podczas budowania paczki i zrzucenie nas do shell'a wewnątrz środowiska chroot.
Standardowo <code>pbuilder</code> by przerwał akcję i posprzątał po sobie. Linkujemy ten hook:</p>
<pre><code>$ ln -s /usr/share/doc/pbuilder/examples/C10shell /media/Kabi/pbuilder/hooks/
</code></pre>
<p>Od tego momentu, jeśli <code>pbuilder</code> napotka błąd, doinstaluje w chroot min. edytor <code>vim</code> i da nam
szansę sprawdzić czemu pakiet się nie zbudował.</p>
<p>Musimy umieć się poruszać wewnątrz środowiska chroot. Przede wszystkim, znajdziemy się w katalogu ze
źródłami (tam gdzie jest katalog <code>debian/</code> ), z tym, że nasz katalog roboczy zostanie zmieniony
nieco:</p>
<pre><code>root@morfikownia:~/monitorix-3.6.0# pwd
/tmp/buildd/monitorix-3.6.0
</code></pre>
<p>Sama edycja plików nie powinna przysporzyć problemów, jedynie co, to trzeba opanować vim'a, choć
można też i to obejść ale o tym za moment. Jeśli problemy będą tkwić w ścieżkach plików, zawsze
możemy porównać je z tym co wypisał nam <code>debhelper</code> . Przykładowo:</p>
<pre><code>...
dh_install --
   cp -a ./docs/debian.conf debian/monitorix/etc/monitorix/conf.d/
...
</code></pre>
<p>Powyższy wycinek z logu mówi, że plik <code>debian.conf</code> z folderu <code>./docs/</code> (wszystko odbywa się
względem naszego katalogu roboczego), czyli w sumie jest to
<code>/tmp/buildd/monitorix-3.6.0/docs/debian.conf</code> ma zostać przekopiowany do
<code>debian/monitorix/etc/monitorix/conf.d/</code> . Zajrzyjmy zatem do tego tajemniczego katalogu
<code>debian/monitorix/</code> :</p>
<pre><code>root@morfikownia:~/monitorix-3.6.0# ls -al debian/monitorix
total 24
drwxr-xr-x 6 morfik morfik 4096 Feb 22 12:50 .
drwxr-xr-x 5 morfik morfik 4096 Feb 22 12:50 ..
drwxr-xr-x 6 morfik morfik 4096 Feb 22 12:50 etc
drwxr-xr-x 3 morfik morfik 4096 Feb 22 12:50 lib
drwxr-xr-x 5 morfik morfik 4096 Feb 22 12:50 usr
drwxr-xr-x 3 morfik morfik 4096 Feb 22 12:50 var
</code></pre>
<p>Widzimy tutaj, że jest to część struktury folderów, która przypomina tę z naszego systemu
operacyjnego. To tutaj właśnie się buduje cały projekt, czyli w odpowiednie miejsca są kopiowane
dostarczane z projektem pliki. Jeśli z jakiegoś powodu coś nie gra, to tu zaczynamy poszukiwania,
oczywiście podpierając się logiem debhelper'a.</p>
<p>Gdy już ustalimy w czym tkwił problem, budujemy testowo paczkę <code>.deb</code> , z tym, że korzystamy już
bezpośrednio z narzędzia <code>dpkg-buildpackage</code> :</p>
<pre><code>root@morfikownia:~/monitorix-3.6.0# dpkg-buildpackage -uc -us -b
...
</code></pre>
<p>Jeśli paczka się zbuduje, znaczy, że możemy opuścić ten chroot.</p>
<p>Powyższe środowisko to chroot, zatem mamy dostęp do jego plików z maszyny hosta, wystarczy znaleźć
miejsce gdzie się ulokował ten chroot. Miejsce gdzie zaczynamy poszukiwania jest określone w pliku
konfiguracyjnym pbuilder'a. Jako, że środowiska są wypakowywane za każdym razem, tworzone są foldery
z numerkami pid'ów procesu pbuilder'a, przykładowo <code>/media/Kabi/pbuilder/build/69865/</code> . Jeśli
chcielibyśmy w trybie graficznym edytować, np. plik <code>debian/rules</code> , to używamy ścieżki
<code>/media/Kabi/pbuilder/build/69865/tmp/buildd/monitorix-3.6.0/debian/rules</code> .</p>
<h3 id="zgubione-pliki-dh_missing">Zgubione pliki (dh_missing)</h3>
<p>Budując pojedynczą paczkę nie ma w zasadzie obaw, że jakieś pliki nam się gdzieś zawieruszą, bo
wszystkie pliki wynikowe są pakowane do tej jednej paczki. Niemniej jednak, w przypadku bardziej
zaawansowanych projektów, z jednego źródła będziemy w stanie wyprodukować kilka paczek. W takim
przypadku trzeba będzie rozdzielić pliki. Może się zatem zdarzyć tak, że przez naszą nieuwagę pewne
pliki nie trafią na swoje miejsce lub zostaną pominięte i zwyczajnie nieuwzględnione w żadnym
pakiecie, który zostanie zbudowany. By tego typu sytuacjom przeciwdziałać dobrze jest w pliku reguł
<code>debian/rules</code> zawrzeć poniższe przepisanie targetu <code>dh_missing</code> :</p>
<pre><code>override_dh_missing:
    dh_missing --list-missing --fail-missing
</code></pre>
<p>W tym powyższym nadpisaniu mamy dwa dodatkowe parametry, z których <code>--list-missing</code> wypisuje
wszystkie pliki, które nie zostaną uwzględnione w żadnym wynikowym pakiecie. Jeśli dodatkowo
zostanie podany <code>--fail-missing</code> , to proces budowy pakietu zostanie przerwany jeśli taki plik
zostanie odnotowany.</p>
<h3 id="instalowanie-zbudowanego-pakietu">Instalowanie zbudowanego pakietu</h3>
<p>Jeśli mamy obawy co do tego jak zachowa się paczka podczas jej instalacji w systemie, możemy
skorzystać z narzędzia <code>piuparts</code> , które w środowisku chroot przetestuje wszystkie kombinacje
instalacji/deinstalacji i aktualizacji pakietu i zwróci obszerny log na temat modyfikowanych plików.
Na końcu zostanie także przedstawione podsumowanie. Poniżej przykładowe sprawdzenie paczki
<code>ansifilter-gui_1.11-1_amd64.deb</code> w środowisku chroot upchniętym w <code>base.tgz</code>
.</p>
<pre><code># piuparts /media/Kabi/pbuilder/result/ansifilter-gui_1.11-1_amd64.deb -b /media/Kabi/pbuilder/base.tgz
</code></pre>
<h2 id="aktualizowanie-pakietu">Aktualizowanie pakietu</h2>
<p>Aktualizacja pakietu <code>.deb</code>, który jest dostępny w debianie i ma zdebianizowane źródła, sprowadza
się do pobrania tych źródeł przy pomocy <code>apt</code> . Trzeba pamiętać by wpis z <code>deb-src</code> był dodany do
pliku <code>/etc/apt/sources.list</code> . Źródła pobieramy w poniższy sposób:</p>
<pre><code>$ apt-get source wpasupplicant
Reading package lists... Done
Building dependency tree
Reading state information... Done
Picking 'wpa' as source package instead of 'wpasupplicant'
Selected version '2.2-1' (testing) for wpa
NOTICE: 'wpa' packaging is maintained in the 'Svn' version control system at:
svn://anonscm.debian.org/pkg-wpa/wpa/trunk/
Need to get 1,801 kB of source archives.
Get:1 http://ftp.pl.debian.org/debian/ sid/main wpa 2.2-1 (dsc) [2,483 B]
Get:2 http://ftp.pl.debian.org/debian/ sid/main wpa 2.2-1 (tar) [1,725 kB]
Get:3 http://ftp.pl.debian.org/debian/ sid/main wpa 2.2-1 (diff) [74.3 kB]
Fetched 1,801 kB in 1s (1,458 kB/s)
gpgv: Signature made Wed 17 Sep 2014 09:53:09 PM CEST using RSA key ID C2B35520
gpgv: Can't check signature: public key not found
dpkg-source: warning: failed to verify signature on ./wpa_2.2-1.dsc
dpkg-source: info: extracting wpa in wpa-2.2
dpkg-source: info: unpacking wpa_2.2.orig.tar.xz
dpkg-source: info: unpacking wpa_2.2-1.debian.tar.xz
dpkg-source: info: applying 01_use_pkg-config_for_pcsc-lite_module.patch
dpkg-source: info: applying 02_dbus_group_policy.patch
dpkg-source: info: applying 06_wpa_gui_menu_exec_path.patch
dpkg-source: info: applying 07_dbus_service_syslog.patch
dpkg-source: info: applying 12_wpa_gui_knotify_support.patch
dpkg-source: info: applying wpa_gui_desktop_add-keywords-entry.patch
dpkg-source: info: applying wpa_supplicant-MACsec-fix-build-failure-for-IEEE8021.patch
dpkg-source: info: applying ap_config_c_fix-typo-for-capabilities.patch
</code></pre>
<p>Paczki budowane ze źródeł nie zawsze mają nazwy takie same jak ich źródła ale to nie stanowi
problemu dla <code>apt</code> i ten sobie odszuka odpowiednie pakiety, tak jak nam to wyżej oznajmił: <code>Picking 'wpa' as source package instead of 'wpasupplicant'</code> . Dalej w logu widzimy, że z repozytorium
zostały pobrane trzy pliki: <code>.dsc</code> , <code>.tar</code> oraz <code>.diff</code> .</p>
<p>Plik <code>.dsc</code> zawiera szereg informacji opisujących pliki, źródła i ludzi, którzy opiekują się daną
paczką. Są tam też zawarte linki, pod którymi można znaleźć dany projekt. Dodatkowo, znajdują się
tam też informacje na temat sum kontrolnych źródeł oraz katalogu <code>debian/</code> . Całość jest podpisana
cyfrowo, co gwarantuje integralność danych, które właśnie pobraliśmy. Jeśli uważnie przejrzeliśmy
log pobierania źródeł, możemy tam zauważyć, że <code>apt</code> nie może zweryfikować sygnatury. By
zweryfikować podpis, potrzebny nam jest klucz publiczny osoby, która podpisała powyższy plik.
Pobranie klucza i weryfikację podpisu możemy przeprowadzić ręcznie przy pomocy poniższych linijek:</p>
<pre><code>$ gpg --verify wpa_2.2-1.dsc
$ gpg --search-keys 0xFF914AF0C2B35520
$ gpg --verify wpa_2.2-1.dsc
</code></pre>
<p>Zwykle plik zostanie poprawnie zweryfikowany, ale jako że nie mamy określonego zaufania do osoby,
której klucz publiczny posiadamy, to zostanie nam wyświetlone ostrzeżenie: <code>WARNING: This key is not certified with a trusted signature!</code>. Samo ostrzeżenie nie wpływa jednak na weryfikację podpisu,
a ten jest w porządku, zatem możemy przejść dalej.</p>
<p>Poza plikiem <code>.dsc</code> , pobrał się także plik <code>.tar</code> . Zawiera on spakowane źródła aplikacji, zwykle
te udostępnianie przez jej dewelopera. W pliku <code>.dif</code> zaś są umieszczone wszelkie zmiany jakie muszą
być poczynione, by zdebianizować oryginalne źródła. Po pobraniu tych plików, źródła są wypakowywane
i dostosowywane, wliczając w to też nakładanie łat, jakie opiekun pakietu przygotował. Po tym
zabiegu mamy przygotowany katalog <code>wpa/</code> .</p>
<p>W katalogu z wypakowanymi źródłami znajduje się podkatalog <code>debian/</code> i to w nim będziemy dokonywać
praktycznie wszelkich zmian. Sam katalog, jak możemy wywnioskować z tych wszystkich powyższych
informacji, jest odrębną całością i jest pakowany oddzielnie. Można go też przenosić między
kolejnymi wersjami źródeł. Jeśli zajrzymy do katalogu gdzie pobraliśmy źródła, możemy dostrzec
również spakowany plik <code>wpa_2.2-1.debian.tar.xz</code> . To tam właśnie jest ulokowany katalog
<code>debian/</code> .</p>
<h3 id="aktualizacja-długo-nieaktualizowanego-pakietu">Aktualizacja długo nieaktualizowanego pakietu</h3>
<p>Jakiś czas temu, próbowałem sobie zaktualizować pakiet <code>minitube</code> , bo w repozytorium była dostępna
wersja sprzed chyba 2 lat. Co w takim przypadku należałoby zrobić, by zaktualizować ten pakiet? Na
początek pobieramy stare źródła przy pomocy <code>apt-get source</code> . Po ich pobraniu, będziemy mieli
dostęp do pliku <code>minitube_2.0-1.debian.tar.xz</code> . Pobieramy ze strony projektu najnowsze źródła i
zapisujemy je w tym samym katalogu. Zmieniamy nazwę pliku z nowymi źródłami, na taką według wzoru:
<code>program_versja.orig.tar.{gz,bz2,xz}</code> , po czym wypakowujemy te dwa pliki. Następnie kopiujemy
katalog <code>debian/</code> do folderu z nowszą wersją źródeł i przechodzimy do tego katalogu. Poniżej
praktyczny przykład:</p>
<pre><code>$ apt-get source minitube
$ wget http://flavio.tordini.org/files/minitube/minitube.tar.gz
$ mv minitube.tar.gz minitube_2.2.orig.tar.gz
$ tar xpf minitube_2.2.orig.tar.gz
$ tar xpf minitube_2.0-1.debian.tar.xz
$ cp -a debian/ minitube
</code></pre>
<p>Teraz pozostaje nam edycja poszczególnych plików. Pierwszym, na który musimy rzucić okiem, jest plik
<code>debian/control</code> . Na stronie projektu danej aplikacji, zwykle przy nowszych wersjach, będą
publikowane informacje na temat zależności, które muszą być spełnione, by dana aplikacja działała w
naszym systemie bez zarzutu. Także jeśli podczas budowania nowszej wersji pakietu, system narzeka na
brak pewnych bibliotek, znaczy to, że musimy uaktualnić pole <code>Build-Depends:</code> . Nie trzeba też
zwykle definiować zależności, które muszą być spełnione przy instalacji pakietu w systemie, bo one
powinny zostać wygenerowane automatycznie w oparciu o <code>${shlibs:Depends}, ${misc:Depends},</code> .</p>
<p>Kolejnym miejscem gdzie prawdopodobnie będziemy musieli zajrzeć przy aktualizacji pakietu jest
katalog <code>debian/patches/</code> , który zawiera wszystkie modyfikacje źródeł wprowadzone przez opiekuna
pakietu. Zwykle przy nowszej wersji, część z łatek zwyczajnie staje się zbędna lub też zbudowanie
pakietu za ich sprawą może okazać się niemożliwe. W takim przypadku, w logu będzie informacja
odnośnie łaty, która stwarza problemy i należy ją wyłączyć przez zakomentowanie odpowiedniej
linijki w pliku <code>debian/patches/series</code> .</p>
<p>Przy aktualizacji paczki, dobrze jest też za sprawą <code>dch</code> uzupełnić wpisy w changelog'u odnośnie
tego co zostało zmienione. Zwykle będziemy korzystać z opcji <code>-n</code> , <code>-i</code> oraz <code>-r</code> . Jeśli byśmy
dokonywali aktualizacji czyjejś paczki, wtedy posługujemy się parametrami <code>-n</code> oraz <code>-r</code> . W
przypadku aktualizacji swojej, wykorzystujemy <code>-i</code> oraz <code>-r</code> . Opcja <code>-n</code> uzupełnia wpis w
changelog'u o <code>Non-maintainer upload</code> :</p>
<pre><code> minitube (2.2-1.1) UNRELEASED; urgency=medium

  * Non-maintainer upload.
  *

  -- Mikhail Morfikov &lt;morfik@nsa.com&gt;  Fri, 26 Sep 2014 17:30:33 +0200
</code></pre>
<p>Tam gdzie są gwiazdki, definiujemy zmiany. Natomiast opcja <code>-r</code> zmienia <code>UNRELEASED</code> , widoczny
wyżej, na <code>unstable</code> , przykład:</p>
<pre><code> minitube (2.2-1.1) unstable; urgency=medium

   * Non-maintainer upload.
   * New upsteram version.

  -- Mikhail Morfikov &lt;morfik@nsa.com&gt;  Fri, 26 Sep 2014 17:33:19 +0200
</code></pre>
<p>I to jest w zasadzie wszystko czego od nas wymaga proces przygotowywania źródeł, przynajmniej w
przypadku aktualizowanych paczek. Musimy teraz zbudować osobno źródła i paczkę <code>.deb</code> , tak jak to
zostało opisane wyżej w rozdziale <code>8</code> . Dobrze jest także zajrzeć sobie do <a href="https://debian-handbook.info/browse/stable/sect.building-first-package.html">tego poradnika</a> i
przejrzeć poszczególne podrozdziały. Więcej bardziej zaawansowanych informacji można znaleźć w
<a href="https://www.debian.org/doc/manuals/developers-reference/index.html">podręczniku dla deweloperów</a> oraz w <a href="https://www.debian.org/doc/debian-policy/index.html">dokumencie poświęconym polityce debiana</a>. Na wiki
debiana jest też kilka obszerniejszych wpisów min. ten dotyczący <a href="https://wiki.debian.org/Packaging/Intro">wprowadzenia do
pakietowania</a>, który można obrać jako punkt wyjścia.</p>
<h3 id="aktualizacja-pakietu-z-repozytorium-git">Aktualizacja pakietu z repozytorium git</h3>
<p>Jako, że spora ilość projektów jest utrzymywana w jakimś systemie kontroli wersji (CVS), to
przydałoby się poruszyć temat ich aktualizacji. Oczywiście, gdy zostaje wypuszczona nowa wersja
danej aplikacji, to nie ma problemu z aktualizacją takiego oprogramowania. Niemniej jednak,
deweloperzy rozwijając dany projekt niekoniecznie chcą co każdy kolejny commit wypuszczać nową
wersję programu. Sporo problemów i/lub błędów jest naprawianych chwilę po ich zgłoszeniu, co
owocuje kolejnymi commit'ami. Gdy tych commit'ów zbierze się jakaś większa ilość (lub będą łatać
krytyczne dziury), to wtedy dopiero autor projektu decyduje się na wydanie nowej wersji appki.
Przez ten cały czas od jednego wydania do drugiego zwykle korzystamy ze starszej wersji programu do
momentu, aż zostanie wypuszczony nowy release, mimo, że pewne zmiany w projekcie już się dokonały.
Jeśli nie chce nam się czekać na moment wypuszczenia kolejnego release, to możemy pobrać wersję git
danej aplikacji i to z niej zbudować pakiet <code>.deb</code> .</p>
<p>Najnowsze źródła zawsze pobieramy za pomocą <code>git clone</code> (lub <code>git pull</code> , jeśli repozytorium mamy
już na dysku). Następnie tak uzyskany katalog trzeba spakować. Poniżej przykład:</p>
<pre><code>$ git clone https://github.com/mhogomchungu/ussd-gui/
$ tar --exclude='.git*' --exclude='.pc' -cf - ussd-gui | xz -9 -c - &gt; ussd-gui_1.2.0+git20160426.orig.tar.xz
</code></pre>
<p>W ten sposób uzyskujemy paczkę z oryginalnymi źródłami niezbędnymi w dalszym procesie budowania
pakietu <code>.deb</code> . Nazwa tego archiwum zawiera w sobie <code>+git20160426</code> . Standardowo po numerze wersji
ostatniego release jest wskazanie, że mamy do czynienia z wersją git ( <code>+git</code> ). Następnie jest
określona data najświeższego commit'a, który został przepchnięty do repozytorium, w formie YYYYMMDD.</p>
<p>W changelog'u ( <code>dch -i</code> ) uwzględniamy tą wersję oraz dorzucamy informacje na temat tego commit'a.
Można ją wyciągnąć z logu git'a w poniższy sposób:</p>
<pre><code>$ git log --graph --decorate --oneline
* 84b2c13 (HEAD -&gt; master, origin/master, origin/HEAD) minor code improvements
...
</code></pre>
<p>Poniżej zaś przykładowy wpis w pliku changelog'a:</p>
<pre><code>ussd-gui (1.2.0+git20160426-2) unstable; urgency=medium

  * New upstream snapshot (84b2c13)

 -- Mikhail Morfikov &lt;morfik@nsa.com&gt;  Tue, 26 Apr 2016 21:00:59 +0200
</code></pre>
<p>Tak przygotowane źródła można zbudować standardową metodą.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/debian/">debian</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f&amp;text=Poradnik%20maintainer%27a%2c%20czyli%20jak%20zrobi%c4%87%20pakiet%20deb" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f&amp;title=Poradnik%20maintainer%27a%2c%20czyli%20jak%20zrobi%c4%87%20pakiet%20deb" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f&amp;title=Poradnik%20maintainer%27a%2c%20czyli%20jak%20zrobi%c4%87%20pakiet%20deb" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f&title=Poradnik%20maintainer%27a%2c%20czyli%20jak%20zrobi%c4%87%20pakiet%20deb" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f&amp;title=Poradnik%20maintainer%27a%2c%20czyli%20jak%20zrobi%c4%87%20pakiet%20deb" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fporadnik-maintainera-czyli-jak-zrobic-pakiet-deb%2f&description=Poradnik%20maintainer%27a%2c%20czyli%20jak%20zrobi%c4%87%20pakiet%20deb" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/migawka-snapshot-repozytorium-debiana/">Migawka (snapshot) repozytorium debiana</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/konfiguracja-multiarch-na-debianie/">Konfiguracja multiarch w dystrybucji Debian</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/manualna-weryfikacja-pakietu-deb-w-debianie/">Manualna weryfikacja pakietu deb w debianie</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/klucze-do-repozytoriow-debiana-trusted-gpg/">Klucze do repozytoriów Debiana (trusted.gpg)</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/pulseaudio-i-przesylanie-dzwieku-przez-siec/">PulseAudio i przesyłanie dźwięku przez sieć</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/konfiguracja-wtyczki-flash-na-linuxie-mms-cfg/">Konfiguracja wtyczki flash na linux&#39;ie (mms.cfg)</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/pobieranie-pakietow-przy-pomocy-cron-apt/">Pobieranie pakietów przy pomocy cron-apt</a></li>
		
	</ul>
</div>

	<div id="comments">
		<script>
  var id =  215 ;

  if (id)
  {
    let url = "https://github.com/morfikov/morfitronik-comments/issues/".concat(id);
    let api_url = "https://api.github.com/repos/morfikov/morfitronik-comments/issues/".concat(id, "/comments");

    var commentsDiv = document.getElementById("comments");

    let xhr = new XMLHttpRequest();
    xhr.responseType = "json";
    xhr.open("GET", api_url);
    xhr.setRequestHeader("Accept", "application/vnd.github.v3.html+json");
    xhr.send();

    xhr.onload = function()
    {
      if (xhr.status != 200)
      {
        let errorText = document.createElement("p");
        errorText.innerHTML = "<i>Komentarze dla tego postu nie zostały jeszcze otworzone (albo skrypty GitHub'a są wyłączone). Być może też skończył ci się przydział 60/godzinę (limit GitHub'a).</i>";
        commentsDiv.appendChild(errorText);
      }
      else
      {
        let comments = xhr.response;

        let mainHeader = document.createElement("h3");
        mainHeader.innerHTML = "Komentarze: ".concat(comments.length);
        commentsDiv.appendChild(mainHeader);

        let issueLink = document.createElement("p");
        issueLink.innerHTML = "<i>Możesz zostawić komentarz korzystając z <a href='".concat(url, "'>GitHub issue</a>.</i>");
        commentsDiv.appendChild(issueLink);

        comments.forEach(function(comment)
        {
			const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'Europe/Warsaw' };
			options.timeZoneName = 'short';
            let commentContent = document.createElement("div");
            commentContent.setAttribute('class', 'gh-comment')
            commentContent.innerHTML = "".concat(
                "<div class='gh-header'>",
                  "<img src='", comment.user.avatar_url, "' />",
                  "<div style='margin:auto 0;'>",
                    "<b><a class='gh-username' href='", comment.user.html_url, "'>", comment.user.login, "</a></b>",
                    " | <em>", (new Date(comment.created_at)).toLocaleTimeString('pl-PL', options), "</em>",
                  "</div>",
                "</div>",
                "<div class='gh-body'>",
                  comment.body_html,
                "</div>"
            );
            commentsDiv.appendChild(commentContent);
        });
      }
    };

    xhr.onerror = function()
    {
      let errorText = document.createElement("p");
      errorText.innerHTML = "<i>Wystąpił jakiś błąd przy ładowaniu komentarzy.</i>";
      commentsDiv.appendChild(errorText);
    };
  }
</script>

	</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2021 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
</body>
</html>
