<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Kopia struktury dysku twardego | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kopia struktury dysku twardego" />
<meta property="og:description" content="Wszyscy wiedzą, że zabawa z dyskiem zwykle kończy się tragicznie dla zawartych na nim danych. W tym
wpisie spróbujemy się przyjrzeć sytuacjom, które nie jednego użytkownika linux&#39;a potrafią przyprawić
o zawał serca. Chodzi generalnie o uszkodzenie struktury dysku, oczywiście tylko tej programowej. Na
błędy fizyczne nie możemy zbytnio nic poradzić. Natomiast jeśli chodzi o sferę logiczną, to mamy
tutaj dość duże pole do popisu i jesteśmy w stanie się zabezpieczyć przed wieloma krytycznymi
sytuacjami. Postaramy się tutaj omówić to jak wykonać kopię dysku. Taka kopia będzie miała tylko
kilka (ew. kilkanaście) MiB, w skład której wchodzić będzie superblok systemu plików, nagłówki
zaszyfrowanych partycji LUKS, struktura LVM i tablica partycji. Uszkodzenie każdego z tych
powyższych uniemożliwia nam dostęp do danych zgromadzonych na dysku." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/kopia-struktury-dysku-twardego/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2015-12-18T17:01:12&#43;00:00" />
<meta property="article:modified_time" content="2015-12-18T17:01:12&#43;00:00" />


		<meta itemprop="name" content="Kopia struktury dysku twardego">
<meta itemprop="description" content="Wszyscy wiedzą, że zabawa z dyskiem zwykle kończy się tragicznie dla zawartych na nim danych. W tym
wpisie spróbujemy się przyjrzeć sytuacjom, które nie jednego użytkownika linux&#39;a potrafią przyprawić
o zawał serca. Chodzi generalnie o uszkodzenie struktury dysku, oczywiście tylko tej programowej. Na
błędy fizyczne nie możemy zbytnio nic poradzić. Natomiast jeśli chodzi o sferę logiczną, to mamy
tutaj dość duże pole do popisu i jesteśmy w stanie się zabezpieczyć przed wieloma krytycznymi
sytuacjami. Postaramy się tutaj omówić to jak wykonać kopię dysku. Taka kopia będzie miała tylko
kilka (ew. kilkanaście) MiB, w skład której wchodzić będzie superblok systemu plików, nagłówki
zaszyfrowanych partycji LUKS, struktura LVM i tablica partycji. Uszkodzenie każdego z tych
powyższych uniemożliwia nam dostęp do danych zgromadzonych na dysku."><meta itemprop="datePublished" content="2015-12-18T17:01:12&#43;00:00" />
<meta itemprop="dateModified" content="2015-12-18T17:01:12&#43;00:00" />
<meta itemprop="wordCount" content="5341">
<meta itemprop="keywords" content="luks,system-plików,hdd,ssd,lvm," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Kopia struktury dysku twardego"/>
<meta name="twitter:description" content="Wszyscy wiedzą, że zabawa z dyskiem zwykle kończy się tragicznie dla zawartych na nim danych. W tym
wpisie spróbujemy się przyjrzeć sytuacjom, które nie jednego użytkownika linux&#39;a potrafią przyprawić
o zawał serca. Chodzi generalnie o uszkodzenie struktury dysku, oczywiście tylko tej programowej. Na
błędy fizyczne nie możemy zbytnio nic poradzić. Natomiast jeśli chodzi o sferę logiczną, to mamy
tutaj dość duże pole do popisu i jesteśmy w stanie się zabezpieczyć przed wieloma krytycznymi
sytuacjami. Postaramy się tutaj omówić to jak wykonać kopię dysku. Taka kopia będzie miała tylko
kilka (ew. kilkanaście) MiB, w skład której wchodzić będzie superblok systemu plików, nagłówki
zaszyfrowanych partycji LUKS, struktura LVM i tablica partycji. Uszkodzenie każdego z tych
powyższych uniemożliwia nam dostęp do danych zgromadzonych na dysku."/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Kopia struktury dysku twardego</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2015-12-18T17:01:12Z">Opublikowano: 18/12/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Kopia struktury dysku twardego</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#objawy-przy-złym-przycięciu-partycji">Objawy przy złym przycięciu partycji</a></li>
    <li><a href="#ryzyko-utraty-danych">Ryzyko utraty danych</a>
      <ol>
        <li><a href="#kopia-wpisów-tablicy-partycji-ms-dos">Kopia wpisów tablicy partycji MS-DOS</a></li>
        <li><a href="#kopia-wpisów-tablicy-partycji-gpt">Kopia wpisów tablicy partycji GPT</a></li>
        <li><a href="#kopia-nagłówków-zaszyfrowanych-partycji-luks">Kopia nagłówków zaszyfrowanych partycji LUKS</a></li>
        <li><a href="#kopia-struktury-lvm">Kopia struktury LVM</a></li>
        <li><a href="#kopia-superbloku-systemu-plików">Kopia superbloku systemu plików</a></li>
      </ol>
    </li>
    <li><a href="#uszkodzenie-struktury-dysku">Uszkodzenie struktury dysku</a>
      <ol>
        <li><a href="#uszkodzenie-tablicy-partycji">Uszkodzenie tablicy partycji</a></li>
        <li><a href="#uszkodzenie-partycji-rozszerzonej">Uszkodzenie partycji rozszerzonej</a></li>
        <li><a href="#uszkodzenie-struktury-lvm">Uszkodzenie struktury LVM</a></li>
        <li><a href="#uszkodzenie-zaszyfrowanego-kontenera-luks">Uszkodzenie zaszyfrowanego kontenera LUKS</a></li>
        <li><a href="#uszkodzenie-superbloku-systemu-plików">Uszkodzenie superbloku systemu plików</a></li>
      </ol>
    </li>
    <li><a href="#wnioski">Wnioski</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Wszyscy wiedzą, że zabawa z dyskiem zwykle kończy się tragicznie dla zawartych na nim danych. W tym
wpisie spróbujemy się przyjrzeć sytuacjom, które nie jednego użytkownika linux'a potrafią przyprawić
o zawał serca. Chodzi generalnie o uszkodzenie struktury dysku, oczywiście tylko tej programowej. Na
błędy fizyczne nie możemy zbytnio nic poradzić. Natomiast jeśli chodzi o sferę logiczną, to mamy
tutaj dość duże pole do popisu i jesteśmy w stanie się zabezpieczyć przed wieloma krytycznymi
sytuacjami. Postaramy się tutaj omówić to jak wykonać kopię dysku. Taka kopia będzie miała tylko
kilka (ew. kilkanaście) MiB, w skład której wchodzić będzie superblok systemu plików, nagłówki
zaszyfrowanych partycji LUKS, struktura LVM i tablica partycji. Uszkodzenie każdego z tych
powyższych uniemożliwia nam dostęp do danych zgromadzonych na dysku.</p>
<h2 id="objawy-przy-złym-przycięciu-partycji">Objawy przy złym przycięciu partycji</h2>
<p>Gdy bawimy się naszym dyskiem i zmieniamy w nim układ partycji, to jest niemal pewne, że prędzej czy
później popełnimy błąd i podamy złe parametry w <code>fdisk</code> . Jeśli zmniejszymy za bardzo partycję i
obetniemy jej trochę systemu plików, to w zależności od posiadanego systemu plików dostaniemy różne
informacje z błędami. Poniżej jest kilka takich komunikatów.</p>
<p>W przypadku, gdy <a href="https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ntfs-pod-linuxem/">zmienialiśmy rozmiar systemu plików
NTFS</a> i zrobiliśmy to błędnie,
<code>ntfsresize</code> zwróci nam poniższy komunikat:</p>
<pre><code># ntfsresize -i -f /dev/sdb1
ntfsresize v2013.1.13AR.1 (libntfs-3g)
Failed to read last sector (19531240): Invalid argument
HINTS: Either the volume is a RAID/LDM but it wasn't setup yet,
   or it was not setup correctly (e.g. by not using mdadm --build ...),
   or a wrong device is tried to be mounted,
   or the partition table is corrupt (partition is smaller than NTFS),
   or the NTFS boot sector is corrupt (NTFS size is not valid).
ERROR(22): Opening '/dev/sdb1' as NTFS failed: Invalid argument
The device '/dev/sdb1' doesn't have a valid NTFS.
Maybe you selected the wrong partition? Or the whole disk instead of a
partition (e.g. /dev/hda, not /dev/hda1)? This error might also occur
if the disk was incorrectly repartitioned (see the ntfsresize FAQ).
</code></pre>
<p>Gdy próbowaliśmy zaś <a href="https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ext4/">zmienić rozmiar systemu plików
EXT4</a> i również coś pochrzaniliśmy, to przy
sprawdzaniu błędów w <code>fsck</code> , ten zwróci nam poniższe zapytanie:</p>
<pre><code># fsck.ext4 -fv /dev/sdb1
e2fsck 1.42.9 (28-Dec-2013)
The filesystem size (according to the superblock) is 1280000 blocks
The physical size of the device is 786432 blocks
Either the superblock or the partition table is likely to be corrupt!
Abort? yes
</code></pre>
<p>Natomiast jeśli chodzi o problemy przy <a href="https://morfikov.github.io/post/zmiana-rozmiaru-partycji-fat32/">zmianie rozmiaru systemu plików
FAT32</a>, to <code>dosfsck</code> będzie miał poniższy
problem:</p>
<pre><code># dosfsck -v /dev/sdb1
dosfsck 3.0.16 (01 Mar 2013)
dosfsck 3.0.16, 01 Mar 2013, FAT32, LFN
Checking we can access the last sector of the filesystem
Seek to 5242879488:Invalid argument
</code></pre>
<p>W przypadku, gdy <a href="https://morfikov.github.io/post/zmiana-rozmiaru-lvm/">zmienialiśmy rozmiar partycji LVM</a> i
przycięliśmy ją za bardzo w <code>fdisk</code> , to przy skanowaniu voluminów w <code>pvscan</code> dostaniemy taki
komunikat:</p>
<pre><code># pvscan
  /dev/grupa1/volumin5: read failed after 0 of 4096 at 12947750912: Błąd wejścia/wyjścia
  /dev/grupa1/volumin5: read failed after 0 of 4096 at 12947808256: Błąd wejścia/wyjścia
  PV /dev/sdb1   VG grupa1   lvm2 [19,06 GiB / 0    free]
  Total: 1 [19,06 GiB] / in use: 1 [19,06 GiB] / in no VG: 0 [0   ]
</code></pre>
<p>Oczywiście nie da rady w takich przypadkach zamontować żadnego przyciętego systemu plików. Jeśli
spróbujemy to <code>mount</code> przy próbie zamontowania takiego zasobu wyrzuci poniższy komunikat:</p>
<pre><code>mount: wrong fs type, bad option, bad superblock on /dev/sdb1,
       missing codepage or helper program, or other error
       In some cases useful info is found in syslog - try
       dmesg | tail  or so
</code></pre>
<p>Bez obaw. Trzeba po prostu znów odpalić fdisk'a i zrobić partycję nieco większą. Żadnych danych w
ten sposób nie stracimy, gdyż operujemy jedynie na tablicy partycji, a ta ma w swojej strukturze
parę pozycji, z których tylko 3 są brane pod uwagę, przynajmniej w linux'ie. Są to sektor
początkowy partycji, rozmiar w sektorach, oraz typ partycji. Możemy dowolnie się tymi parametrami
bawić bez utraty danych, tylko lepiej pamiętać pozycję wyjściową.</p>
<h2 id="ryzyko-utraty-danych">Ryzyko utraty danych</h2>
<p>Ryzyko utraty danych zawsze istnieje, zwłaszcza gdy obchodzimy się z systemem plików bardzo
nieumiejętnie ale wystarczy odrobina rozsądku i kalkulator, aby to ryzyko całkowicie wyeliminować.
Poniżej kilka wskazówek na temat tego jak ma wyglądać kopia struktury dysku twardego i jak ją
wykonać.</p>
<h3 id="kopia-wpisów-tablicy-partycji-ms-dos">Kopia wpisów tablicy partycji MS-DOS</h3>
<p>Zanim się zaczniemy bawić z tablicą partycji, która jest zlokalizowana w
<a href="https://pl.wikipedia.org/wiki/Master_Boot_Record">MBR</a> (przynajmniej jej część), najlepiej jest
wykonać kopię zapasową tego sektora i zachować ją w bezpiecznym miejscu. Jeśli posiadamy partycję
rozszerzoną, przydałoby się również zrobić kopię każdego
<a href="https://en.wikipedia.org/wiki/Extended_boot_record">EBR</a>, a ich lokalizacja zależy od faktycznego
rozkładu dysków logicznych, przykładowo:</p>
<pre><code>Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux
</code></pre>
<p>Są tutaj 3 EBR, a lokalizacja każdego z nich znajduje się zawsze w pierwszym sektorze logicznego
dysku. W przypadku pierwszego dysku logicznego jest to parametr &quot;start&quot; partycji rozszerzonej. W
przypadku pozostałych dysków sprawa ma się nieco inaczej, bo jest to sektor zaraz za końcem
poprzedniej partycji. Między tymi dyskami logicznymi jest trochę wolnego miejsca. W przypadku
równania do 1 MiB jest tam 2047 sektorów + 1 sektor na EBR. Jeśli byśmy wykonali kopię tej pozycji
co jest w parametrze &quot;start&quot;, skopiujemy pierwszy sektor systemu plików, a nie EBR, i przywrócenie
tego sektora nic nam nie da.</p>
<p><a href="https://morfikov.github.io/post/mbr-ebr-i-tablica-partycji-dysku-twardego/">Kopię MBR za to możemy wykonać</a>
bardzo łatwo, bo MBR zawsze znajduje się na tej samej pozycji i jest to pierwszy sektor dysku. Kopię
możemy zrobić przy pomocy narzędzia <code>dd</code> , przykładowo:</p>
<pre><code># dd if=/dev/sdb of=./mbr bs=512 count=1
</code></pre>
<p>W razie problemów, by przywrócić podstawową tablicę partycji możemy wgrać 64 bajty do MBR z
uprzednio zrobionej kopi zapasowej:</p>
<pre><code># dd if=./mbr of=/dev/sdb bs=1 count=64 skip=446 seek=446
</code></pre>
<p>Kopie EBR robimy w ten sam sposób podając tylko odpowiednie adresy sektorów.</p>
<p>Zamiast jednak się bawić w robienie kopi MBR i EBR, możemy zrobić kopię wpisów w tablicy partycji
przy pomocy <code>sfdisk</code> :</p>
<pre><code># sfdisk -d /dev/sdb &gt; sdb_table
# sfdisk /dev/sda &lt; sdb_table
</code></pre>
<p>Tak wygląda przykładowa tablica partycji:</p>
<pre><code># partition table of /dev/sdb
unit: sectors

/dev/sdb1 : start=     2048, size= 45639680, Id=83
/dev/sdb2 : start= 45641728, size= 34525184, Id=83
/dev/sdb3 : start= 80166912, size= 24057856, Id=83
/dev/sdb4 : start=104224768, size= 52074496, Id= 5
/dev/sdb5 : start=104226816, size= 15101952, Id=83
/dev/sdb6 : start=119330816, size=  9390080, Id=83
/dev/sdb7 : start=128722944, size= 27576320, Id=83
</code></pre>
<p>Jak coś nawali, to zawsze możemy ręcznie wpisywać wartości z tej powyższej tabelki do fdisk'a.</p>
<h3 id="kopia-wpisów-tablicy-partycji-gpt">Kopia wpisów tablicy partycji GPT</h3>
<p>Jeśli ktoś używa tablicy partycji GPT, to nie może kierować się powyższymi wskazówkami co do kopi
struktury tablicy partycji, bo ta w przypadku GPT jest inna. Bez problemu możemy zrobić jej kopię i
zachować ją jako plik przy pomocy narzędzi <code>gdisk</code> lub <code>sgdisk</code> , przykładowo:</p>
<pre><code># gdisk /dev/sdb
GPT fdisk (gdisk) version 0.8.8

Partition table scan:
  MBR: protective
  BSD: not present
  APM: not present
  GPT: present

Found valid GPT with protective MBR; using GPT.

Command (? for help): b
Enter backup filename to save: backup_gpt_file
The operation has completed successfully.
</code></pre>
<p>Problem ze stworzonym w ten sposób plikiem jest taki, że nie jest on w postaci czytelnej dla
człowieka i trzeba przywracać całą kopię partycji, zamiast jedynie pojedynczych wpisów.</p>
<h3 id="kopia-nagłówków-zaszyfrowanych-partycji-luks">Kopia nagłówków zaszyfrowanych partycji LUKS</h3>
<p>Jeśli chodzi o zaszyfrowane kontenery LUKS, to trzeba pamiętać, że by się dostać do tego co jest w
środku, musimy podać odpowiedni klucz/hasło, a te są przechowywane w nagłówku partycji. Taki
nagłówek to zwykle 2 MiB danych. Kopię takiego nagłówka możemy zrobić ręcznie przy pomocy <code>dd</code>
albo też posłużyć się w tym celu natywnymi narzędziami LUKS. Jeśli zdecydujemy, aby tak kopia
nagłówka LUKS była zrobiona ręcznie, to musimy pierw uzyskać informacje na temat tego ile taki
nagłówek faktycznie zajmuje:</p>
<pre><code># cryptsetup status sdb1
/dev/mapper/sdb1 is active.
  type:    LUKS1
  cipher:  aes-xts-plain64
  keysize: 512 bits
  device:  /dev/sdb1
  offset:  4096 sectors
  size:    78229504 sectors
  mode:    read/write
</code></pre>
<p>W tym przypadku jest to 4096 sektorów, z których każdy ma 512 bajtów. Zatem wklepujemy te parametry
do <code>dd</code> :</p>
<pre><code># dd if=/dev/sdb1 of=./backup_header_sdb1 bs=512 count=4096
</code></pre>
<p>W ten sposób utworzona kopia nagłówka może zostać przywrócona ręcznie w poniższy sposób:</p>
<pre><code># dd if=./backup_header_sdb1 of=/dev/sdb1 bs=512 count=4096
</code></pre>
<p>Kopię nagłówka LUKS możemy także wykonać przy pomocy <code>luksHeaderBackup</code> , przykładowo:</p>
<pre><code># cryptsetup luksHeaderBackup /dev/sdb1 --header-backup-file ./backup_header_sdb1
</code></pre>
<p>Przywracanie kopi zapasowej nagłówka LUKS odbywa się za sprawą <code>luksHeaderRestore</code> :</p>
<pre><code># cryptsetup luksHeaderRestore /dev/sdb1 --header-backup-file ./backup_header_sdb1
</code></pre>
<h3 id="kopia-struktury-lvm">Kopia struktury LVM</h3>
<p>LVM posiada narzędzia umożliwiające dokonanie kopi struktury kontenera i zapisanie jej w czytelnej
dla człowieka formie w pliku tekstowym. By zrobić sobie taką kopię, wpisujemy do terminala poniższą
komendę:</p>
<pre><code># vgcfgbackup
  Volume group &quot;grupa1&quot; successfully backed up.
</code></pre>
<p>Zostanie w ten sposób utworzony plik <code>/etc/lvm/backup/grupa1</code> , który może nam posłużyć do
odtworzenia całej struktury, w przypadku, gdy ta zostanie w jakiś sposób uszkodzona.</p>
<h3 id="kopia-superbloku-systemu-plików">Kopia superbloku systemu plików</h3>
<p>Superblok to krytyczny sektor każdego systemu plików. Zawiera on informacje, według których kernel
jest w stanie operować na danej partycji. W przypadku, gdy superblok zostaje uszkodzony, kernel nie
wie jak zamontować taki system plików, w efekcie czego nie możemy uzyskać dostępu do danych. Systemy
plików są w stanie chronić swój superblok kopiując go (kilka razy) i zapisując w innych
lokalizacjach w obrębie granic partycji. W taki sposób, jeśli uszkodzeniu ulegnie główny superblok,
to możemy przywrócić jego kopię z któregoś z tych zapasowych sektorów.</p>
<p>Lokalizację superbloku jak i jego kopi w systemie plików EXT4 możemy poznać za pomocą <code>dumpe2fs</code> :</p>
<pre><code># dumpe2fs /dev/sdb1 | grep -i super
...
  Primary superblock at 0, Group descriptors at 1-1
  Backup superblock at 32768, Group descriptors at 32769-32769
  Backup superblock at 98304, Group descriptors at 98305-98305
  Backup superblock at 163840, Group descriptors at 163841-163841
...
</code></pre>
<p>W tym przypadku główny superblok jest ulokowany na pozycji <code>0</code> . Standardowo jest to pierwszy blok
systemu plików. Ilość zapasowych kopi zależy od rozmiaru systemu plików. W tym przypadku mamy do
czynienia z partycją 9 GiB. Zatem jest ona niewielka ale i tak mamy kilka kopi zapasowych
ulokowanych, min. w bloku <code>32768</code> , <code>98304</code> , <code>163840</code> . Na dobrą sprawę, to nie musimy uczyć się
tych pozycji na pamięć. W każdym przypadku są one takie same. Nie musimy także ręcznie dokonywać
kopi superbloku, bo system plików robi to za nas.</p>
<h2 id="uszkodzenie-struktury-dysku">Uszkodzenie struktury dysku</h2>
<p>Może i zmiana rozmiaru LVM, LUKS i normalnych partycji potrafi przebiegać zwykle bez najmniejszych
problemów ale w życiu czasem różnie bywa i niekiedy struktura danych zawartych na dysku może zostać
rozbita. Zadajmy sobie pytanie, co się stanie jak badsector uderzy w MBR, czyli w miejsce gdzie
siedzą wpisy tablicy partycji albo też co się stanie, gdy uszkodzeniu ulegnie nagłówek zaszyfrowanej
partycji? Wyżej został opisany, co prawda, sposób dokonania kopi danych i wgrywania ich w przypadku
problemów ale to trochę takie bezpłciowe. Poniżej sprawdzimy czy faktyczne uszkodzenie struktury
dysku spowoduje utratę rzeczywistych danych.</p>
<h3 id="uszkodzenie-tablicy-partycji">Uszkodzenie tablicy partycji</h3>
<p>W przypadku tablicy partycji MS-DOS może ulec awarii MBR. W MBR poza kodem bootloader'a mamy
4*16=64 bajty na tablicę partycji. Dobrze jest zrobić kopię całego MBR, a potem ewentualnie
przywracać jego części. MBR może przechować maksymalnie 4 wpisy odpowiadające 4 partycjom. Nie
przechowuje jednak wpisów, które są na partycji rozszerzonej.</p>
<p>Partycję rozszerzoną można traktować jako dysk zagnieżdżony w innym dysku. Posiada swój MBR z tym,
że nieco inny. EBR ma taką samą strukturę co MBR ale jest pozbawiony kodu bootloader'a i
wykorzystuje dwa z czterech wpisów na partycje. Jeden z nich opisuje partycję (start partycji, bez
offsetu, oraz długość partycji), a drugi linkuje do kolejnego EBR (start w miejscu nowego EBR,
rozmiar całej partycji począwszy od EBR). W przypadku ostatniej partycji w łańcuchu EBR, ten drugi
wpis ma 0 bajtów.</p>
<p>Co się zatem mogłoby stać? Mógłby zostać uszkodzony wpis podstawowej partycji w MBR, w takim
przypadku stracilibyśmy jedną partycję. Mógłby zostać też trafiony wpis rozszerzony. W wyniku
takiego zdarzenia stracilibyśmy wszystkie partycje w łańcuchu EBR. Jeśli mamy 4 dyski logiczne na
rozszerzonej partycji i uszkodzeniu uległby drugi EBR, stracilibyśmy nie tylko 2 dysk logiczny ale
również 3 i 4.</p>
<p>Tak wygląda przykładowy dysk, ma 3 partycje podstawowe i 3 rozszerzone:</p>
<pre><code># fdisk /dev/sdb

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux
</code></pre>
<p>Skopiujmy teraz całą tablicę partycji:</p>
<pre><code># sfdisk -d /dev/sdb &gt; ./sdb_table
Warning: extended partition does not start at a cylinder boundary.
DOS and Linux will interpret the contents differently.

# cat sdb_table
# partition table of /dev/sdb
unit: sectors

/dev/sdb1 : start=     2048, size= 45639680, Id=83
/dev/sdb2 : start= 45641728, size= 34525184, Id=83
/dev/sdb3 : start= 80166912, size= 24057856, Id=83
/dev/sdb4 : start=104224768, size= 52074496, Id= 5
/dev/sdb5 : start=104226816, size= 15101952, Id=83
/dev/sdb6 : start=119330816, size=  9390080, Id=83
/dev/sdb7 : start=128722944, size= 27576320, Id=83
</code></pre>
<p>W przypadku, gdy zniknie nam jeden wpis, możemy odtworzyć ręcznie tylko ten, którego brakuje. Czas
nabroić trochę. Skoro tablica partycji to 64 bajty po 446 bajtach, to uszkodzimy drugą partycję
przez zapisanie 5 bajtów z tych 16 opisujących tą partycję. Zatem 446+16=462 , czyli na 462 zaczyna
się drugi wpis, jako że numerowanie zaczyna się od 0, a nie od 1:</p>
<pre><code># dd if=/dev/zero of=/dev/sdb bs=1 seek=462 count=5
5+0 records in
5+0 records out
5 bytes (5 B) copied, 0.00636016 s, 0.8 kB/s
# partprobe
</code></pre>
<p>I patrzymy cośmy uczynili:</p>
<pre><code># fdisk /dev/sdb

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592    0  Empty
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux
</code></pre>
<p>No ładnie druga partycja zniszczona i oznaczona jako &quot;empty&quot;. Nie jest to, co prawda, wolna
przestrzeń ale dane są pozornie utracone. Wpis partycji ma szereg bajtów opisujących jej strukturę i
w tym przypadku nadpisaliśmy tylko typ partycji ale w realiach może się zdarzyć, że nieczytelne będą
inne bajty opisujące, np. początek partycji. Jak zatem naprawić szkody, które spowodowaliśmy? W tym
przypadku wystarczy na nowo ustawić typ partycji:</p>
<pre><code># fdisk /dev/sdb

Command (m for help): t
Partition number (1-7): 2
Hex code (type L to list codes): 83
Changed system type of partition 2 to 83 (Linux)

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</code></pre>
<p>A w innych przypadkach? Można oczywiście usunąć cały wpis w tablicy partycji i stworzyć go na nowo.</p>
<pre><code>Command (m for help): d
Partition number (1-7): 2
Warning: partition 2 has empty type
Command (m for help): n
Partition type:
   p   primary (2 primary, 1 extended, 1 free)
   l   logical (numbered from 5)
Select (default p): p
Selected partition 2
First sector (45641728-156299374, default 45641728):
Using default value 45641728
Last sector, +sectors or +size{K,M,G} (45641728-80166911, default 80166911):
Using default value 80166911

Command (m for help): t
Partition number (1-7): 2
Hex code (type L to list codes): 83
Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</code></pre>
<h3 id="uszkodzenie-partycji-rozszerzonej">Uszkodzenie partycji rozszerzonej</h3>
<p>Scenariusz drugi, czyli uszkodzenie partycji rozszerzonej.</p>
<pre><code># dd if=/dev/zero of=/dev/sdb bs=1 seek=494 count=5
5+0 records in
5+0 records out
5 bytes (5 B) copied, 0.00958093 s, 0.5 kB/s
# partprobe
</code></pre>
<p>W tym przypadku partycja rozszerzona będzie pokazywana jako partycja podstawowa i nie da rady
zmienić jej typu na 5 (partycja rozszerzona). Spróbujemy przywrócić cały wpis. Jeśli nie wiemy jaki
powinien być rozmiar partycji rozszerzonej, możemy nam pomóc kopia zrobiona przez <code>sfdisk</code> :</p>
<pre><code>/dev/sdb4 : start=104224768, size= 52074496, Id= 5
</code></pre>
<p>Początkowy sektor to 104224768. Rozmiar zaś to 52074496 sektorów. Pamiętajmy tylko, by od 52074496
odjąć 1 przy wpisywaniu rozmiaru w <code>fdisk</code> :</p>
<pre><code>root:~# fdisk /dev/sdb
Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    0  Empty

Command (m for help): d
Partition number (1-5): 4

Command (m for help): n
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): e
Selected partition 4
First sector (104224768-156299374, default 104224768): 104224768
Last sector, +sectors or +size{K,M,G} (104224768-156299374, default 156299374): +52074495

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</code></pre>
<p>Jak widać stworzenie nowej partycji rozszerzonej nie przywróciło dysków logicznych. Jak je
przywrócić? Trzeba ręcznie przepisać wpisy z kopi zrobionej przez <code>sfdisk</code> :</p>
<pre><code>Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended

Command (m for help): n
All primary partitions are in use
Adding logical partition 5
First sector (104226816-156299263, default 104226816): 104226816
Last sector, +sectors or +size{K,M,G} (104226816-156299263, default 156299263): +15101951

Command (m for help): n
All primary partitions are in use
Adding logical partition 6
First sector (119330816-156299263, default 119330816): 119330816
Last sector, +sectors or +size{K,M,G} (119330816-156299263, default 156299263): +9390079

Command (m for help): n
All primary partitions are in use
Adding logical partition 7
First sector (128722944-156299263, default 128722944): 128722944
Last sector, +sectors or +size{K,M,G} (128722944-156299263, default 156299263): +27576319

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</code></pre>
<p>Jeszcze tylko sprawdźmy czy damy radę zamontować partycję numer 6:</p>
<pre><code># mount /dev/sdb6 /mnt
</code></pre>
<p>Można również wgrać pierwszy EBR, jego pozycja znajduje się zawsze na początku partycji
rozszerzonej, a przy tworzeniu nowej rozszerzonej partycji ten sektor jest nadpisywany. To dlatego
nie ma dysków logicznych. Jego kopię w tym przypadku można by sporządzić przy pomocy <code>dd</code> w poniższy
sposób:</p>
<pre><code># dd if=/dev/sdb bs=512 skip=104224768 count=1 of=./ebr
</code></pre>
<p>I jeśli stracimy rozszerzony wpis w MBR, tworzymy go na nowo w fdisk'u:</p>
<pre><code># fdisk /dev/sdb

Command (m for help): d
Partition number (1-7): 4
Command (m for help): n
Partition type:
   p   primary (3 primary, 0 extended, 1 free)
   e   extended
Select (default e): e
Selected partition 4
First sector (104224768-156299374, default 104224768): 104224768
Last sector, +sectors or +size{K,M,G} (104224768-156299374, default 156299374): +52074495

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
</code></pre>
<p>I wgrywamy kopię EBR:</p>
<pre><code># dd if=./ebr bs=512 seek=104224768 count=1 of=/dev/sdb
1+0 records in
1+0 records out
512 bytes (512 B) copied, 0.000119726 s, 4.3 MB/s
# partprobe
</code></pre>
<p>I co widzimy w fdisk'u?</p>
<pre><code># fdisk /dev/sdb

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux
</code></pre>
<p>Logiczne dyski wróciły na swoje miejsce. Sprawdźmy jeszcze czy da radę zamontować partycję numer 6
bez błędów:</p>
<pre><code># mount /dev/sdb6 /mnt
</code></pre>
<p>Ostatnie uszkodzenie będzie polegać na nadpisaniu EBR poprzedzającego partycję <code>sdb6</code> . Tylko tutaj
taka uwaga, nie możemy nadpisywać sektora 119330816 (start sda6), bo tutaj jest uwzględniony offset.
EBR tej partycji znajduje się zaraz za końcem partycji poprzedzającej, czyli: 119328767+1=119328768
i to ten sektor należy uszkodzić.</p>
<pre><code># dd if=/dev/zero bs=512 seek=119328768 of=/dev/sdb count=1
1+0 records in
1+0 records out
512 bytes (512 B) copied, 0.00091464 s, 560 kB/s
# partprobe
</code></pre>
<p>I sprawdźmy:</p>
<pre><code># fdisk /dev/sdb
omitting empty partition (6)

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
</code></pre>
<p>Tak jak można było się spodziewać, zniknęły dwie partycje. Ta, której EBR nadpisaliśmy oraz następne
w łańcuchu EBR, a że była tylko jedna, to w sumie zniknęły dwie. Oczywiście w tym przypadku sprawa
wygląda podobnie, trzeba przywrócić EBR. A co jeśli nie mamy EBR? Można, by skorzystać z kopi
sfdisk'a. W sumie to sfdisk rozwiązuje wszystkie problemy. Zatem wchodzimy do fdisk'a i przywracamy
dwa zagubione wpisy:</p>
<pre><code># fdisk /dev/sdb
omitting empty partition (6)

Command (m for help): n
All primary partitions are in use
Adding logical partition 6
First sector (119330816-156299263, default 119330816): 119330816
Last sector, +sectors or +size{K,M,G} (119330816-156299263, default 156299263): +9390079

Command (m for help): n
All primary partitions are in use
Adding logical partition 7
First sector (128722944-156299263, default 128722944): 128722944
Last sector, +sectors or +size{K,M,G} (128722944-156299263, default 156299263): +27576319

Command (m for help): p

Disk /dev/sdb: 80.0 GB, 80025280000 bytes
255 heads, 63 sectors/track, 9729 cylinders, total 156299375 sectors
Units = sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disk identifier: 0x000c741d

   Device Boot      Start         End      Blocks   Id  System
/dev/sdb1            2048    45641727    22819840   83  Linux
/dev/sdb2        45641728    80166911    17262592   83  Linux
/dev/sdb3        80166912   104224767    12028928   83  Linux
/dev/sdb4       104224768   156299263    26037248    5  Extended
/dev/sdb5       104226816   119328767     7550976   83  Linux
/dev/sdb6       119330816   128720895     4695040   83  Linux
/dev/sdb7       128722944   156299263    13788160   83  Linux

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</code></pre>
<p>Montujemy i sprawdzamy czy są jakieś błędy:</p>
<pre><code># mount /dev/sdb6 /mnt
</code></pre>
<p>Także kopia pełnej tablicy partycji uchroni nas przed utratą danych wynikającą z jej uszkodzenia.</p>
<h3 id="uszkodzenie-struktury-lvm">Uszkodzenie struktury LVM</h3>
<p>Przetestujmy zatem czy kopia zapasowa struktury LVM, która jest trzymana w katalogu
<code>/etc/lvm/backup/</code> uchroni nas przed czymś. Popsujmy celowo cały kontener LVM:</p>
<pre><code># vgremove grupa1
Do you really want to remove volume group &quot;grupa1&quot; containing 3 logical volumes? [y/n]: y
Do you really want to remove active logical volume volumin1? [y/n]: y
  Logical volume &quot;volumin1&quot; successfully removed
Do you really want to remove active logical volume volumin3? [y/n]: y
  Logical volume &quot;volumin3&quot; successfully removed
Do you really want to remove active logical volume volumin5? [y/n]: y
  Logical volume &quot;volumin5&quot; successfully removed
  Volume group &quot;grupa1&quot; successfully removed

# pvremove /dev/sdb1
  Labels on physical volume &quot;/dev/sdb1&quot; successfully wiped

# lsblk /dev/sdb
NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sdb      8:16   0  74,5G  0 disk
└─sdb1   8:17   0  19,1G  0 part
</code></pre>
<p>No to ładnie namieszaliśmy. Spróbujmy to teraz przywrócić przy pomocy <code>vgcfgrestore</code> :</p>
<pre><code># vgcfgrestore -v grupa1 -f /etc/lvm/backup/grupa1
  Couldn't find device with uuid xMddCU-5h1X-ZZL4-GFfO-ea4L-PqW8-YCGLte.
  Cannot restore Volume Group grupa1 with 1 PVs marked as missing.
  Restore failed.

# pvcreate --uuid xMddCU-5h1X-ZZL4-GFfO-ea4L-PqW8-YCGLte --restorefile /etc/lvm/backup/grupa1 /dev/sdb1
  Couldn't find device with uuid xMddCU-5h1X-ZZL4-GFfO-ea4L-PqW8-YCGLte.
  Physical volume &quot;/dev/sdb1&quot; successfully created

# vgcfgrestore -vv -f /home/user/grupa1 grupa1
      Setting activation/monitoring to 0
      Setting global/locking_type to 1
      Setting global/wait_for_locks to 1
      File-based locking selected.
      Setting global/locking_dir to /run/lock/lvm
      Setting global/prioritise_write_locks to 1
      Locking /run/lock/lvm/V_grupa1 WB
      Locking /run/lock/lvm/P_orphans WB
      /dev/sdb: size is 156299375 sectors
      /dev/sdb1: size is 39976960 sectors
      /dev/sdb1: size is 39976960 sectors
      /dev/sdb1: lvm2 label detected at sector 1
  Restored volume group grupa1
      Unlocking /run/lock/lvm/P_orphans
      Unlocking /run/lock/lvm/V_grupa1
</code></pre>
<p>Sprawdzamy czy coś to dało:</p>
<pre><code># pvs -v --segments
    Scanning for physical volume names
  PV         VG     Fmt  Attr PSize  PFree Start SSize LV       Start Type   PE Ranges
  /dev/sdb1  grupa1 lvm2 a--  19,06g    0      0  1280 volumin1     0 linear /dev/sdb1:0-1279
  /dev/sdb1  grupa1 lvm2 a--  19,06g    0   1280   512 volumin3     0 linear /dev/sdb1:1280-1791
  /dev/sdb1  grupa1 lvm2 a--  19,06g    0   1792  3087 volumin5     0 linear /dev/sdb1:1792-4878

# lvs -v --segments
    Finding all logical volumes
  LV       VG     Attr      Start SSize  #Str Type   Stripe Chunk
  volumin1 grupa1 -wc------    0   5,00g    1 linear     0     0
  volumin3 grupa1 -wc------    0   2,00g    1 linear     0     0
  volumin5 grupa1 -wc------    0  12,06g    1 linear     0     0
</code></pre>
<p>Podmontujmy jeszcze te voluminy:</p>
<pre><code># vgchange -a y grupa1
  3 logical volume(s) in volume group &quot;grupa1&quot; now active
# mount /dev/mapper/grupa1-volumin1 /media/1
# mount /dev/mapper/grupa1-volumin3 /media/3
# mount /dev/mapper/grupa1-volumin5 /media/5

# lsblk /dev/sdb
NAME                       MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sdb                          8:16   0  74,5G  0 disk
└─sdb1                       8:17   0  19,1G  0 part
  ├─grupa1-volumin1 (dm-1) 254:1    0     5G  0 lvm  /media/1
  ├─grupa1-volumin3 (dm-2) 254:2    0     2G  0 lvm  /media/3
  └─grupa1-volumin5 (dm-3) 254:3    0  12,1G  0 lvm  /media/5
</code></pre>
<p>Wszystko działa jak trzeba. Także, jeśli kontener LVM się spieprzy i gdzieś leży kopia metadanych w
postaci pliku (na osobnym dysku), to możemy być spokojni. Co ciekawe, wszelkie zmiany struktury
kontenera LVM są odnotowywane i zapisywane w <code>/etc/lvm/archive/</code> . Są tam po prostu wszystkie
przeszłe konfiguracje kontenerów LVM. Jeśli manipulujemy rozmiarem kontenera LVM najlepiej zrobić
kopię całego foldera <code>/etc/lvm/</code> i trzymać ją na osobnym dysku.</p>
<h3 id="uszkodzenie-zaszyfrowanego-kontenera-luks">Uszkodzenie zaszyfrowanego kontenera LUKS</h3>
<p>W przypadku zaszyfrowanych partycji LUKS, uszkodzeniu mogą ulec nagłówki uniemożliwiając nam dostęp
do zaszyfrowanych danych. Robimy zatem backup nagłówków:</p>
<pre><code># cryptsetup luksHeaderBackup /dev/sdb1 --header-backup-file ./backup_header_sdb1
# ls -al backup_header_sdb1
-r-------- 1 root root 2.0M Jan 16 16:51 backup_header_sdb1
</code></pre>
<p>Nadpiszmy teraz nagłówki przy pomocy 20 sektorów 512 bajtowych:</p>
<pre><code># dd if=/dev/zero of=/dev/sdb1 bs=512 count=20 seek=100
20+0 records in
20+0 records out
10240 bytes (10 kB) copied, 0.00268263 s, 3.8 MB/s
</code></pre>
<p>Spróbujmy otworzyć kontener:</p>
<pre><code># cryptsetup luksOpen /dev/sdb1 sdb1
Enter passphrase for /dev/sdb1:
No key available with this passphrase.
Enter passphrase for /dev/sdb1:
No key available with this passphrase.
Enter passphrase for /dev/sdb1:
No key available with this passphrase.
</code></pre>
<p>Kontener nie przyjmuje hasła, mimo iż jest ono prawidłowe. Jeśli nie otworzymy kontenera, to nie da
rady dostać się do danych. Jeśli sprawdzimy nagłówek, zobaczymy, że jakieś hasło tam jest
przechowywane:</p>
<pre><code># cryptsetup luksDump /dev/sdb1
LUKS header information for /dev/sdb1

Version:        1
Cipher name:    aes
Cipher mode:    xts-plain64
Hash spec:      sha512
Payload offset: 4096
MK bits:        512
MK digest:      1e 6b c3 90 8f 4d ae 35 0c 08 38 16 5f 81 97 e2 a5 34 d0 ec
MK salt:        da 47 d9 88 8f ef 97 79 99 96 cb 9d ca cd 4d 56
                73 a1 5f 76 5b 44 a8 76 3d a4 a9 93 35 e1 7c fd
MK iterations:  46875
UUID:           88ddc490-8904-4fad-b072-39686730977b

Key Slot 0: ENABLED
        Iterations:             185180
        Salt:                   01 88 98 93 3d 96 8c 31 5e ea d2 f4 d9 d8 52 9b
                                66 a2 40 19 72 cb 46 c7 7f a4 1c 97 c2 d8 40 45
        Key material offset:    8
        AF stripes:             4000
Key Slot 1: DISABLED
Key Slot 2: DISABLED
Key Slot 3: DISABLED
Key Slot 4: DISABLED
Key Slot 5: DISABLED
Key Slot 6: DISABLED
Key Slot 7: DISABLED
</code></pre>
<p>Ale jakież to hasło? Tego raczej nie zgadniemy. Przywróćmy zatem kopię nagłówka:</p>
<pre><code># cryptsetup luksHeaderRestore /dev/sdb1 --header-backup-file ./backup_header_sdb1

WARNING!
========
Device /dev/sdb1 already contains LUKS header. Replacing header will destroy existing keyslots.

Are you sure? (Type uppercase yes): YES
</code></pre>
<p>No to jeszcze sprawdźmy czy jesteśmy w stanie zamontować bez problemów ten zaszyfrowany system
plików:</p>
<pre><code># cryptsetup luksOpen /dev/sdb1 sdb1
Enter passphrase for /dev/sdb1:
# mount /dev/mapper/sdb1 /mnt
</code></pre>
<p>Także posiadanie kopi zapasowej nagłówków zaszyfrowanych partycji jest iście obowiązkowe.</p>
<h3 id="uszkodzenie-superbloku-systemu-plików">Uszkodzenie superbloku systemu plików</h3>
<p>Sprawdźmy co się stanie, gdy zostanie uszkodzony superblok sytemu plików. Tak wygląda przykładowy
dysk w <code>fsidk</code> :</p>
<pre><code># fdisk -l /dev/sdb
Disk /dev/sdb: 74.5 GiB, 80025280000 bytes, 156299375 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0x000642e6

Device     Boot    Start       End   Sectors  Size Id Type
/dev/sdb1  *        2048  19531775  19529728  9.3G 83 Linux
/dev/sdb2       19533822 156297215 136763394 65.2G  5 Extended
/dev/sdb5       19533824  25100287   5566464  2.7G 82 Linux swap / Solaris
/dev/sdb6       25102336 156297215 131194880 62.6G 83 Linux
</code></pre>
<p>By uszkodzić superblok partycji <code>sdb1</code> , musimy zapisać jej pierwszy blok. Niekoniecznie musi to być
pełny 4096-bajtowy blok. Zwróćmy uwagę, że zapisujemy urządzenie <code>/dev/sdb1</code> , a nie <code>/dev/sdb</code> .</p>
<pre><code># dd if=/dev/urandom bs=4096 count=1 of=/dev/sdb1
</code></pre>
<p>W tej chwili, przy próbie zamontowania tego systemu plików via <code>mount</code> , kernel zwróci nam ten
poniższy komunikat:</p>
<pre><code>mount.nilfs2: Error while mounting /dev/sdb1 on /mnt: Invalid argument
</code></pre>
<p>Przy skanowaniu tego systemu plików w <code>fsck</code> zostanie zwrócona masa błędów, których nie powinniśmy w
żaden sposób naprawiać. Dlatego też jeśli już skanujemy taki dysk to zawsze róbmy to z opcją <code>-n</code> ,
która zapobiegnie wprowadzaniu zmian do tego uszkodzonego systemu plików.</p>
<p>Spróbujmy zatem przywrócić kopię superbloku, która jest przechowywana w jednym z zapasowych bloków,
dajmy na to <code>32768</code> . By przywrócić superblok, również posługujemy się narzędziem <code>fsck</code> , tylko
wskazujemy mu inną lokalizację superbloku, przykładowo:</p>
<pre><code># fsck -y -f -b 32768 /dev/sdb1
</code></pre>
<p>System plików powinien zostać zmodyfikowany, a my powinniśmy być w stanie go bez problemu
zamontować. Nie powinniśmy też utracić żadnych danych.</p>
<h2 id="wnioski">Wnioski</h2>
<p>Jak widać w pokazanym przeze mnie doświadczeniu, mając w posiadaniu kalkulator i kopię określonej
struktury dysku w zależności od jego konfiguracji, dane przechowywane na takim nośniku są
bezpieczne. Zatem nie ma się co stresować przy zmianie poszczególnych parametrów, tylko ważne jest,
by była kopia zapasowa, z której to możemy wrócić do pozycji wyjściowej.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/luks/">luks</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/system-plik%C3%B3w/">system-plików</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/hdd/">hdd</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/ssd/">ssd</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/lvm/">lvm</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f&amp;text=Kopia%20struktury%20dysku%20twardego" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f&amp;title=Kopia%20struktury%20dysku%20twardego" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f&amp;title=Kopia%20struktury%20dysku%20twardego" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f&title=Kopia%20struktury%20dysku%20twardego" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f&amp;title=Kopia%20struktury%20dysku%20twardego" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkopia-struktury-dysku-twardego%2f&description=Kopia%20struktury%20dysku%20twardego" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zmiana-rozmiaru-lvm/">Zmiana rozmiaru dysków w strukturze LVM</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zmiana-rozmiaru-zaszyfrowanego-kontenera-luks/">Zmiana rozmiaru kontenera LUKS</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ext4/">Zmiana rozmiaru partycji EXT4</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zmiana-rozmiaru-partycji-ntfs-pod-linuxem/">Zmiana rozmiaru partycji NTFS pod linux&#39;em</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/opcja-extents-w-systemach-plikow-ext4/">Opcja extents w systemach plików ext4</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/etykieta-systemu-plikow-i-jej-dostosowanie/">Etykieta systemu plików i jej dostosowanie</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/zarezerwowane-miejsce-w-systemie-plikow-ext4/">Zarezerwowane miejsce w systemie plików ext4</a></li>
		
	</ul>
</div>

	<div id="comments">
		<script>
  var id =  212 ;

  if (id)
  {
    let url = "https://github.com/morfikov/morfitronik-comments/issues/".concat(id);
    let api_url = "https://api.github.com/repos/morfikov/morfitronik-comments/issues/".concat(id, "/comments");

    var commentsDiv = document.getElementById("comments");

    let xhr = new XMLHttpRequest();
    xhr.responseType = "json";
    xhr.open("GET", api_url);
    xhr.setRequestHeader("Accept", "application/vnd.github.v3.html+json");
    xhr.send();

    xhr.onload = function()
    {
      if (xhr.status != 200)
      {
        let errorText = document.createElement("p");
        errorText.innerHTML = "<i>Komentarze dla tego postu nie zostały jeszcze otworzone (albo skrypty GitHub'a są wyłączone). Być może też skończył ci się przydział 60/godzinę (limit GitHub'a).</i>";
        commentsDiv.appendChild(errorText);
      }
      else
      {
        let comments = xhr.response;

        let mainHeader = document.createElement("h3");
        mainHeader.innerHTML = "Komentarze: ".concat(comments.length);
        commentsDiv.appendChild(mainHeader);

        let issueLink = document.createElement("p");
        issueLink.innerHTML = "<i>Możesz zostawić komentarz korzystając z <a href='".concat(url, "'>GitHub issue</a>.</i>");
        commentsDiv.appendChild(issueLink);

        comments.forEach(function(comment)
        {
			const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'Europe/Warsaw' };
			options.timeZoneName = 'short';
            let commentContent = document.createElement("div");
            commentContent.setAttribute('class', 'gh-comment')
            commentContent.innerHTML = "".concat(
                "<div class='gh-header'>",
                  "<img src='", comment.user.avatar_url, "' />",
                  "<div style='margin:auto 0;'>",
                    "<b><a class='gh-username' href='", comment.user.html_url, "'>", comment.user.login, "</a></b>",
                    " | <em>", (new Date(comment.created_at)).toLocaleTimeString('pl-PL', options), "</em>",
                  "</div>",
                "</div>",
                "<div class='gh-body'>",
                  comment.body_html,
                "</div>"
            );
            commentsDiv.appendChild(commentContent);
        });
      }
    };

    xhr.onerror = function()
    {
      let errorText = document.createElement("p");
      errorText.innerHTML = "<i>Wystąpił jakiś błąd przy ładowaniu komentarzy.</i>";
      commentsDiv.appendChild(errorText);
    };
  }
</script>

	</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2021 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
</body>
</html>
