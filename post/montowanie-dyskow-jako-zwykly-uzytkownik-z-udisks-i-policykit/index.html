<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit" />
<meta property="og:description" content="Jeszcze nie tak dawno temu przeciętnej klasy desktop był wyposażony w pojedynczy i do tego
niewielkiej pojemności dysk twardy, który był w stanie pomieścić wszystkie pliki swojego
właściciela. Obecnie jednak większość maszyn ma tych nośników już kilka. Mowa tutaj nie tylko o
dyskach systemowych, które są fizycznie na stałe zamontowane w komputerze ale również o tych
wszystkich urządzeniach, które można podłączyć do portu USB. Polityka linux&#39;a wymusza, by wszystkie
nośniki pamięci masowej (HDD, SSD, pendrive czy też karty SD) były montowane w systemie jedynie
przez użytkowników posiadających uprawnienia administratora. Domyślnie taki przywilej ma jedynie
root. Zatem by uzyskać dostęp do danych na takim zewnętrznym nośniku musimy logować się na root&#39;a.
Jakby nie patrzeć ma to swoje plusy patrząc z perspektywy bezpieczeństwa, niemniej jednak czy
naprawdę potrzebny nam jest root do wgrania czegoś na nasz ulubiony pendrive? Widać nie tylko ja
zadawałem sobie takie pytanie i ktoś postanowił stworzyć narzędzie UDisks (lub jego nowszą wersję
UDisks2), które za pomocą mechanizmu PolicyKit (zwanym też PolKit) jest w stanie nadać stosowne
uprawnienia konkretnym użytkownikom systemu, przez co można określić zespół akcji, które będą oni w
stanie przeprowadzić bez potrzeby podawania hasła, np. montowanie czy odmontowanie zasobu.
Postanowiłem zatem zobaczyć jak ten duet sobie radzi na moim Debianie przy tradycyjnym użytkowaniu
systemu i ocenić jego stopień przydatności." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/montowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2019-04-26T21:10:15+02:00" />
<meta property="article:modified_time" content="2023-12-18T18:00:00+01:00" />


		<meta itemprop="name" content="Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit">
<meta itemprop="description" content="Jeszcze nie tak dawno temu przeciętnej klasy desktop był wyposażony w pojedynczy i do tego
niewielkiej pojemności dysk twardy, który był w stanie pomieścić wszystkie pliki swojego
właściciela. Obecnie jednak większość maszyn ma tych nośników już kilka. Mowa tutaj nie tylko o
dyskach systemowych, które są fizycznie na stałe zamontowane w komputerze ale również o tych
wszystkich urządzeniach, które można podłączyć do portu USB. Polityka linux&#39;a wymusza, by wszystkie
nośniki pamięci masowej (HDD, SSD, pendrive czy też karty SD) były montowane w systemie jedynie
przez użytkowników posiadających uprawnienia administratora. Domyślnie taki przywilej ma jedynie
root. Zatem by uzyskać dostęp do danych na takim zewnętrznym nośniku musimy logować się na root&#39;a.
Jakby nie patrzeć ma to swoje plusy patrząc z perspektywy bezpieczeństwa, niemniej jednak czy
naprawdę potrzebny nam jest root do wgrania czegoś na nasz ulubiony pendrive? Widać nie tylko ja
zadawałem sobie takie pytanie i ktoś postanowił stworzyć narzędzie UDisks (lub jego nowszą wersję
UDisks2), które za pomocą mechanizmu PolicyKit (zwanym też PolKit) jest w stanie nadać stosowne
uprawnienia konkretnym użytkownikom systemu, przez co można określić zespół akcji, które będą oni w
stanie przeprowadzić bez potrzeby podawania hasła, np. montowanie czy odmontowanie zasobu.
Postanowiłem zatem zobaczyć jak ten duet sobie radzi na moim Debianie przy tradycyjnym użytkowaniu
systemu i ocenić jego stopień przydatności."><meta itemprop="datePublished" content="2019-04-26T21:10:15+02:00" />
<meta itemprop="dateModified" content="2023-12-18T18:00:00+01:00" />
<meta itemprop="wordCount" content="2685">
<meta itemprop="keywords" content="debian,udisks,policykit,hdd,ssd,usb," />
		<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit"/>
<meta name="twitter:description" content="Jeszcze nie tak dawno temu przeciętnej klasy desktop był wyposażony w pojedynczy i do tego
niewielkiej pojemności dysk twardy, który był w stanie pomieścić wszystkie pliki swojego
właściciela. Obecnie jednak większość maszyn ma tych nośników już kilka. Mowa tutaj nie tylko o
dyskach systemowych, które są fizycznie na stałe zamontowane w komputerze ale również o tych
wszystkich urządzeniach, które można podłączyć do portu USB. Polityka linux&#39;a wymusza, by wszystkie
nośniki pamięci masowej (HDD, SSD, pendrive czy też karty SD) były montowane w systemie jedynie
przez użytkowników posiadających uprawnienia administratora. Domyślnie taki przywilej ma jedynie
root. Zatem by uzyskać dostęp do danych na takim zewnętrznym nośniku musimy logować się na root&#39;a.
Jakby nie patrzeć ma to swoje plusy patrząc z perspektywy bezpieczeństwa, niemniej jednak czy
naprawdę potrzebny nam jest root do wgrania czegoś na nasz ulubiony pendrive? Widać nie tylko ja
zadawałem sobie takie pytanie i ktoś postanowił stworzyć narzędzie UDisks (lub jego nowszą wersję
UDisks2), które za pomocą mechanizmu PolicyKit (zwanym też PolKit) jest w stanie nadać stosowne
uprawnienia konkretnym użytkownikom systemu, przez co można określić zespół akcji, które będą oni w
stanie przeprowadzić bez potrzeby podawania hasła, np. montowanie czy odmontowanie zasobu.
Postanowiłem zatem zobaczyć jak ten duet sobie radzi na moim Debianie przy tradycyjnym użytkowaniu
systemu i ocenić jego stopień przydatności."/>
<meta name="twitter:site" content="@mikhailmorfikov"/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2019-04-26T21:10:15&#43;02:00">Opublikowano: 26/04/2019</time>
	<time class="entry__meta-lastmod meta-lastmod" datetime="2023-12-18T18:00:00&#43;01:00">Zaktualizowano: 18/12/2023</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Montowanie dysków jako zwykły użytkownik z UDisks i PolicyKit</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#udisks-i-udisks2">UDisks i UDisks2</a></li>
    <li><a href="#policykit-0115-vs-0105">PolicyKit 0.115 vs. 0.105</a></li>
    <li><a href="#agent-autoryzacyjny-policykit">Agent autoryzacyjny PolicyKit</a></li>
    <li><a href="#akcje-udisks-dla-policykit">Akcje UDisks dla PolicyKit</a>
      <ol>
        <li><a href="#domyślne-ustawienia-autoryzacji-akcji">Domyślne ustawienia autoryzacji akcji</a></li>
      </ol>
    </li>
    <li><a href="#konfiguracja-policykit">Konfiguracja PolicyKit</a>
      <ol>
        <li><a href="#logowanie-reguł">Logowanie reguł</a>
          <ol>
            <li><a href="#usunięcie-flagi---no-debug">Usunięcie flagi --no-debug</a></li>
          </ol>
        </li>
        <li><a href="#domyślne-blokowanie-montowania-zasobów">Domyślne blokowanie montowania zasobów</a></li>
        <li><a href="#zezwolenie-użytkownikom-na-montowanie-zasobów">Zezwolenie użytkownikom na montowanie zasobów</a></li>
      </ol>
    </li>
    <li><a href="#nośniki-systemowe-vs-niesystemowe">Nośniki systemowe vs. niesystemowe</a></li>
    <li><a href="#automatyczne-montowanie-podłączonych-dysków">Automatyczne montowanie podłączonych dysków</a></li>
    <li><a href="#usbguard-vs-udisks--policykit">USBguard vs. UDisks + PolicyKit</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Jeszcze nie tak dawno temu przeciętnej klasy desktop był wyposażony w pojedynczy i do tego
niewielkiej pojemności dysk twardy, który był w stanie pomieścić wszystkie pliki swojego
właściciela. Obecnie jednak większość maszyn ma tych nośników już kilka. Mowa tutaj nie tylko o
dyskach systemowych, które są fizycznie na stałe zamontowane w komputerze ale również o tych
wszystkich urządzeniach, które można podłączyć do portu USB. Polityka linux'a wymusza, by wszystkie
nośniki pamięci masowej (HDD, SSD, pendrive czy też karty SD) były montowane w systemie jedynie
przez użytkowników posiadających uprawnienia administratora. Domyślnie taki przywilej ma jedynie
root. Zatem by uzyskać dostęp do danych na takim zewnętrznym nośniku musimy logować się na root'a.
Jakby nie patrzeć ma to swoje plusy patrząc z perspektywy bezpieczeństwa, niemniej jednak czy
naprawdę potrzebny nam jest root do wgrania czegoś na nasz ulubiony pendrive? Widać nie tylko ja
zadawałem sobie takie pytanie i ktoś postanowił stworzyć narzędzie UDisks (lub jego nowszą wersję
UDisks2), które za pomocą mechanizmu PolicyKit (zwanym też PolKit) jest w stanie nadać stosowne
uprawnienia konkretnym użytkownikom systemu, przez co można określić zespół akcji, które będą oni w
stanie przeprowadzić bez potrzeby podawania hasła, np. montowanie czy odmontowanie zasobu.
Postanowiłem zatem zobaczyć jak ten duet sobie radzi na moim Debianie przy tradycyjnym użytkowaniu
systemu i ocenić jego stopień przydatności.</p>
<h2 id="udisks-i-udisks2">UDisks i UDisks2</h2>
<p>Lata temu, gdy przenośna forma pamięci masowej zyskiwała na popularności i przy okazji rosło coraz
bardziej niezadowolenie użytkowników z racji niedogodności wynikających z dodatkowej konfiguracji
jaką trzeba było poczynić, by te zewnętrzne nośniki można było jakoś po ludzku montować w linux'ie,
powstało narzędzie UDisks. W późniejszym czasie powstała jego druga wersja zwana
obecnie <a href="http://storaged.org/doc/udisks2-api/latest/">UDisks2</a>, z tym, że w dalszym ciągu referuje się do tego narzędzia jako UDisks, co może
być nieco mylące. Z Debiana pakiet <a href="https://tracker.debian.org/pkg/udisks">udisks wyleciał dnia 2015-06-22</a>. Od tak już 2012 roku
rozpoczęła się migracja na <a href="https://tracker.debian.org/pkg/udisks2/">udisks2</a> i obecnie od lat się używa już tylko tej drugiej wersji.</p>
<h2 id="policykit-0115-vs-0105">PolicyKit 0.115 vs. 0.105</h2>
<p>Aktualnie w Debianie jest jakiś większy problem dotyczący PolicyKit. Chodzi generalnie o to, że od
lat jest już nowsza wersja pakietu <code>policykit-1</code> (tj. <code>0.106+</code> ) ale w gałęzi niestabilnej w
dalszym ciągu jest wersja <code>0.105</code> . Do końca nie mam pojęcia czemu deweloperzy Debiana nie chcą
wpuścić tej nowszej wersji (aktualnie <code>0.115</code> ) do głównego repozytorium. Być może przez fakt, że
składnia reguł nie jest wstecznie kompatybilna z tą, która była w poprzedniej wersji PolKit'a i są
obawy o popsucie ludziom ich systemów. Niemniej jednak, różnica wersji niesie ze sobą pewne
konsekwencje. Mianowicie, niektórych rzeczy na starszej wersji PolicyKit nie da rady wykonać.
Dlatego też potrzebna jest ta nowsza wersja, która obecnie od lat figuruje w repozytorium
experimental.</p>
<p>Ten artykuł zakłada wykorzystanie właśnie tej nowszej wersji PolicyKit i jeśli chcemy by nam
poniższa składnia reguł zadziałała, to musimy sobie zaktualizować pakiety PolKit'a do wersji z
experimental. W tym celu dodajemy do pliku <code>/etc/apt/sources.list</code> poniższy wpis:</p>
<pre><code>  deb     https://deb.debian.org/debian/ experimental main contrib non-free
# deb-src https://deb.debian.org/debian/ experimental main contrib non-free
</code></pre>
<p>Oraz tworzymy plik <code>/etc/apt/preferences</code> i wrzucamy do niego poniższy kod:</p>
<pre><code>Package: libpolkit-* policykit-*
Pin: release o=Debian,a=experimental
Pin-Priority: 995

Package: *
Pin: origin deb.debian.org
Pin: release o=Debian,a=experimental
Pin-Priority: 130

Package: *
Pin: origin deb.debian.org
Pin: release o=Debian,a=unstable
Pin-Priority: 990
</code></pre>
<p>Więcej na temat <a href="https://wiki.debian.org/AptPreferences">konfiguracji pinning'u APT</a> można znaleźć tutaj.</p>
<h2 id="agent-autoryzacyjny-policykit">Agent autoryzacyjny PolicyKit</h2>
<p>PolicyKit wymaga agenta, który będzie pośredniczył między użytkownikiem, a demonem PolKit'a. Z
reguły każde środowisko graficzne ma swojego własnego agenta, np. KDE ma <code>polkit-kde-agent-1</code> . Nie
wszystkie środowiska, np. te oparte o Openbox, mają stosownego agenta i jeśli korzystamy z takiego
środowiska, to trzeba rozejrzeć się za jakimś agentem PolicyKit i go sobie doinstalować we własnym
zakresie. W przeciwnym razie okienka z prośbą o autoryzację nie będą pokazywane.</p>
<h2 id="akcje-udisks-dla-policykit">Akcje UDisks dla PolicyKit</h2>
<p>UDisks nie jest jedynym narzędziem, które potrafi współpracować z PolicyKit. Jest ich dość sporo i
w zasadzie każda aplikacja może robić użytek z PolKit'a jeśli ich deweloperzy się postarali o to. W
przypadku UDisks mamy <a href="http://storaged.org/doc/udisks2-api/latest/udisks-polkit-actions.html">sporo akcji</a>, których przeprowadzenie można indywidualnie przypisać
poszczególnym użytkownikom w systemie. Wszystkie akcje wraz z ich opisami można także wyciągnąć z
pliku, który znajduje się w katalogu <code>/usr/share/polkit-1/actions/</code> :</p>
<pre><code>$ cat /usr/share/polkit-1/actions/org.freedesktop.UDisks2.policy | grep \&lt;action -A1
  &lt;action id=&quot;org.freedesktop.udisks2.filesystem-mount&quot;&gt;
    &lt;description&gt;Mount a filesystem&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.filesystem-mount-system&quot;&gt;
    &lt;description&gt;Mount a filesystem on a system device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.filesystem-mount-other-seat&quot;&gt;
    &lt;description&gt;Mount a filesystem from a device plugged into another seat&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.filesystem-fstab&quot;&gt;
    &lt;description&gt;Mount/unmount filesystems defined in the fstab file with the x-udisks-auth option&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.filesystem-unmount-others&quot;&gt;
    &lt;description&gt;Unmount a device mounted by another user&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.filesystem-take-ownership&quot;&gt;
    &lt;description&gt;Take ownership of a filesystem&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-unlock&quot;&gt;
    &lt;description&gt;Unlock an encrypted device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-unlock-system&quot;&gt;
    &lt;description&gt;Unlock an encrypted system device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-unlock-other-seat&quot;&gt;
    &lt;description&gt;Unlock an encrypted device plugged into another seat&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-unlock-crypttab&quot;&gt;
    &lt;description&gt;Unlock an encrypted device specified in the crypttab file with the x-udisks-auth option&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-lock-others&quot;&gt;
    &lt;description&gt;Lock an encrypted device unlocked by another user&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-change-passphrase&quot;&gt;
    &lt;description&gt;Change passphrase for an encrypted device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.encrypted-change-passphrase-system&quot;&gt;
    &lt;description&gt;Change passphrase for an encrypted device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.loop-setup&quot;&gt;
    &lt;description&gt;Manage loop devices&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.loop-delete-others&quot;&gt;
    &lt;description&gt;Delete loop devices&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.loop-modify-others&quot;&gt;
    &lt;description&gt;Modify loop devices&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.manage-swapspace&quot;&gt;
    &lt;description&gt;Manage swapspace&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.manage-md-raid&quot;&gt;
    &lt;description&gt;Manage RAID arrays&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.power-off-drive&quot;&gt;
    &lt;description&gt;Power off drive&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.power-off-drive-system&quot;&gt;
    &lt;description&gt;Power off a system drive&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.power-off-drive-other-seat&quot;&gt;
    &lt;description&gt;Power off a drive attached to another seat&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.eject-media&quot;&gt;
    &lt;description&gt;Eject media&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.eject-media-system&quot;&gt;
    &lt;description&gt;Eject media from a system drive&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.eject-media-other-seat&quot;&gt;
    &lt;description&gt;Eject media from a drive attached to another seat&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.modify-device&quot;&gt;
    &lt;description&gt;Modify a device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.modify-device-system&quot;&gt;
    &lt;description&gt;Modify a system device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.modify-device-other-seat&quot;&gt;
    &lt;description&gt;Modify a device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.rescan&quot;&gt;
    &lt;description&gt;Rescan a device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.open-device&quot;&gt;
    &lt;description&gt;Open a device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.open-device-system&quot;&gt;
    &lt;description&gt;Open a system device&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.modify-system-configuration&quot;&gt;
    &lt;description&gt;Modify system-wide configuration&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.read-system-configuration-secrets&quot;&gt;
    &lt;description&gt;Modify system-wide configuration&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.modify-drive-settings&quot;&gt;
    &lt;description&gt;Modify drive settings&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-smart-update&quot;&gt;
    &lt;description&gt;Update SMART data&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-smart-simulate&quot;&gt;
    &lt;description&gt;Set SMART data from blob&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-smart-selftest&quot;&gt;
    &lt;description&gt;Run SMART self-test&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-smart-enable-disable&quot;&gt;
    &lt;description&gt;Enable/Disable SMART&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-check-power&quot;&gt;
    &lt;description&gt;Check power state&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-standby&quot;&gt;
    &lt;description&gt;Send standby command&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-standby-system&quot;&gt;
    &lt;description&gt;Send standby command to a system drive&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-standby-other-seat&quot;&gt;
    &lt;description&gt;Send standby command to drive on other seat&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.ata-secure-erase&quot;&gt;
    &lt;description&gt;Securely erase a hard disk&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.cancel-job&quot;&gt;
    &lt;description&gt;Cancel job&lt;/description&gt;
--
  &lt;action id=&quot;org.freedesktop.udisks2.cancel-job-other-user&quot;&gt;
    &lt;description&gt;Cancel job started by another user&lt;/description&gt;
</code></pre>
<h3 id="domyślne-ustawienia-autoryzacji-akcji">Domyślne ustawienia autoryzacji akcji</h3>
<p>Każda akcja ma domyślne ustawienia autoryzacji akcji. Poniżej przykład autoryzacji dla jednej z
akcji UDisks, a konkretnie dla <code>org.freedesktop.udisks2.filesystem-mount</code> :</p>
<pre><code>&lt;defaults&gt;
  &lt;allow_inactive&gt;auth_admin&lt;/allow_inactive&gt;
  &lt;allow_active&gt;yes&lt;/allow_active&gt;
  &lt;allow_any&gt;auth_admin&lt;/allow_any&gt;
&lt;/defaults&gt;
</code></pre>
<p>Poniżej wyjaśnienie opcji:</p>
<ul>
<li><code>allow_inactive</code> -- aplikuje się do lokalnych klientów, którzy mają nieaktywne sesje, np. mają
zablokowany ekran.</li>
<li><code>allow_active</code> -- aplikuje się do lokalnych klientów, którzy mają aktywne sesje, np. użytkownicy
zalogowani na TTY, czy mający odpalone środowisko graficzne.</li>
<li><code>allow_any</code> -- aplikuje się do każdego klienta (w tym też zdalnego), który próbuje zamontować
zasób.</li>
</ul>
<p>Wszystkie te trzy elementy, tj. <code>allow_any</code> , <code>allow_inactive</code> oraz <code>allow_active</code> mogą przyjąć
jedną z poniższych wartości:</p>
<ul>
<li><code>no</code> -- nieautoryzowany.</li>
<li><code>yes</code> -- autoryzowany.</li>
<li><code>auth_admin</code> -- wymagane uwierzytelnienie przez użytkownika z prawami administratora.</li>
<li><code>auth_self</code> -- wymagane jest uwierzytelnienie przez właściciela sesji, z której klient się wywodzi.
Niezalecane w systemach mających kilku użytkowników z powodu niedostatecznych restrykcji (zalecane
używanie <code>auth_admin</code> ).</li>
<li><code>auth_self_keep</code> -- podobne do <code>auth_self</code> ale autoryzacja jest zachowywana przez krótki przedział
czasu, np. 5 minut.</li>
<li><code>auth_admin_keep</code> -- podobne do <code>auth_admin</code> ale autoryzacja jest zachowywana przez krótki
przedział czasu, np. 5 minut.</li>
</ul>
<h2 id="konfiguracja-policykit">Konfiguracja PolicyKit</h2>
<p>Domyślna konfiguracja PolicyKit dla montowania zasobów z wykorzystaniem UDisks zezwala każdemu
użytkownikowi lokalnemu posiadającemu aktywną sesję na zamontowanie dowolnego systemu plików bez
podawania jakiegokolwiek hasła. Można więc podłączyć dowolny nośnik i bez problemu zacząć z nim
wymieniać informacje. Tego typu zachowanie jest niedopuszczalne z punktu widzenia bezpieczeństwa
systemu. Musimy zatem napisać parę reguł dla PolicyKit, które skonfigurują nam zachowanie UDisks i
zezwolą tylko określonym użytkownikom w systemie (innym niż root) na montowanie nośników pamięci.</p>
<p>Pliki reguł PolicyKit umieszcza się w katalogu <code>/etc/polkit-1/rules.d/</code> . Nazwy plików mają postać
<code>nn-nazwa.rules</code> , czyli dwucyfrowy numerek oddzielony od nazwy za pomocą myślnika, a na końcu
sufiks <code>.rules</code> . Tylko pliki w takim systemie nazewniczym są brane pod uwagę przez PolKit. Trzeba
tutaj zaznaczyć jeszcze, że kolejność reguł w plikach również ma znaczenie. Generalnie te reguły
obecne wyżej w danym pliku mają pierwszeństwo przed tymi obecnymi w dalszej części pliku. Dlatego
też te bardziej specyficzne reguły trzeba umieścić na początku, a te bardziej rozległe na końcu
pliku.</p>
<h3 id="logowanie-reguł">Logowanie reguł</h3>
<p>Przy tworzeniu polityki dla PolicyKit warto jest zaprzęgnąć do pracy jego mechanizm logujący. W tak
powstałym logu będą dostępne wszystkie informacje, które będziemy w stanie wykorzystać przy pisaniu
reguł. Niemniej jednak, ten mechanizm logujący trzeba pierw włączyć, a robi się to przez stworzenie
pliku <code>00-log-access.rules</code> w katalogu <code>/etc/polkit-1/rules.d/</code> i dodanie do niego poniższej treści:</p>
<pre><code>polkit.addRule(function(action, subject) {
    polkit.log(&quot;action=&quot; + action);
    polkit.log(&quot;subject=&quot; + subject);
});
</code></pre>
<p>Od tej pory za każdym razem jak tylko mechanizm PolicyKit zadziała w jakiś sposób, to będzie
generował stosowny komunikat w logu.</p>
<h4 id="usunięcie-flagi---no-debug">Usunięcie flagi --no-debug</h4>
<p>Od jakiegoś czasu, demon <code>polkitd</code> jest wywoływany z flagą <code>--no-debug</code> za sprawą usługi systemd
zlokalizowanej w pliku <code>/usr/lib/systemd/system/polkit.service</code> . By być w stanie skorzystać z tej
powyższej regułki i zobaczyć logi w terminalu, musimy tę flagę <code>--no-debug</code> usunąć. Robimy to
edytując plik usługi:</p>
<pre><code># systemctl edit polkit.service
</code></pre>
<p>Po czym dopisujemy tę poniższą zawartość:</p>
<pre><code>[Service]
ExecStart=
ExecStart=/usr/lib/polkit-1/polkitd
</code></pre>
<p>Tę powyższą zawartość możemy też zapisać bezpośrednio w pliku
<code>/etc/systemd/system/polkit.service.d/override.conf</code> , tylko w takim przypadku trzeba też wydać to
poniższe polecenie:</p>
<pre><code># systemctl daemon-reload
</code></pre>
<h3 id="domyślne-blokowanie-montowania-zasobów">Domyślne blokowanie montowania zasobów</h3>
<p>Stwórzmy sobie jeszcze jeden plik w katalogu <code>/etc/polkit-1/rules.d/</code> , tj. <code>20-udisks2.rules</code> . Z
racji, że nie chcemy aby każdy użytkownik miał możliwość montować dowolny nośnik w naszym systemie,
to dodajemy na końcu tego utworzonego wyżej pliku taki oto kod:</p>
<pre><code>polkit.addRule(function(action) {
  if (action.id.indexOf(&quot;org.freedesktop.udisks2.&quot;) == 0) {
        return polkit.Result.NO;
      }
});
</code></pre>
<p>Mówi on w zasadzie tyle, że jeśli jakiś użytkownik będzie próbował przeprowadzić akcję, której <code>id</code>
zaczyna się od <code>org.freedesktop.udisks2.</code> , to PolicyKit ma zwrócić <code>NO</code> , co oznacza brak
autoryzacji.</p>
<p>Jeśli byśmy w takiej sytuacji spróbowali zamontować system plików jakiegoś pendrive czy dysku
twardego, który podłączyliśmy do portu USB, to przywita nas taki oto komunikat:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2019/04/001-udisks-udisks2-polkit-policykit-linux-debian-hdd-pendrive-deny-mount.png" alt="udisks-udisks2-polkit-policykit-linux-debian-hdd-pendrive-deny-mount"    class="small"></p>
<p>Z kolei gdybyśmy skorzystali z <code>return polkit.Result.AUTH_ADMIN;</code> , to byśmy zobaczyli poniższe
okienko, w którym trzeba by podać hasło:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2019/04/002-udisks-udisks2-polkit-policykit-linux-debian-hdd-pendrive-auth-mount.png" alt="udisks-udisks2-polkit-policykit-linux-debian-hdd-pendrive-auth-mount"    class="medium"></p>
<p>Jeśli zawartość pliku <code>/etc/polkit-1/rules.d/40-debian-sudo.rules</code> zostanie wykomentaowana, to
wtedy będziemy proszeni o hasło użytkownika root. W przeciwnym wypadku członkowie grupy <code>sudo</code>
będą pytani o ich własne hasło, by potwierdzić swoją tożsamość.</p>
<p>Zatem dodając ten powyższy kod blokujemy użytkownikom możliwość korzystania z akcji UDisks.</p>
<p>W logu systemowym zaś przy próbie montowania zasobu możemy wyczytać te poniższe wiadomości:</p>
<pre><code>Apr 25 18:43:46 morfikownia polkitd[2457]: /etc/polkit-1/rules.d/00-log-access.rules:2:
  action=[Action id='org.freedesktop.udisks2.filesystem-mount' id.usage='filesystem'
  drive.serial='D57CA0A36079' id.label='ntfs_data' partition.flags='0x00000000'
  polkit.gettext_domain='udisks2' drive.removable.bus='usb' drive='Kingston DataTraveler 3.0 (/dev/sdc2)'
  partition.number='2' id.uuid='4CF875EB65AC2B02' partition.uuid='208bbb20-01'
  drive.vendor='Kingston' device='/dev/sdc2' id.type='ntfs' partition.type='0x07'
  polkit.message='Authentication is required to mount $(drive)' drive.revision='AB51'
  drive.model='DataTraveler 3.0' drive.removable='true']

Apr 25 18:43:46 morfikownia polkitd[2457]: /etc/polkit-1/rules.d/00-log-access.rules:3:
  subject=[Subject pid=1928 user='morfik'
  groups=morfik,sudo,audio,dip,video,plugdev,systemd-journal,bluetooth,scanner,dane,p2p,docker,wireshark,wheel
  seat='seat0' session='4' local=true active=true]
</code></pre>
<p>Widzimy kto i kiedy próbował skorzystać z jakich akcji UDisks. Widoczne są też parametry
montowanego urządzenia oraz trochę dodatkowych informacji o samym użytkowniku.</p>
<h3 id="zezwolenie-użytkownikom-na-montowanie-zasobów">Zezwolenie użytkownikom na montowanie zasobów</h3>
<p>Obecnie po zaaplikowaniu tej powyższej reguły sytuacja nie różni się niczym od zaprzęgania root'a
do zamontowania systemu plików jakiejś partycji. Użytkowników, którzy powinni mieć prawo montować
zasoby w systemie, trzeba potraktować nieco bardziej ulgowo. Trzeba zatem dorobić kilka wyjątków,
poniżej przykład:</p>
<pre><code>polkit.addRule(function(action, subject) {
  if (action.id.indexOf(&quot;org.freedesktop.udisks2.filesystem-mount&quot;) == 0 &amp;&amp;
      subject.local &amp;&amp; subject.active &amp;&amp;
      subject.user == &quot;morfik&quot;) {
        return polkit.Result.YES;
      }
});
</code></pre>
<p>Ta powyższa zwrotka zezwoli lokalnemu użytkownikowi <code>morfik</code> w sesji aktywnej na skorzystanie z
akcji <code>org.freedesktop.udisks2.filesystem-mount</code> , która umożliwia zamontowanie systemu plików
dowolnego nośnika podłączonego do komputera. Ten użytkownik będzie również w stanie odmontować
zasoby ale tylko te, które sam zamontował. Wszystko co zamontuje sobie <code>morfik</code> będzie dostępne w
katalogu <code>/media/morfik/</code> .</p>
<p>Możliwe jest także zacieśnienie polityki, tak by konkretny użytkownik był w stanie montować tylko i
wyłącznie określone urządzenia w systemie. Dla przykładu:</p>
<pre><code>polkit.addRule(function(action, subject) {
  if (action.id.indexOf(&quot;org.freedesktop.udisks2.filesystem-mount&quot;) == 0 &amp;&amp;
      action.lookup(&quot;drive.serial&quot;) == &quot;D57CA0A36079&quot; &amp;&amp;
      action.lookup(&quot;id.type&quot;) == &quot;ntfs&quot; &amp;&amp;
      action.lookup(&quot;id.uuid&quot;) == &quot;4CF875EB65AC2B02&quot; &amp;&amp;
      action.lookup(&quot;partition.uuid&quot;) == &quot;208bbb20-01&quot; &amp;&amp;
      subject.local &amp;&amp; subject.active &amp;&amp;
      subject.user == &quot;morfik&quot;) {
        return polkit.Result.YES;
      }
});
</code></pre>
<p>Dopasowań w <code>action.lookup</code> można określić ile się chce. Im ich będzie więcej, tym bardziej
specyficzna reguła. W tym przypadku musi się zgadzać numer seryjny urządzenia, typ systemu plików,
numer UUID systemu plików oraz numer UUID partycji. Jeśli któraś z tych wartości będzie inna, np.
urządzenie zostanie sformatowane nowym systemem plików, to użytkownik już nie będzie w stanie
zamontować takiego urządzenia. <a href="http://storaged.org/doc/udisks2-api/latest/udisks-polkit-actions.html">Pełna lista atrybutów</a>, na podstawie których można próbować
dopasować urządzenie, znajduje się tutaj.</p>
<p>W logu, który zostanie wygenerowany podczas montowania urządzenia, te wszystkie wartości potrzebne
by dopasować urządzenie będą wynotowane. Można zatem bez problemu skopiować je sobie i uzupełnić
wedle potrzeby.</p>
<h2 id="nośniki-systemowe-vs-niesystemowe">Nośniki systemowe vs. niesystemowe</h2>
<p>UDisks rozróżnia pamięć masową i dzieli ją na systemową oraz niesystemową. Ten pierwszy rodzaj
pamięci masowej, to zwykle są dyski HDD/SSD, np. ten, na którym mamy zainstalowany system.
Natomiast drugi rodzaj pamięci dotyczy urządzeń podpinanych do portu USB (pendrive czy też karty
SD), które można odłączyć w dowolnym czasie podczas pracy systemu komputera. UDisks jest w stanie
rozróżnić te dwa typy pamięci w oparciu o <code>ATTR{removable}</code> , który można wyciągnąć przez
<code>udevadm</code> :</p>
<pre><code># udevadm info --attribute-walk --name /dev/sdc

  looking at device '/devices/pci0000:00/0000:00:1d.0/usb2/2-1/2-1.3/2-1.3:1.0/host4/target4:0:0/4:0:0:0/block/sdc':
    ...
    ATTR{removable}==&quot;1&quot;
    ...
</code></pre>
<p>Jeśli <code>ATTR{removable}</code> ma wartość <code>0</code> to mamy do czynienia z dyskiem systemowym, jeśli zaś
widnieje tam wartość <code>1</code> , to z pamięcią przenośną. Warto sobie z tego faktu zdawać sprawę, bo
UDisks ma dwie osobne akcje <code>org.freedesktop.udisks2.filesystem-mount</code> oraz
<code>org.freedesktop.udisks2.filesystem-mount-system</code> w zależności od tego czy chcemy montować pamięć
przenośną czy systemową.</p>
<h2 id="automatyczne-montowanie-podłączonych-dysków">Automatyczne montowanie podłączonych dysków</h2>
<p>Wypadałoby jeszcze wspomnieć o możliwości automatycznego montowania systemu plików podłączanych
urządzeń. W takiej sytuacji po podłączeniu pendrive czy innego dysku USB, jego system plików
automatycznie zostanie zamontowany. Niemniej jednak, sam UDisks nie realizuje automatycznego
montowania zasobów -- one muszą być montowane za pomocą jakiegoś zewnętrznego mechanizmu i zwykle
menadżery plików (czy inne częci środowiska graficznego) go oferują. Tak czy inaczej, istnieje
także dedykowane narzędzie do tego celu, tj. <code>udiskie</code> (taki frontend dla UDisks).</p>
<p>Mechanizm automatycznego montowania nośników działa w oparciu o zmienne środowiskowe UDEV'a, są
m.in. <code>ENV{UDISKS_IGNORE}</code> , <code>ENV{UDISKS_AUTO}</code> oraz <code>ENV{UDISKS_SYSTEM}</code> . Wartości tych zmiennych
można podejrzeć w wyjściu <code>udisksctl</code> :</p>
<pre><code>$ udisksctl info -b /dev/sdc2
/org/freedesktop/UDisks2/block_devices/sdc2:
  org.freedesktop.UDisks2.Block:
    ...
    HintAuto:                   true
    HintIgnore:                 false
    HintSystem:                 false
    ...
</code></pre>
<p>Domyślnie włączone jest automatyczne montowanie nośników i jeśli nam ten fakt przeszkadza, to
możemy powstrzymać nasz system przed tego typu zachowaniem. Wystarczy, że dorobimy jedną prostą
regułę dla UDEV'a. Tworzymy zatem w katalogu <code>/etc/udev/rules.d/</code> plik <code>99-udisks2-automount.rules</code>
i dodajemy w nim poniższą zawartość:</p>
<pre><code>SUBSYSTEMS==&quot;usb&quot;, \
  ENV{UDISKS_AUTO}=&quot;0&quot;, \
  ENV{UDISKS_IGNORE}=&quot;1&quot;
</code></pre>
<p>Generalnie rzecz biorąc, to zmienna <code>ENV{UDISKS_IGNORE}</code> informuje aplikacje, że mają one dany
zasób zignorować. W tym przypadku dopasowanie jest po interfejsie USB, zatem wszystkie urządzenia
USB będą przez aplikacje ignorowane. Oczywiście jeśli chcemy, aby tylko określone dyski USB były
montowane automatycznie, to naturalnie trzeba by napisać im osobne reguły określając przy tym
dopasowanie na podstawie <code>ATTRS{idProduct}</code> oraz <code>ATTRS{idVendor}</code>. Teoretycznie nie powinno się
korzystać ze zmiennej <code>ENV{UDISKS_IGNORE}</code> w przypadku zasobów, które powinny być widoczne w
aplikacjach, a jeśli nie chcemy montować ich automatycznie to powinno się korzystać ze zmiennej
<code>ENV{UDISKS_AUTO}</code> . Niemniej jednak, w przypadku mojego systemu zmienna <code>ENV{UDISKS_AUTO}</code> nie
działa i dlatego musiałem się posłużyć tą drugą zmienną. Można też ustawić nośnikom wymiennym
zmienną <code>ENV{UDISKS_SYSTEM}</code> , która przerobi nośniki przenośne na systemowe i tym samym sprawi, że
UDisks ich nie będzie automatycznie montował.</p>
<p>Po dodaniu reguły trzeba jeszcze przeładować konfigurację UDEV'a:</p>
<pre><code># udevadm control --reload
</code></pre>
<p>Od tego momentu nasz system powinien zaprzestać automatycznie montować zewnętrzne nośniki
podłączane do portu USB.</p>
<h2 id="usbguard-vs-udisks--policykit">USBguard vs. UDisks + PolicyKit</h2>
<p>Jakiś już czas temu <a href="https://morfikov.github.io/post/jak-przy-pomocy-usbguard-zabezpieczyc-porty-usb-przed-zlosliwymi-urzadzeniami/">opisywałem mechanizm USBguard</a>, który był poświęcony zagadnieniu ochrony
portów USB przed niezbyt przyjaznymi urządzeniami. Teraz mamy jeszcze opcję w postaci PolicyKit +
UDisks. Które z tych dwóch rozwiązań jest lepsze?</p>
<p>No jakby nie patrzeć, to UDisks + PolicyKit ogranicza się jedynie do szeroko rozumianej pamięci
masowej. Ten mechanizm jest w stanie wyprofilować system w taki sposób, by konkretni użytkownicy
mieli możliwość montować jedynie określone nośniki pamięci. Jeśli zaś chodzi o USBguard, to on z
kolei chroni nasz system przed każdym urządzeniem USB, a nie tylko tymi wyposażonymi w pamięć
masową. Dodatkowo USBguard działa w warstwie niższej i jest w stanie uniemożliwić kernelowi
komunikację z takim urządzeniem (dobór modułu). Te dwa mechanizmy (albo raczej trzy) uzupełniają
się wzajemnie i w mojej ocenie stanowią ideale połączenie, które jest w stanie ochronić nasz system
przed chyba wszystkimi atakami z udziałem pamięci masowej podłączanej do portów USB.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/debian/">debian</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/udisks/">udisks</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/policykit/">policykit</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/hdd/">hdd</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/ssd/">ssd</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/usb/">usb</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f&amp;text=Montowanie%20dysk%c3%b3w%20jako%20zwyk%c5%82y%20u%c5%bcytkownik%20z%20UDisks%20i%20PolicyKit" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f&amp;title=Montowanie%20dysk%c3%b3w%20jako%20zwyk%c5%82y%20u%c5%bcytkownik%20z%20UDisks%20i%20PolicyKit" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f&amp;title=Montowanie%20dysk%c3%b3w%20jako%20zwyk%c5%82y%20u%c5%bcytkownik%20z%20UDisks%20i%20PolicyKit" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f&title=Montowanie%20dysk%c3%b3w%20jako%20zwyk%c5%82y%20u%c5%bcytkownik%20z%20UDisks%20i%20PolicyKit" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f&amp;title=Montowanie%20dysk%c3%b3w%20jako%20zwyk%c5%82y%20u%c5%bcytkownik%20z%20UDisks%20i%20PolicyKit" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fmontowanie-dyskow-jako-zwykly-uzytkownik-z-udisks-i-policykit%2f&description=Montowanie%20dysk%c3%b3w%20jako%20zwyk%c5%82y%20u%c5%bcytkownik%20z%20UDisks%20i%20PolicyKit" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/badsector-dysku-hdd-w-kontenerze-luks-zawierajacym-lvm/">Badsector dysku HDD w kontenerze LUKS zawierającym LVM</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-optymalnie-podzielic-dysk-hdd-ssd-na-partycje-pod-linux/">Jak optymalnie podzielić dysk HDD/SSD na partycje pod linux</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-przy-pomocy-usbguard-zabezpieczyc-porty-usb-przed-zlosliwymi-urzadzeniami/">Jak przy pomocy USBguard zabezpieczyć porty USB przed złośliwymi urządzeniami</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-ukryc-zaszyfrowany-kontener-luks-pod-linux/">Jak ukryć zaszyfrowany kontener LUKS pod linux</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/dysk-pendrive-inne-nosniki-pod-openwrt/">Dysk, pendrive i inne nośniki pod OpenWRT</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/backup-dysku-przez-siec-przy-pomocy-dd-netcat/">Backup dysku przez sieć przy pomocy dd i netcat</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-dodac-nowy-dysk-lvm/">Jak dodać nowy dysk do LVM</a></li>
		
	</ul>
</div>

	<div id="comments">
		<script src="https://utteranc.es/client.js"
        repo="morfikov/morfitronik-comments"
        issue-term="og:title"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>

	</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2024 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
const images = Array.from(document.querySelectorAll(".entry__content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null,  
    background: 'rgba(0, 0, 0, 0.8)'
  });
});
</script>
</body>
</html>
