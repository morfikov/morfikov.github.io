<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Konfiguracja serwera XMPP/Jabber pod linux (ejabberd) | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Konfiguracja serwera XMPP/Jabber pod linux (ejabberd)" />
<meta property="og:description" content="Użytkownicy internetu mają całą masę różnych sposobów na komunikację miedzy sobą. Kiedyś wszyscy
korzystali z komunikatorów typu Gadu-Gadu. Ja byłem jedyną osobą, która od samego początku wolała
alternatywne rozwiązania i jechałem na komunikatorze Tlen (ten od O2), a w niedługim czasie
przesiadłem się na Jabber&#39;a i tak z niego korzystam do dziś. W zasadzie GG i Tlen są obecnie już
chyba na wymarciu, bo większość ludzi (jak nie wszyscy) przerzuciła się na Facebook&#39;a czy Twitter&#39;a.
Niemniej jednak, pisanie o sprawach prywatnych w tych serwisach nie jest najlepszym rozwiązaniem.
Jeśli chcemy zadbać o poufność przesyłanych przez internet komunikatów, to trzeba to robić na inne
sposoby. Jednym z nich jest właśnie korzystanie z protokołu XMPP/Jabber. To co odróżnia
Jabber&#39;a od innych technologii na rynku, to fakt zdecentralizowania sieci, czyli mamy całą masę
serwerów Jabber&#39;a, na których możemy sobie stworzyć konto. Uwalenie jednego serwera nie wpływa na
działanie pozostałych. Google także wykorzystuje protokół XMPP/Jabber i mając konto na gmail&#39;u,
mamy również stosowny JID w postaci adresu email, który możemy sobie wklepać do jednego z klientów
Jabber&#39;a, np. PSI czy Gajim, i jesteśmy już w stanie rozmawiać z osobami, które mają konta na
innych serwerach. Właśnie, inne serwery, a może by tak sobie postawić własny serwer Jabber&#39;a? Tak
się składa, że w repozytorium Debiana znajduje się oprogramowanie ejabberd, które jest nam w
stanie umożliwić realizację tego przedsięwzięcia." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/konfiguracja-serwer-xmpp-jabber-linux-ejabberd/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2017-03-20T20:26:15&#43;00:00" />
<meta property="article:modified_time" content="2017-03-20T20:26:15&#43;00:00" />


		<meta itemprop="name" content="Konfiguracja serwera XMPP/Jabber pod linux (ejabberd)">
<meta itemprop="description" content="Użytkownicy internetu mają całą masę różnych sposobów na komunikację miedzy sobą. Kiedyś wszyscy
korzystali z komunikatorów typu Gadu-Gadu. Ja byłem jedyną osobą, która od samego początku wolała
alternatywne rozwiązania i jechałem na komunikatorze Tlen (ten od O2), a w niedługim czasie
przesiadłem się na Jabber&#39;a i tak z niego korzystam do dziś. W zasadzie GG i Tlen są obecnie już
chyba na wymarciu, bo większość ludzi (jak nie wszyscy) przerzuciła się na Facebook&#39;a czy Twitter&#39;a.
Niemniej jednak, pisanie o sprawach prywatnych w tych serwisach nie jest najlepszym rozwiązaniem.
Jeśli chcemy zadbać o poufność przesyłanych przez internet komunikatów, to trzeba to robić na inne
sposoby. Jednym z nich jest właśnie korzystanie z protokołu XMPP/Jabber. To co odróżnia
Jabber&#39;a od innych technologii na rynku, to fakt zdecentralizowania sieci, czyli mamy całą masę
serwerów Jabber&#39;a, na których możemy sobie stworzyć konto. Uwalenie jednego serwera nie wpływa na
działanie pozostałych. Google także wykorzystuje protokół XMPP/Jabber i mając konto na gmail&#39;u,
mamy również stosowny JID w postaci adresu email, który możemy sobie wklepać do jednego z klientów
Jabber&#39;a, np. PSI czy Gajim, i jesteśmy już w stanie rozmawiać z osobami, które mają konta na
innych serwerach. Właśnie, inne serwery, a może by tak sobie postawić własny serwer Jabber&#39;a? Tak
się składa, że w repozytorium Debiana znajduje się oprogramowanie ejabberd, które jest nam w
stanie umożliwić realizację tego przedsięwzięcia."><meta itemprop="datePublished" content="2017-03-20T20:26:15&#43;00:00" />
<meta itemprop="dateModified" content="2017-03-20T20:26:15&#43;00:00" />
<meta itemprop="wordCount" content="3400">
<meta itemprop="keywords" content="debian,xmpp,jabber," />
		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Konfiguracja serwera XMPP/Jabber pod linux (ejabberd)"/>
<meta name="twitter:description" content="Użytkownicy internetu mają całą masę różnych sposobów na komunikację miedzy sobą. Kiedyś wszyscy
korzystali z komunikatorów typu Gadu-Gadu. Ja byłem jedyną osobą, która od samego początku wolała
alternatywne rozwiązania i jechałem na komunikatorze Tlen (ten od O2), a w niedługim czasie
przesiadłem się na Jabber&#39;a i tak z niego korzystam do dziś. W zasadzie GG i Tlen są obecnie już
chyba na wymarciu, bo większość ludzi (jak nie wszyscy) przerzuciła się na Facebook&#39;a czy Twitter&#39;a.
Niemniej jednak, pisanie o sprawach prywatnych w tych serwisach nie jest najlepszym rozwiązaniem.
Jeśli chcemy zadbać o poufność przesyłanych przez internet komunikatów, to trzeba to robić na inne
sposoby. Jednym z nich jest właśnie korzystanie z protokołu XMPP/Jabber. To co odróżnia
Jabber&#39;a od innych technologii na rynku, to fakt zdecentralizowania sieci, czyli mamy całą masę
serwerów Jabber&#39;a, na których możemy sobie stworzyć konto. Uwalenie jednego serwera nie wpływa na
działanie pozostałych. Google także wykorzystuje protokół XMPP/Jabber i mając konto na gmail&#39;u,
mamy również stosowny JID w postaci adresu email, który możemy sobie wklepać do jednego z klientów
Jabber&#39;a, np. PSI czy Gajim, i jesteśmy już w stanie rozmawiać z osobami, które mają konta na
innych serwerach. Właśnie, inne serwery, a może by tak sobie postawić własny serwer Jabber&#39;a? Tak
się składa, że w repozytorium Debiana znajduje się oprogramowanie ejabberd, które jest nam w
stanie umożliwić realizację tego przedsięwzięcia."/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Konfiguracja serwera XMPP/Jabber pod linux (ejabberd)</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2017-03-20T20:26:15Z">Opublikowano: 20/03/2017</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Konfiguracja serwera XMPP/Jabber pod linux (ejabberd)</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#zalety-posiadania-własnego-serwera-jabbera">Zalety posiadania własnego serwera Jabber'a</a></li>
    <li><a href="#instalacja-i-konfiguracja-serwera-ejabberd">Instalacja i konfiguracja serwera ejabberd</a>
      <ol>
        <li><a href="#subdomena">Subdomena</a></li>
        <li><a href="#rekord-srv">Rekord SRV</a></li>
        <li><a href="#certyfikat-lets-encrypt">Certyfikat Let's Encrypt</a></li>
        <li><a href="#firewall-i-reguły-iptables">Firewall i reguły iptables</a>
          <ol>
            <li><a href="#czarna-lista-adresów-ip">Czarna lista adresów IP</a></li>
            <li><a href="#limitowanie-połączeń">Limitowanie połączeń</a></li>
          </ol>
        </li>
        <li><a href="#plik-ejabberdyml">Plik ejabberd.yml</a></li>
      </ol>
    </li>
    <li><a href="#test-konfiguracji-serwera-jabbera">Test konfiguracji serwera Jabber'a</a></li>
    <li><a href="#tworzenie-kont-użytkownikom-i-podłączenia-do-serwera">Tworzenie kont użytkownikom i podłączenia do serwera</a></li>
    <li><a href="#zmiana-adresu-i-zabezpieczenie-panelu-admina">Zmiana adresu i zabezpieczenie panelu admina</a></li>
    <li><a href="#baza-danych-mysqlmariadb">Baza danych MySQL/MariaDB</a></li>
    <li><a href="#dalsza-konfiguracja-serwera-jabbera">Dalsza konfiguracja serwera Jabber'a</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Użytkownicy internetu mają całą masę różnych sposobów na komunikację miedzy sobą. Kiedyś wszyscy
korzystali z komunikatorów typu Gadu-Gadu. Ja byłem jedyną osobą, która od samego początku wolała
alternatywne rozwiązania i jechałem na komunikatorze Tlen (ten od O2), a w niedługim czasie
przesiadłem się na Jabber'a i tak z niego korzystam do dziś. W zasadzie GG i Tlen są obecnie już
chyba na wymarciu, bo większość ludzi (jak nie wszyscy) przerzuciła się na Facebook'a czy Twitter'a.
Niemniej jednak, pisanie o sprawach prywatnych w tych serwisach nie jest najlepszym rozwiązaniem.
Jeśli chcemy zadbać o poufność przesyłanych przez internet komunikatów, to trzeba to robić na inne
sposoby. Jednym z nich jest właśnie korzystanie z <a href="https://xmpp.org/">protokołu XMPP/Jabber</a>. To co odróżnia
Jabber'a od innych technologii na rynku, to fakt zdecentralizowania sieci, czyli mamy całą masę
serwerów Jabber'a, na których możemy sobie stworzyć konto. Uwalenie jednego serwera nie wpływa na
działanie pozostałych. Google także wykorzystuje protokół XMPP/Jabber i mając konto na gmail'u,
mamy również stosowny JID w postaci adresu email, który możemy sobie wklepać do jednego z klientów
Jabber'a, np. <a href="https://xmpp.org/software/clients.html">PSI czy Gajim</a>, i jesteśmy już w stanie rozmawiać z osobami, które mają konta na
innych serwerach. Właśnie, inne serwery, a może by tak sobie postawić własny serwer Jabber'a? Tak
się składa, że w repozytorium Debiana znajduje się <a href="https://www.ejabberd.im/">oprogramowanie ejabberd</a>, które jest nam w
stanie umożliwić realizację tego przedsięwzięcia.</p>
<h2 id="zalety-posiadania-własnego-serwera-jabbera">Zalety posiadania własnego serwera Jabber'a</h2>
<p>Protokół XMPP/Jabber jest protokołem otwartym i darmowym, tzn. każdy z nas może z niego korzystać
bez potrzeby kupowania jakichś licencji czy wnoszenia opłat. Komunikacja w tym protokole może być
szyfrowana na linii klient-serwer lub/i serwer-serwer. To czy tak w istocie, zależy od kilku
czynników, min. od konfiguracji serwera na którym mamy konto, a mając własny serwer mamy też pełnię
władzy nad jego konfiguracją.</p>
<p>Komunikacja klientów z serwerem może odbywać się w zasadzie na dwóch portach. Standardowo jest to
port <code>5222</code> . We wcześniejszych wersjach oprogramowania Jabber'a był używany port <code>5223</code> ale obecnie
jest on uważany za przestarzały i się go już nie stosuje, przynajmniej nie jest to zalecane. Różnica
między tymi dwoma portami tkwi głównie w nawiązywaniu szyfrowanego połączenia między klientem a
serwerem. W przypadku portu <code>5222</code> ruch może nie być w ogóle szyfrowany lub też wykorzystywana jest
<a href="https://en.wikipedia.org/wiki/Opportunistic_TLS">metoda STARTTLS</a> (zwykle ta opcja jest spotykana). Natomiast jeśli chodzi o port <code>5223</code> , to
tutaj używany jest klasyczny SSL/TLS, z którym mamy do czynienia przeglądając, np. strony WWW po
HTTPS.</p>
<p>Nie wszystkie serwery Jabber'a równają do najwyższych standardów bezpieczeństwa. Część z serwerów
może obsługiwać jedynie słabe szyfry, np. SSLv2 czy SSLv3, których stosowanie zagraża
bezpieczeństwu serwera i prywatności jego użytkowników. Nawet jeśli serwer wymusza od swoich
klientów negocjowanie szyfrów TLSv1.2, to i tak nie daje to 100% odporności na próby przechwycenia
komunikacji.</p>
<p>Gdy klienci mają konto na tym samym serwerze, to ruch między nimi zawsze będzie szyfrowany i tutaj
decyduje tylko i wyłącznie konfiguracja tego konkretnego serwera. W przypadku, gdy konta są na
różnych serwerach, to wiadomości między serwerami mogą podróżować w formie niezaszyfrowanej.
Dzieje się tak dlatego, że serwery muszą między sobą wynegocjować parametry dla połączenia. Jeśli
jeden z nich nie wspiera szyfrowania, lub oferuje jedynie słabe szyfry, to mamy do wyboru albo
przystać na takie warunki i stosować te słabe szyfry (lub w ogóle ich nie stosować), albo też
serwery te nie nawiążą połączenia i komunikacja nie będzie w ogóle możliwa.</p>
<p>Przykładem takiego serwera, który nie chce współpracować z wymuszonym szyfrowaniem jest ten od
Google (adresy GMAIL). W przypadku tego typu serwerów możemy naturalnie wykorzystać
<a href="https://pl.wikipedia.org/wiki/Off-the-record_messaging">OTR</a> (Off-The-Record messaging) czy <a href="https://pl.wikipedia.org/wiki/GNU_Privacy_Guard">klucze szyfrujące PGP/GPG</a>, by we własnym zakresie
zabezpieczyć komunikację. Problem w tym, że jest to mało wygodne. Może i OTR dość znacznie ułatwia
cały proces ale i tak wymaga od użytkownika przeprowadzenia kilku dodatkowych czynności. A w
przypadku posiadania własnego serwera Jabber'a (z wymuszonym TLSv1.2) w zasadzie nie trzeba robić
nic więcej, by ruch zaszyfrować, przynajmniej w przypadku użytkowników mających konto na naszym
serwerze. Oczywiście w dalszym ciągu możemy wykorzystać OTR czy klucze PGP/GPG jako dodatkową
warstwę zabezpieczającą.</p>
<h2 id="instalacja-i-konfiguracja-serwera-ejabberd">Instalacja i konfiguracja serwera ejabberd</h2>
<p>W dystrybucji Debian jest dostępny pakiet <code>ejabberd</code> oraz również kilka pakietów z różnymi modułami
<code>ejabberd-mod-*</code> . W stabilnym wydaniu, te pakiety są w dość leciwej wersji (14.07). Dlatego też
lepiej <a href="https://backports.debian.org/Instructions/">dodać sobie repozytorium Debian backports</a> i to z niego zainstalować stosowne pakiety,
bo tutaj mamy wersję 16.09 .</p>
<p>Po zainstalowaniu pakietu <code>ejabberd</code> , w katalogu <code>/etc/ejabberd/</code> zostanie utworzony plik
<code>ejabberd.yml</code> . W tym pliku znajduje się konfiguracja naszego serwera Jabber'a. Niemniej jednak,
zanim przejdziemy do edycji tego pliku, musimy zrobić kilka innych rzeczy.</p>
<h3 id="subdomena">Subdomena</h3>
<p>Morfitronik jest hostowany na OVH i jego domena to <code>morfitronik.pl</code> . Serwer Jabber'a będzie zaś
podpięty pod subdomenę <code>jabber.morfitronik.pl</code> . Tę subdomenę trzeba pierw stworzyć, tj. dodać
stosowny rekord A/AAAA w konfiguracji DNS. Można się spotkać z informacją, że zamiast tworzyć osobny
rekord A/AAAA dla subdomeny, lepiej jest utworzyć rekord CNAME i tam określić docelowy adres. Z tego
<a href="https://prosody.im/doc/dns">co znalazłem na sieci</a> wynika, że późniejsze wskazanie w rekordzie SRV docelowego adresu z
CNAME będzie powodować problemy i tak jest w przypadku OVH:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/000-0.jabber-ejabberd-serwer-debian-linux-cname-problem.png" alt=""    class="huge"></p>
<p>Dlatego też ja stworzyłem sobie osobny rekord A/AAAA zamiast CNAME.</p>
<p>Zarządzanie rekordami DNS może wyglądać inaczej u różnych DNS provider'ów. Niemniej jednak, dla
przykładu opiszę jak to wygląda w przypadku panelu webowego OVH. Udajmy się zatem do panelu
administracyjnego i przejdźmy na zakładkę <code>WWW</code> .</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/000-1.jabber-ejabberd-serwer-debian-linux-ovh-domena.png" alt=""    class="small"></p>
<p>Po wybraniu domeny, pojawią nam się informacje ogólne dotyczące konfiguracji. Mamy tam też min.
zakładkę <code>Strefa DNS</code> . Po przejściu na nią, po prawej stronie będziemy mieć poniższe przyciski:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/001.jabber-ejabberd-serwer-debian-linux-dns-przyciski.png" alt=""    class="huge"></p>
<p>Klikamy naturalnie w <code>Dodaj wpis</code> , a następnie wybieramy rodzaj pola DNS i tu wskazujemy <code>A</code> dla
IPv4 lub/i <code>AAAA</code> dla IPv6:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/002.jabber-ejabberd-serwer-debian-linux-dns-rekord-a.png" alt=""    class="big"></p>
<p>Określamy subdomenę na <code>jabber</code> oraz wskazujemy adres docelowy:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/003.jabber-ejabberd-serwer-debian-linux-dns-rekord-subdomena.png" alt=""    class="big"></p>
<p>Akceptujemy i powinniśmy ujrzeć poniższe podsumowanie:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/004.jabber-ejabberd-serwer-debian-linux-dns-rekord-subdomena.png" alt=""    class="big"></p>
<p>Niżej jest jeszcze tekstowa wersja wpisu, gdyby ktoś chciał ręcznie go dodać w konfiguracji DNS:</p>
<pre><code>jabber.morfitronik.pl IN A  151.80.57.162
</code></pre>
<h3 id="rekord-srv">Rekord SRV</h3>
<p>Mamy zatem skonfigurowaną subdomenę. Teraz musimy jeszcze dodać rekordy SRV. Rekord SRV umożliwia
transparentne przekierowanie zapytań na inną domenę lub port, czyli tam, gdzie znajduje się usługa.
W naszym przypadku będzie to subdomena <code>jabber.morfitronik.pl</code> .</p>
<p>W przypadku protokołu XMPP/Jabber <a href="https://wiki.xmpp.org/web/SRV_Records">jest kilka typów rekordów SRV</a>. Nas interesują
client-to-server (c2s) oraz server-to-server (s2s). W ten sposób klienci używają rekordu c2s,
natomiast inne serwery używają rekordu s2s i wiedzą na jakie porty słać zapytania. Standardowe
porty dla protokołu XMPP/Jabber to: 5222 (XMPP client connection (RFC 6120)) oraz 5269 (XMPP server
connection (RFC 6120)). To właśnie te dwa porty musimy podać w konfiguracji DNS wskazując
jednocześnie subdomenę <code>jabber.morfitronik.pl</code> .</p>
<p>Ponownie odwiedzamy panel OVH i dodajemy kolejny wpis. Tym razem wybieramy jedno z pól
rozszerzonych, tj. <code>SRV</code> :</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/006.jabber-ejabberd-serwer-debian-linux-dns-rekord-srv.png" alt=""    class="big"></p>
<p>I uzupełniamy tak jak to widać na poniższym obrazku:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/007.jabber-ejabberd-serwer-debian-linux-dns-rekord-srv-konfiguracja.png" alt=""    class="big"></p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/008.jabber-ejabberd-serwer-debian-linux-dns-rekord-srv-konfiguracja.png" alt=""    class="big"></p>
<p>Podobnie postępujemy dla drugiego rekordu:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/009.jabber-ejabberd-serwer-debian-linux-dns-rekord-srv-konfiguracja.png" alt=""    class="big"></p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/010.jabber-ejabberd-serwer-debian-linux-dns-rekord-srv-konfiguracja.png" alt=""    class="big"></p>
<p>Poniżej jeszcze dodatkowo tekstowa wersja tych dwóch rekordów na wypadek, gdyby ktoś chciał ręcznie
edytować konfigurację DNS:</p>
<pre><code>_xmpp-client._tcp.morfitronik.pl. 18000 IN SRV    0 5 5222 jabber.morfitronik.pl.
_xmpp-server._tcp.morfitronik.pl. 18000 IN SRV    0 5 5269 jabber.morfitronik.pl.
</code></pre>
<p>Starsze serwery Jabber'a mogą korzystać z rekordu <code>_jabber._tcp</code> zamiast <code>_xmpp-server._tcp</code> i można
również dodać ten rekord SRV:</p>
<pre><code>_jabber._tcp.morfitronik.pl. 18000 IN SRV    0 5 5269 jabber.morfitronik.pl.
</code></pre>
<h3 id="certyfikat-lets-encrypt">Certyfikat Let's Encrypt</h3>
<p>Mając skonfigurowaną domenę oraz wiedząc, że ruch w protokole XMPP/Jabber powinien być szyfrowany,
musimy postarać się o odpowiednie certyfikaty dla naszego serwera. Te z kolei można wygenerować
sobie ręcznie, np. <a href="https://morfikov.github.io/post/generowanie-certyfikatow-przy-pomocy-easy-rsa/">przy pomocy pakietu easy-rsa</a>, ale też można skorzystać z <a href="https://letsencrypt.org/">gotowego
rozwiązania oferowanego przez Let's Encrypt</a> i my właśnie z niego skorzystamy.</p>
<p>Na Morfitroniku znajduje się już kilka usług, które zapewniają szyfrowane połączenie. Jest tutaj
zainstalowany min. serwer www. Tak się składa, że <a href="https://morfikov.github.io/post/certyfikat-letsencrypt-dla-bloga-certbot/">Let's Encrypt dostarcza już certyfikat dla tego
bloga</a>, a konkretnie dla domeny <code>morfitronik.pl</code> . Nie da rady wygenerować certyfikatu osobno
dla drugiej domeny i trzeba ten proces przeprowadzić dla obu domen jednocześnie. Robimy to w
poniższy sposób:</p>
<pre><code># certbot certonly \
    -d morfitronik.pl,www.morfitronik.pl,jabber.morfitronik.pl \
    --standalone
</code></pre>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/011.jabber-ejabberd-serwer-debian-linux-certyfikat-letsencrypt.png" alt=""    class="huge"></p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/012.jabber-ejabberd-serwer-debian-linux-certyfikat-letsencrypt.png" alt=""    class="huge"></p>
<p>Podczas generowania certyfikatu, trzeba tymczasowo wyłączyć serwer www jeśli takowy posiadamy. Warto
też wspomnieć, że ta subdomena standardowo będzie wskazywać na główny katalog serwisu. W końcu
serwer DNS odsyła zapytania pod ten sam adres IP po wywołaniu zarówno domeny jak i subdomeny. Trzeba
będzie zatem stworzyć nowego wirtualnego hosta w konfiguracji Apache2 (czy innego serwera www) i
rozdzielić w ten sposób zapytania.</p>
<p>Let's Encrypt przechowuje certyfikaty i klucze w osobnych plikach. Na potrzeby <code>ejabberd</code> trzeba dwa
z tych plików połączyć w jeden:</p>
<pre><code># cd /etc/letsencrypt/live/morfitronik.pl/
# cat privkey.pem fullchain.pem &gt; /etc/ejabberd/ejabberd.pem
</code></pre>
<p>Generujemy jeszcze plik <code>dh4096.pem</code> :</p>
<pre><code># openssl dhparam 4096 &gt; /etc/ejabberd/dh4096.pem
</code></pre>
<p>Upewnijmy się przy tym, że te powyższe pliki mają odpowiednie uprawnienia:</p>
<pre><code># chown root:ejabberd /etc/ejabberd/dh4096.pem
# chown root:ejabberd /etc/ejabberd/ejabberd.pem
# chmod 440 /etc/ejabberd/dh4096.pem
# chmod 640 /etc/ejabberd/ejabberd.pem
</code></pre>
<p>Certyfikaty Let's Encrypt są odnawiane co trzy miesiące. Przydałoby się zatem co miesiąc łączyć
pliki <code>privkey.pem</code> i <code>fullchain.pem</code> i resetować serwer Jabber'a. Jeśli tego nie uczynimy, to w
końcu nasz serwer będzie działał bez ważnego certyfikatu. To zadanie można zautomatyzować tworząc
sobie prosty skrypt i wywołując go cyklicznie przy pomocy cron'a. Poniżej jest taki skrypt:</p>
<pre><code>#!/bin/bash

cert_dir=&quot;/etc/letsencrypt/live/morfitronik.pl&quot;

systemctl stop ejabberd.service
#systemctl stop epmd.socket
systemctl stop epmd.service

cat $cert_dir/privkey.pem $cert_dir/fullchain.pem &gt; /etc/ejabberd/ejabberd.pem

chown root:ejabberd /etc/ejabberd/ejabberd.pem
chmod 640 /etc/ejabberd/ejabberd.pem

systemctl start ejabberd.service
</code></pre>
<p>A tak wygląda zadanie dla cron'a:</p>
<pre><code>27  02  1   *   *   /skrypty/ejabberd-cert.sh
</code></pre>
<h3 id="firewall-i-reguły-iptables">Firewall i reguły iptables</h3>
<p>Wiemy, że jabber będzie nasłuchiwał dwóch rodzajów połączeń na portach 5222 oraz 5269 . Są to
standardowe porty i jest niemal pewne, ze jakieś boty się do naszego serwera przyczepią. Dlatego
musimy się postarać o zabezpieczenie tej usługi przy pomocy filtra pakietów <code>iptables</code> . W zasadzie
musimy zrobić trzy rzeczy. Pierwszą z nich jest akceptowanie połączeń w stanie NEW na te ww. porty.
Drugą jest limitowanie ilości jednoczesnych połączeń dla konkretnego adresu IP. A trzecią rzeczą
jest zaimplementowanie czarnej listy adresów, która uniemożliwi pewnym osobom/botom na połączenie z
serwerem.</p>
<h4 id="czarna-lista-adresów-ip">Czarna lista adresów IP</h4>
<p>Może zacznijmy od ostatniej kwestii czyli czarnej listy adresów. Nie musimy jej budować od podstaw,
bo stosowne listy są już utrzymywane i regularnie aktualizowane. My musimy tylko te listy jakoś
wrzucić na zaporę sieciową naszego serwera. Najprościej do tego celu wykorzystać
<a href="http://ipset.netfilter.org/">ipset</a>. W dystrybucji Debian, to narzędzie jest dostępne w pakiecie <code>ipset</code> i wystarczy je
zainstalować.</p>
<p>List z adresami można poszukać na Google ale ktoś już tę pracę wykonał za nas i stworzył prosty
skrypt, który jest w stanie bardzo łatwo dodać całe zakresy adresów IP i filtrować w oparciu o nie
ruch sieciowy docierający do naszego serwera. Projekt, o którym mowa, <a href="https://github.com/trick77/ipset-blacklist">znajduje się tutaj</a>. W
tym linku mamy dokładną instrukcję obsługi tego narzędzia i raczej nie powinno być problemów z
zaimplementowaniem go w systemie. Można oczywiście sobie dostosować pewne rzeczy, np. pozycję
reguły w filtrze przenosząc ją z łańcucha INPUT w tablicy FILTER do łańcucha PREROUTING w tablicy
RAW, przez co żądania połączeń nie będą przechodzić przez sporą część samego filtra.</p>
<h4 id="limitowanie-połączeń">Limitowanie połączeń</h4>
<p>Może i czarna lista adresów została załadowana do <code>iptables</code> ale nie damy rady zbanować nią
wszystkich złych użytkowników internetu. Zawsze znajdzie się ktoś, kto będzie próbował nasz serwer
zaatakować i uzyskać do niego nieuprawniony dostęp czy wykorzystać jego zasoby w sposób
nieodpowiedni. Dlatego też drugim zabezpieczeniem jakie sobie zaimplementujemy będzie ograniczenie
ilości połączeń jakie pojedynczy klient będzie w stanie nawiązać. Do tego celu posłużą nam dwa
moduły: <a href="http://ipset.netfilter.org/iptables-extensions.man.html#lbAM">connlimit</a> oraz <a href="http://ipset.netfilter.org/iptables-extensions.man.html#lbAY">hashlimit</a>.</p>
<p>Przekierujmy sobie zatem wszystkie nowe połączenia w protokole TCP do łańcucha <code>tcp</code> :</p>
<pre><code>iptables -N tcp

iptables -A INPUT -p tcp -m tcp ! --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -m comment --comment &quot;Connections not started by SYN&quot; -j DROP
iptables -A INPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m conntrack --ctstate NEW -j tcp
</code></pre>
<p>Teraz w łańcuchu <code>tcp</code> tworzymy te dwie poniższe reguły:</p>
<pre><code>iptables -A tcp -p tcp -m tcp --dport 5222 \
    -m connlimit --connlimit-upto 20 --connlimit-mask 0 --connlimit-saddr \
    -m hashlimit --hashlimit-upto 5/min --hashlimit-burst 5 --hashlimit-mode srcip --hashlimit-name xmpp \
    -m comment --comment xmpp-client \
    -j ACCEPT

iptables -A tcp -p tcp -m tcp --dport 5269 \
    -m connlimit --connlimit-upto 20 --connlimit-mask 0 --connlimit-saddr \
    -m hashlimit --hashlimit-upto 10/min --hashlimit-burst 10 --hashlimit-mode srcip --hashlimit-name xmpp \
    -m comment --comment xmpp-server \
    -j ACCEPT
</code></pre>
<p>Pierwsza z tych reguł limituje połączenia dla klientów naszego serwera, tj. tych osób które będą
miały u nas konto. Z grubsza to maksymalna ilość połączeń jakie może utrzymywać w danym czasie
konkretny adres IP z naszym serwerem to 20. Ilość nowych połączeń, które mogą zostać zainicjowane z
danego IP w czasie jednej minuty to 5. Podobnie sprawa wygląda w przypadku drugiej reguły odnoszącej
się do serwerów, z tym, że tutaj mamy limit 10 nowych połączeń na minutę. Po przekroczeniu tych
limitów zadziała mechanizm bezpieczeństwa i kolejne połączenia będą zrzucane, no chyba, że klient
lub serwer pozamyka poprzednie połączenia.</p>
<h3 id="plik-ejabberdyml">Plik ejabberd.yml</h3>
<p>Przyszła pora poskładać te wszystkie wyżej opisane rzeczy i stworzyć z nich konfigurację dla serwera
Jabber'a. Interesuje nas plik <code>/etc/ejabberd/ejabberd.yml</code> , w którym to trzeba co nieco dopisać i
zmienić. Przede wszystkim, musimy określić porty, na których <code>ejabberd</code> będzie nasłuchiwał. Każdy z
tych portów trzeba skonfigurować. W tym przypadku konfigurujemy trzy porty: dla połączeń klienckich,
serwerowych oraz dla serwera www.</p>
<p>Port 5222 (dla połączeń klienckich):</p>
<pre><code>listen:
  -
    port: 5222
    module: ejabberd_c2s
    certfile: &quot;/etc/ejabberd/ejabberd.pem&quot;
    protocol_options:
      - &quot;no_sslv3&quot;
      - &quot;no_tlsv1&quot;
    ciphers: 'TLS_CIPHERS'
    max_stanza_size: 65536
    shaper: c2s_shaper
    access: c2s
    zlib: false
    resend_on_timeout: if_offline
    tls_compression: false
    dhfile: &quot;/etc/ejabberd/dh4096.pem&quot;
</code></pre>
<p>Port 5269 (dla połączeń serwerowych):</p>
<pre><code>-
    port: 5269
    module: ejabberd_s2s_in
    max_stanza_size: 524288

    ...

s2s_use_starttls: optional
s2s_certfile: &quot;/etc/ejabberd/ejabberd.pem&quot;
s2s_dhfile: &quot;/etc/ejabberd/dh4096.pem&quot;

s2s_protocol_options:
  - &quot;no_sslv3&quot;
  ##- &quot;no_tlsv1&quot;
s2s_ciphers: 'TLS_CIPHERS'
s2s_tls_compression: false
</code></pre>
<p>Port 5280 (dla serwera www):</p>
<pre><code>-
    port: 5280
    module: ejabberd_http
    request_handlers:
      &quot;/websocket&quot;: ejabberd_http_ws
    ##  &quot;/pub/archive&quot;: mod_http_fileserver
    web_admin: true
    http_bind: true
    ## register: true
    ## captcha: true
    tls: true
    certfile: &quot;/etc/ejabberd/ejabberd.pem&quot;
</code></pre>
<p>W przypadku portów 5222 oraz 5269 mamy wykorzystane makro o nazwie <code>TLS_CIPHERS</code> odnoszące się do
obsługiwanych szyfrów. Musimy to makro określić w konfiguracji <code>ejabberd</code> (można także dodać <code>!SHA1</code>
i tym samym wyłączyć protokoły TLSv1.1):</p>
<pre><code>define_macro:
  'TLS_CIPHERS': &quot;ECDH:DH:!CAMELLIA128:!3DES:!MD5:!RC4:!aNULL:!NULL:!EXPORT:!LOW:!MEDIUM&quot;
</code></pre>
<p>Tak skonfigurowany serwer Jabber'a będzie akceptował jedynie próby połączeń, które oferują szyfry
TLSv1.1 oraz TLSv1.2. W przypadku klientów wymagane jest szyfrowanie. Natomiast z racji problemów
przy wymuszeniu szyfrowania w przypadku serwerów, np. GMAIL, szyfrowanie połączenia jest opcjonalne.
Można oczywiście wymusić szyfrowanie na linii serwer=serwer manipulując parametrem
<code>s2s_use_starttls</code> ale wtedy trzeba mieć świadomość, że nasz serwer nie da rady nawiązać połączenia
z wieloma serwerami Jabber'a.</p>
<p>Dla poprawy bezpieczeństwa połączeń szyfrowanych korzystamy z własnego pliku z parametrami DH
(Diffie-Hellman). Gdybyśmy nie wygenerowali wcześniej pliku <code>dh4096.pem</code> , to <code>ejabberd</code> by
wykorzystywał liczbę pierwszą o długości 1024 bitów.</p>
<p>Konfigurujemy także domenę oraz uwierzytelnianie przez <a href="https://pl.wikipedia.org/wiki/Simple_Authentication_and_Security_Layer">mechanizm SASL</a> (Simple Authentication
and Security Layer):</p>
<pre><code>disable_sasl_mechanisms: &quot;digest-md5&quot;

hosts:
  - &quot;morfitronik.pl&quot;

fqdn: &quot;jabber.morfitronik.pl&quot;
</code></pre>
<h2 id="test-konfiguracji-serwera-jabbera">Test konfiguracji serwera Jabber'a</h2>
<p>Gdy już poustawiamy wszystko jak należy, przydałoby się sprawdzić konfigurację serwera pod kątem
szyfrowania oferowanego przy połączeniu z klientami i innymi serwerami. Tego typu test możemy
przeprowadzić w serwisie <a href="https://xmpp.net">xmpp.net</a>. Są tam dwa osobne testy. Mój serwer Jabber'a w obu
przypadkach otrzymał ocenę <code>A</code> .</p>
<p><a href="https://xmpp.net/result.php?id=687741">Link do testu klienckiego</a>:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/013.jabber-ejabberd-serwer-debian-linux-wynik-klient.png" alt=""    class="huge"></p>
<p><a href="https://xmpp.net/result.php?id=687742">Link to testu serwerowego</a>:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/014.jabber-ejabberd-serwer-debian-linux-wynik-server.png" alt=""    class="huge"></p>
<h2 id="tworzenie-kont-użytkownikom-i-podłączenia-do-serwera">Tworzenie kont użytkownikom i podłączenia do serwera</h2>
<p>Nasz serwer Jabber'a powinien już działać ale jeszcze nie ma na nim stworzonego konta użytkownika,
które można by wykorzystać przy logowaniu. Konto możemy stworzyć z poziomu terminala lub też przy
pomocy panelu administracyjnego udostępnianego przez serwer www.</p>
<p>Poniżej znajduje się przykładowe polecenie konsolowe, które tworzy konto na serwerze Jabber'a:</p>
<pre><code># ejabberdctl register user morfitronik.pl haslo
User user@morfitronik.pl successfully registered
</code></pre>
<p>Warto sobie obadać narzędzie <code>ejabberdctl</code> (<a href="https://docs.ejabberd.im/admin/guide/managing/">tutaj znajduje się link do manuala</a>).</p>
<p>A tak wygląda panel admina:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/015.jabber-ejabberd-serwer-debian-linux-panel-admina.png" alt=""    class="big"></p>
<h2 id="zmiana-adresu-i-zabezpieczenie-panelu-admina">Zmiana adresu i zabezpieczenie panelu admina</h2>
<p>Standardowo panel admina jest uruchamiany przez <code>ejabberd</code> na wskazanym w konfiguracji adresie
(domenie <code>morfitronik.pl</code> ) i porcie 5280. Problemy z tym adresem są dwa. Pierwszy z nich dotyczy
wystawienia tego panelu na widok publiczny, co nie jest zbyt rozważne. Drugi problem to
niestandardowy port dla stron WWW, przez co trzeba go za każdym razem wpisywać ilekroć chcemy
zarządzać serwerem. Można by oczywiście w konfiguracji <code>ejabberd</code> zdefiniować port 80 czy 443 dla
tego panelu ale w tym przypadku na tych portach nasłuchuje już Apache2 i serwuje tego bloga. Nie da
rady zatem mieć dwóch usług, które będą nasłuchiwać na tym samym porcie. Można natomiast dorobić
proxy do serwera Apache2 i przekierować zapytania pod wskazany adres i port. W ten sposób wpisując w
przeglądarce adres <code>http://jabber.morfitronik.pl</code> (port 80) lub <code>https://jabber.morfitronik.pl</code>
(port 443) zostaniemy z automatu przekierowani na adres
<code>https://jabber.morfitronik.pl:5280/admin/</code> , gdzie zostanie nam wyrzucone okienko logowania do
serwera Jabber'a, które zabezpieczymy sobie dodatkowo certyfikatami x509.</p>
<p>Zaczniemy od napisania konfiguracji dla wirtualnego hosta. Stwórzmy sobie zatem plik <code>ejabberd.conf</code>
w katalogu <code>/etc/apache2/sites-available/</code> i dodajmy do niego poniższą treść:</p>
<pre><code>&lt;VirtualHost *:80&gt;
    ServerName jabber.morfitronik.pl
    ServerAdmin morfik@nsa.com
    DocumentRoot /apache2/jabber
    Redirect permanent / https://jabber.morfitronik.pl/

    LogLevel info
    ErrorLog ${APACHE_LOG_DIR}/error_jabber.morfitronik.log
    CustomLog ${APACHE_LOG_DIR}/access_jabber.morfitronik.log combined

    php_admin_value open_basedir &quot;/apache2/jabber/&quot;
&lt;/VirtualHost&gt;

&lt;IfModule mod_ssl.c&gt;
    &lt;VirtualHost *:443&gt;
        ServerName jabber.morfitronik.pl
        ServerAdmin morfik@nsa.com
        DocumentRoot /apache2/jabber

        LogLevel info ssl:warn
        ErrorLog ${APACHE_LOG_DIR}/error_jabber.morfitronik.log
        CustomLog ${APACHE_LOG_DIR}/access_jabber.morfitronik.log combined

        php_admin_value open_basedir &quot;/apache2/jabber/&quot;

        SSLEngine on
        SSLCertificateFile      /etc/letsencrypt/live/morfitronik.pl/fullchain.pem
        SSLCertificateKeyFile   /etc/letsencrypt/live/morfitronik.pl/privkey.pem

        &lt;FilesMatch &quot;\.(cgi|shtml|phtml|php)$&quot;&gt;
                SSLOptions +StdEnvVars
        &lt;/FilesMatch&gt;
        &lt;Directory /usr/lib/cgi-bin&gt;
                SSLOptions +StdEnvVars
        &lt;/Directory&gt;

        BrowserMatch &quot;MSIE [2-6]&quot; \
                nokeepalive ssl-unclean-shutdown \
                downgrade-1.0 force-response-1.0
        BrowserMatch &quot;MSIE [17-9]&quot; ssl-unclean-shutdown

    &lt;/VirtualHost&gt;

&lt;/IfModule&gt;
</code></pre>
<p>Konfigurację dla tego wirtualnego hosta włączamy linkując wyżej utworzony plik do katalogu
<code>/etc/apache2/sites-enabled/</code> .</p>
<p>Teraz włączmy w Apache2 <a href="https://httpd.apache.org/docs/2.4/mod/mod_proxy.html">moduł proxy_http</a>, za sprawą którego nasz serwer www zyska umiejętność
przekierowania zapytań:</p>
<pre><code># a2enmod proxy_http
</code></pre>
<p>Musimy jeszcze dodać do pliku <code>/etc/apache2/sites-available/ejabberd.conf</code> konfigurację dla proxy,
tj. które zapytania mają być brane pod uwagę. Jako, że w sekcji z portem 80 mamy przekierowanie na
port 443, to tylko do tej drugiej sekcji dopisujemy poniższy kod:</p>
<pre><code>SSLProxyEngine on
ProxyRequests Off
ProxyVia Off

&lt;Proxy *&gt;
     Require all granted
&lt;/Proxy&gt;

ProxyPass /admin https://jabber.morfitronik.pl:5280/admin
ProxyPassReverse /admin https://jabber.morfitronik.pl:5280/admin
</code></pre>
<p>W ten sposób zapytania o <code>jabber.morfitronik.pl/admin</code> zostaną wewnętrznie z automatu przekierowane
przez Apache2 na <code>jabber.morfitronik.pl:5280/admin</code> i odejdzie nam potrzeba wpisywania tego
niestandardowego z punktu widzenia WWW portu.</p>
<p>By jeszcze bardziej uprościć sobie życie, możemy również odpuścić sobie wpisywanie zasobu <code>/admin</code> i
zrobić przekierowanie z <code>jabber.morfitronik.pl</code> na <code>jabber.morfitronik.pl/admin</code> przy pomocy
dyrektywy <code>RedirectMatch</code> lub modułu <code>mod_rewrite</code> :</p>
<pre><code># RedirectMatch ^/$ https://jabber.morfitronik.pl/admin/

&lt;IfModule mod_rewrite.c&gt;
    RewriteEngine on
    RewriteRule   ^/$  /admin/  [R]
&lt;/IfModule&gt;
</code></pre>
<p>Ostatnią rzeczą jest zabezpieczenie panelu admina certyfikatami. Tutaj musimy już posiadać własne CA
oraz odpowiednie certyfikaty. Jeśli nie mamy stosownych plików, to trzeba je sobie pierw
wygenerować. Cały <a href="https://morfikov.github.io/post/generowanie-certyfikatow-przy-pomocy-easy-rsa/">proces generowania certyfikatów przy pomocy easy-rsa</a> został opisany osobno.
My tutaj już wykorzystamy gotowe certyfikaty. W zasadzie to musimy przesłać na serwer certyfikat CA
i dodać w pliku <code>/etc/apache2/sites-available/ejabberd.conf</code> poniższą linijkę:</p>
<pre><code>SSLCACertificateFile    /etc/CA/keys/ca.crt
</code></pre>
<p>Wszystkie certyfikaty klienckie wystawione przez nasze CA będą w ten sposób zaufane. W tym samym
pliku dodajemy też poniższy blok kodu:</p>
<pre><code>&lt;Location &quot;/admin&quot;&gt;
#   SSLOptions +StdEnvVars
    SSLVerifyClient optional
    SSLVerifyDepth 1
#   SSLRenegBufferSize 524288

    &lt;IfModule mod_rewrite.c&gt;
            RewriteEngine on
            RewriteCond %{SSL:SSL_CLIENT_VERIFY} !^SUCCESS$
    #       RewriteCond %{REMOTE_ADDR} !^127.0.0.1$
            RewriteRule ^(.*) https://morfitronik.pl [R=301,L]
    &lt;/IfModule&gt;

&lt;/Location&gt;
</code></pre>
<p>Ma on za zadanie zabezpieczyć zasób, który znajdzie się pod adresem <code>jabber.morfitronik.pl/admin/</code> .
Każdy, kto będzie starał się odwiedzić ten URL, będzie musiał przestawić ważny certyfikat. W
przeciwnym wypadku dostęp zostanie odmówiony, a odwiedzający zostanie przekierowany pod adres
<code>https://morfitronik.pl</code> .</p>
<p>Zapisujemy konfigurację i restartujemy serwer Apache2:</p>
<pre><code># systemctl restart apache2
</code></pre>
<p>Certyfikat kliencki musimy zaimportować sobie w przeglądarce. W tym przypadku zrobimy to na
przykładzie Firefox'a. Przechodzimy zatem kolejno do Preferences &gt; Advanced. Następnie na zakładce
Certificates klikamy View Certificates. W okienku, które się pojawi, przechodzimy na zakładkę Your
Certificates i klikamy w przycisk Import, gdzie podajemy ścieżkę do pliku <code>client.p12</code> :</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2017/03/016.jabber-ejabberd-serwer-debian-linux-certyfikat-zasoby.png" alt=""    class="huge"></p>
<p>Odwiedzamy teraz adres <code>jabber.morfitronik.pl</code> . Bez znaczenia jest tutaj czy dodamy z na początku
<code>http</code>/<code>https</code> oraz czy określimy zasób <code>/admin/</code> , bo i tak wylądujemy docelowo w tym samym
miejscu. Dysponując odpowiednim certyfikatem, powinniśmy zobaczyć okienko logowania do panelu
admina.</p>
<h2 id="baza-danych-mysqlmariadb">Baza danych MySQL/MariaDB</h2>
<p><code>ejabberd</code> domyślnie korzysta z wbudowanej bazy danych zwanej Mnesia. Jeśli na naszym VPS mamy już
zainstalowany jakiś serwer bazy danych, np. MySQL czy MariaDB, to naturalnie możemy ten serwer
podpiąć do serwera Jabber'a. Musimy tylko pozyskać schemat, na podstawie którego stworzymy sobie
bazę danych na potrzeby <code>ejabberd</code> . <a href="https://github.com/processone/ejabberd/tree/master/sql">Tutaj znajdują się wzory schematów bazy</a>, które możemy
wykorzystać. Musimy tylko zdawać sobie sprawę, że jeśli nasz serwer bazy danych to MySQL, to musi
on być w wersji co najmniej 5.6 . W przeciwnym wypadku, przy importowaniu schematu bazy danych
napotkamy błąd przy tworzeniu indeksu FULLTEXT. Pobieramy plik <code>mysql.sql</code> i importujemy na
serwerze baz danych. Najpierw tworzymy nową bazę danych:</p>
<pre><code># mysql -u root -p

mysql&gt; CREATE DATABASE ejabberd;
</code></pre>
<p>A następnie ładujemy schemat bazy:</p>
<pre><code># mysql -u root -p ejabberd &lt; ./mysql.sql
</code></pre>
<p>W pliku <code>/etc/ejabberd/ejabberd.yml</code> musimy jeszcze załączyć stosowną konfigurację. Zmieniamy metodę
uwierzytelniania z <code>internal</code> na <code>sql</code> :</p>
<pre><code>## auth_method: internal
auth_method: sql
</code></pre>
<p>Następnie definiujemy konfigurację dla bazy danych:</p>
<pre><code>sql_type: mysql
sql_server: &quot;localhost&quot;
sql_database: &quot;ejabberd&quot;
sql_username: &quot;ejabberd&quot;
sql_password: &quot;pass-pass&quot;
## sql_port: 3306
</code></pre>
<p>Możemy także ustawić domyślną bazę dla modułów:</p>
<pre><code>default_db: sql
</code></pre>
<p>Zapisujemy konfigurację i restartujemy resetujemy serwer Jabber'a.</p>
<h2 id="dalsza-konfiguracja-serwera-jabbera">Dalsza konfiguracja serwera Jabber'a</h2>
<p>Powyżej udało nam się jedynie postawić bardzo podstawowy serwer Jabber'a i dość dobrze go
zabezpieczyć ale to jedynie początek. <code>ejabberd</code> ma całą masę modułów, które trzeba sobie już we
własnym zakresie skonfigurować podpierając się przy tym <a href="https://docs.ejabberd.im/admin/configuration/">oficjalnym manualem</a>.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/debian/">debian</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/xmpp/">xmpp</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/jabber/">jabber</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f&amp;text=Konfiguracja%20serwera%20XMPP%2fJabber%20pod%20linux%20%28ejabberd%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f&amp;title=Konfiguracja%20serwera%20XMPP%2fJabber%20pod%20linux%20%28ejabberd%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f&amp;title=Konfiguracja%20serwera%20XMPP%2fJabber%20pod%20linux%20%28ejabberd%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f&title=Konfiguracja%20serwera%20XMPP%2fJabber%20pod%20linux%20%28ejabberd%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f&amp;title=Konfiguracja%20serwera%20XMPP%2fJabber%20pod%20linux%20%28ejabberd%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fkonfiguracja-serwer-xmpp-jabber-linux-ejabberd%2f&description=Konfiguracja%20serwera%20XMPP%2fJabber%20pod%20linux%20%28ejabberd%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/android-jak-odratowac-smartfon-po-usunieciu-partycji-system/">Android: Jak odratować smartfon po usunięciu partycji /system/</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/budowanie-obrazu-twrp-recovery-ze-zrodel-omni-rom/">Budowanie obrazu TWRP recovery ze źródeł OMNI ROM</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/android-studio-i-android-sdk-pod-linux/">Android Studio i Android SDK pod linux</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/redshift-i-dostosowanie-temperatury-kolorow-ekranu/">Redshift i dostosowanie temperatury kolorów ekranu</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-skonfigurowac-polaczenie-vpn-przez-ssh/">Jak skonfigurować połączenie VPN przez SSH</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-ukryc-ruch-openvpn-przy-pomocy-stunnel/">Jak ukryć ruch OpenVPN przy pomocy stunnel</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/">Jak skonfigurować serwer VPN na Debianie (OpenVPN)</a></li>
		
	</ul>
</div>

	<div id="comments">
		<script>
  var id =  49 ;

  if (id)
  {
    let url = "https://github.com/morfikov/morfitronik-comments/issues/".concat(id);
    let api_url = "https://api.github.com/repos/morfikov/morfitronik-comments/issues/".concat(id, "/comments");

    var commentsDiv = document.getElementById("comments");

    let xhr = new XMLHttpRequest();
    xhr.responseType = "json";
    xhr.open("GET", api_url);
    xhr.setRequestHeader("Accept", "application/vnd.github.v3.html+json");
    xhr.send();

    xhr.onload = function()
    {
      if (xhr.status != 200)
      {
        let errorText = document.createElement("p");
        errorText.innerHTML = "<i>Komentarze dla tego postu nie zostały jeszcze otworzone (albo skrypty GitHub'a są wyłączone).</i>";
        commentsDiv.appendChild(errorText);
      }
      else
      {
        let comments = xhr.response;

        let mainHeader = document.createElement("h3");
        mainHeader.innerHTML = "Komentarze: ".concat(comments.length);
        commentsDiv.appendChild(mainHeader);

        let issueLink = document.createElement("p");
        issueLink.innerHTML = "<i>Możesz zostawić komentarz korzystając z <a href='".concat(url, "'>GitHub issue</a>.</i>");
        commentsDiv.appendChild(issueLink);

        comments.forEach(function(comment)
        {
			const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric', timeZone: 'Europe/Warsaw' };
			options.timeZoneName = 'short';
            let commentContent = document.createElement("div");
            commentContent.setAttribute('class', 'gh-comment')
            commentContent.innerHTML = "".concat(
                "<div class='gh-header'>",
                  "<img src='", comment.user.avatar_url, "' />",
                  "<div style='margin:auto 0;'>",
                    "<b><a class='gh-username' href='", comment.user.html_url, "'>", comment.user.login, "</a></b>",
                    " | <em>", (new Date(comment.created_at)).toLocaleTimeString('pl-PL', options), "</em>",
                  "</div>",
                "</div>",
                "<div class='gh-body'>",
                  comment.body_html,
                "</div>"
            );
            commentsDiv.appendChild(commentContent);
        });
      }
    };

    xhr.onerror = function()
    {
      let errorText = document.createElement("p");
      errorText.innerHTML = "<i>Wystąpił jakiś błąd przy ładowaniu komentarzy.</i>";
      commentsDiv.appendChild(errorText);
    };
  }
</script>

	</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2021 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
		<img alt="Licencja Creative Commons" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/80x15.png" />
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
</body>
</html>
