<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN) | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)" />
<meta property="og:description" content="Parę dni temu na forum dug.net.pl pojawiło się zapytanie dotyczące skonfigurowania linux&#39;a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux&#39;a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy iptables / nftables ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/jak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn/" />
<meta property="article:published_time" content="2020-09-02T18:36:00+02:00" />
<meta property="article:modified_time" content="2020-09-02T18:36:00+02:00" />

		<meta itemprop="name" content="Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)">
<meta itemprop="description" content="Parę dni temu na forum dug.net.pl pojawiło się zapytanie dotyczące skonfigurowania linux&#39;a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux&#39;a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy iptables / nftables ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN.">
<meta itemprop="datePublished" content="2020-09-02T18:36:00+02:00" />
<meta itemprop="dateModified" content="2020-09-02T18:36:00+02:00" />
<meta itemprop="wordCount" content="2771">



<meta itemprop="keywords" content="debian,vpn,prywatność,sieć,nftables," />

		<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)"/>
<meta name="twitter:description" content="Parę dni temu na forum dug.net.pl pojawiło się zapytanie dotyczące skonfigurowania linux&#39;a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux&#39;a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy iptables / nftables ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN."/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/wsparcie/">
					
					<span class="main-nav__text">Wsparcie</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2020-09-02T18:36:00&#43;02:00">Opublikowano: 02/09/2020</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Jak zmusić jeden proces do korzystania z VPN na linux (OpenVPN)</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#konfiguracja-openvpn">Konfiguracja OpenVPN</a>
      <ol>
        <li><a href="#parametr-route-nopull">Parametr route-nopull</a></li>
      </ol>
    </li>
    <li><a href="#konfiguracja-tras-routingu-dla-openvpn">Konfiguracja tras routingu dla OpenVPN</a></li>
    <li><a href="#konfiguracja-iptablesnftables">Konfiguracja iptables/nftables</a></li>
    <li><a href="#test-vpn-dla-określonego-użytkownika">Test VPN dla określonego użytkownika</a></li>
    <li><a href="#problemy-związane-z-procesowym-vpn">Problemy związane z procesowym VPN</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Parę dni temu <a href="https://forum.dug.net.pl/viewtopic.php?id=31514">na forum dug.net.pl pojawiło się zapytanie</a> dotyczące skonfigurowania linux'a w
taki sposób, by ten umożliwił pojedynczemu procesowi w systemie (i tylko jemu) korzystanie z VPN,
podczas gdy wszystkie pozostałe aplikacje korzystają ze standardowego łącza internetowego naszego
ISP. Oczywiście to niekoniecznie musi być tylko jeden proces, bo to zagadnienie można rozciągnąć
też na większą grupę procesów jednego lub więcej użytkowników. By to zadanie zrealizować, trzeba
zdać sobie sprawę z faktu, że każdy proces w linux ma swojego właściciela, a ten właściciel
przynależy do co najmniej jednej grupy. Dzięki takiemu rozwiązaniu, każdy proces w systemie ma
przypisany m.in. identyfikator użytkownika (UID) oraz identyfikatory grup (GID), z którymi działa i
na podstawie których to linux przyznaje uprawienia dostępu do różnych części systemu, np. urządzeń
czy plików na dysku. W ten sposób możemy bardzo prosto ograniczyć dostęp do określonych zasobów
konkretnym użytkownikom (bardziej ich procesom). Problem się zaczyna w przypadku sieci, gdzie w
zasadzie dostęp do internetu ma domyślnie przyznany każdy proces. Naturalnie możemy skonfigurować
filtr pakietów i zezwolić tylko części aplikacji na dostęp do sieci ale w dalszym ciągu, gdy tylko
odpalimy VPN (w tym przypadku OpenVPN), to każdy proces mający prawo wysyłać pakiety sieciowe
będzie je przesyłał z automatu przez VPN, jak tylko to połączenie zostanie zestawione. Istnieje
jednak sposób, by nauczyć linux'a aby tylko procesy określonych użytkowników czy grup miały dostęp
do VPN i gdy to połączenie zostanie zerwane, to te procesy nie będą mogły korzystać ze
standardowego łącza internetowego. Trzeba jednak zaprzęgnąć do pracy <code>iptables</code> / <code>nftables</code> ,
tablice routingu oraz nieco inaczej skonfigurować klienta OpenVPN.</p>
<h2 id="konfiguracja-openvpn">Konfiguracja OpenVPN</h2>
<p>Nie będę tutaj opisywał jako takiej <a href="https://morfikov.github.io/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/">konfiguracji OpenVPN</a>, bo to zostało zrobione w osobnym
artykule. Dlatego jeśli ktoś potrzebuje informacji na temat jak skonfigurować OpenVPN, to odsyłam
do podlinkowanego wpisu. Tutaj zakładam, że mamy już działające połączenie VPN i jesteśmy w stanie
bez większego problemu nawiązać łączność ze światem zewnętrznym przy jego pomocy. W tym przypadku
wykorzystywany będzie <a href="https://riseup.net/pl/vpn">VPN riseup</a>, którego konfiguracja znajduje się w pliku
<code>/etc/openvpn/riseup.conf</code> . Ten plik trzeba będzie poddać edycji (o tym za moment).</p>
<p>W przypadku części serwerów OpenVPN (VPN riseup się do nich zalicza), cały ruch klienta po
zestawieniu połączenia jest wrzucany w tunel SSL/TLS i szyfrowany na linii klient-serwer. By ten
zabieg zrealizować, serwer przesyła do klienta żądanie <code>push &quot;redirect-gateway&quot;</code> , które ma na
celu przekonfigurować trasy u klienta w taki sposób, by znalazło się w jego tablicy routingu kilka
dodatkowych wpisów, m.in. <code>0.0.0.0/1</code> oraz <code>128.0.0.0/1</code> , które efektywnie nadpisują domyślną
trasę routingu bez potrzeby jej usuwania z tablicy.</p>
<p>Poniżej jest przykład tablicy routingu z mojego laptopa:</p>
<pre><code># ip route show
default via 192.168.1.1 dev bond0 metric 10
10.10.10.0/24 dev br-docker proto kernel scope link src 10.10.10.1 dead linkdown
192.168.1.0/24 dev bond0 proto kernel scope link src 192.168.1.150
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 dead linkdown
</code></pre>
<p>Domyślna brama (wpis z <code>default</code> ) ma adres <code>192.168.1.1</code> i jest osiągalna przez interfejs <code>bond0</code> .
Pod <code>default</code> kryje się adres <code>0.0.0.0/0</code> , który w zasadzie <a href="https://en.wikipedia.org/wiki/0.0.0.0">oznacza wszystkie adresy</a>. Routing
działa na zasadzie najdłuższego prefiksu, czyli preferowane są bardziej specyficzne trasy. Zatem
cały ruch niepasujący do żadnej skonfigurowanej na tej maszynie sieci, tj <code>10.10.10.0/24</code> ,
<code>192.168.1.0/24</code> oraz <code>192.168.122.0/24</code> , będzie przesyłany na adres <code>192.168.1.1</code> i tam już
odpowiednio przekierują pakiety, tak by np. trafiły pod adres <code>8.8.8.8</code> .</p>
<p>Jeśli teraz zestawimy połączenie VPN, to ta widoczna wyżej tablica routingu będzie się prezentować
w poniższy sposób:</p>
<pre><code># ip route show
0.0.0.0/1 via 172.27.100.1 dev tun0
default via 192.168.1.1 dev bond0 metric 10
10.10.10.0/24 dev br-docker proto kernel scope link src 10.10.10.1 dead linkdown
128.0.0.0/1 via 172.27.100.1 dev tun0
172.27.100.0/22 dev tun0 proto kernel scope link src 172.27.100.19
192.168.1.0/24 dev bond0 proto kernel scope link src 192.168.1.150
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 dead linkdown
198.252.153.226 via 192.168.1.1 dev bond0
</code></pre>
<p>Jak zostało wspomniane wcześniej, wpisy <code>0.0.0.0/1</code> oraz <code>128.0.0.0/1</code> mają za zadanie przekierować
cały ruch do bramy VPN. W zakres <code>0.0.0.0/1</code> łapią się wszystkie adresy, których pierwszy bit ma
wartość <code>0</code> , natomiast w zakres <code>128.0.0.0/1</code> łapią się adresy mające pierwszy bit ustawiony na
wartość <code>1</code> . Dla lepszego zrozumienia, poniżej jest rozpiska:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2020/09/002-openvpn-vpn-routing-table-routes-default.png" alt=""    class="big"></p>
<p>W ten sposób każda z tych dwóch tras jest bardziej specyficzna niż <code>0.0.0.0/0</code> , która również
łapie wszystkie adresy. Tym prostym zabiegiem nasza domyślna brama nie ma już żadnego wpływu na
routing pakietów. Każda z tych dwóch tras ma określony <code>via 172.27.100.1</code> oraz  <code>dev tun0</code> , przez
co nową bramą domyślną staje się adres <code>172.27.100.1</code> osiągalny przez interfejs <code>tun0</code> . Dalej w
tablicy routingu widzimy, że została także skonfigurowana trasa dla nowej sieci <code>172.27.100.0/22</code>
(sieć VPN) oraz pojawił się wpis <code>198.252.153.226</code> , którego IP wskazuje na adres serwera VPN
riseup. Chodzi tutaj o to, że pakiety po zaszyfrowaniu (odebrane z interfejsu <code>tun0</code> ) muszą zostać
przesłane do serwera VPN. Nie mogą jednak lecieć kanałem VPN. Zatem wszystkie pakiety (te wrzucone
w tunel SSL/TLS) kierowane są na adres <code>198.252.153.226</code> . Dalej w tej trasie mamy <code>via 192.168.1.1 dev bond0</code> , przez co pakiety kierowane na adres <code>198.252.153.226</code> będą przesyłane przez naszą
wcześniejszą bramę domyślną.</p>
<h3 id="parametr-route-nopull">Parametr route-nopull</h3>
<p>Po skonfigurowaniu tras routingu, wszystkie aplikacje sieciowe będą przesyłać ruch prze VPN.
Niemniej jednak, ta domyślna polityka przekonfigurowania tras routingu sprawia, że nie damy rady
rozdzielić procesów w taki sposób, by tylko określone z nich przesyłały pakiety przez VPN. Trzeba
zatem tych domyślnych tras routingu się pozbyć i do tego służy parametr <code>route-nopull</code> , który
trzeba dopisać w konfiguracji OpenVPN w pliku <code>/etc/openvpn/riseup.conf</code> :</p>
<pre><code>route-nopull
</code></pre>
<p>Odpalmy teraz OpenVPN. Po rzuceniu okiem na tablicę routingu, możemy stwierdzić, że przypomina ona
tę podstawową tablicę sprzed zestawiania połączenia VPN. W zasadzie to została dodana jedynie trasa
dla sieci VPN (wpis z <code>172.27.100.0/22</code> ):</p>
<pre><code># ip route show
default via 192.168.1.1 dev bond0 metric 10
10.10.10.0/24 dev br-docker proto kernel scope link src 10.10.10.1 dead linkdown
172.27.100.0/22 dev tun0 proto kernel scope link src 172.27.100.18
192.168.1.0/24 dev bond0 proto kernel scope link src 192.168.1.150
192.168.122.0/24 dev virbr0 proto kernel scope link src 192.168.122.1 dead linkdown
</code></pre>
<p>W taki sposób po zestawieniu połączenia VPN, nic u nas w systemie się jeszcze nie dzieje, tj.
pakiety w dalszym ciągu wędrują przez domyślny gateway routera domowego albo naszego ISP. Niemniej
jednak, teraz te trasy routingu musimy sobie sami skonfigurować, by aplikacje miały w ogóle
jakąkolwiek możliwość przesyłania pakietów przez VPN.</p>
<h2 id="konfiguracja-tras-routingu-dla-openvpn">Konfiguracja tras routingu dla OpenVPN</h2>
<p>Pora przejść do ręcznej konfiguracji tras routingu. Przede wszystkim, musimy określić w tym miejscu
jaki proces albo bardziej użytkownik lub grupa, z którymi uruchomiony jest dany proces, ma mieć
dostęp do VPN. W zasadzie to nie ma znaczenia czy zdecydujemy się na grupę czy użytkownika, bo
konfiguracja tras będzie przebiegać tak samo, no może za wyjątkiem drobnych różnic w numerach czy
nazwach parametrów. Każde z tych dwóch rozwiązań ma swoje wady i zalety. Jeśli korzystamy z grup,
to bez problemu nasz zwykły użytkownik, na którym operujemy na co dzień, będzie w stanie
bezpośrednio wywoływać procesy, co może uprościć operowanie na graficznych aplikacjach. Jeśli zaś
chcemy określić użytkownika, który będzie korzystać z VPN, to trzeba będzie się na niego logować.
Tak czy inaczej, zarówno użytkownik jak i grupa posiada swój numer identyfikacyjny i to nim
będziemy się posługiwać w dalszej części tego artykułu.</p>
<p>Na początek stwórzmy nową tablicę routingu i nazwijmy ją <code>vpn</code> . By dodać nową tablicę routingu,
trzeba edytować plik <code>/etc/iproute2/rt_tables</code> i umieścić w niej poniższy wpis:</p>
<pre><code>200 vpn
</code></pre>
<p>Numerek może być dowolny, podobnie jak i nazwa tablicy. Nazwy są bardziej dla ludzi, maszyny wolną
numerki i ta para to właśnie takie mapowanie nazwy na numery. Do obu tych wartości będzie można się
odwoływać w poleceniach.</p>
<p>Następnie dodajemy nowy wpis do tablicy <code>vpn</code> , który ma za zadanie skonfigurować trasę domyślną
dla interfejsu <code>tun0</code> :</p>
<pre><code># ip route add default dev tun0 table vpn
</code></pre>
<p>Problem z tą trasą jest taki, że gdy interfejs <code>tun0</code> zniknie (np. rozłączymy VPN), to ta trasa
również zostanie usunięta, a pakiety, które miałyby iść przez VPN, będą teraz lecieć przez bramę
domyślną naszego ISP. Taka sytuacja niekoniecznie jest pożądana, zwłaszcza w przypadku, gdy chcemy
by określony proces miał dostęp do sieci jedynie przez VPN. W takim przypadku trzeba jeszcze do
tablicy <code>vpn</code> dodać trasę <a href="https://linux.die.net/man/8/ip">typu blackhole</a>, tak by wszystkie pakiety przekierowane do VPN były
cicho niszczone bez przekazywania ich dalej w przypadku braku połączenia VPN:</p>
<pre><code># ip route append blackhole default table vpn
</code></pre>
<p>W ten sposób upewnimy się, że proces korzystający z VPN nie będzie miał możliwości bezpośredniego
kontaktu z siecią.</p>
<p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=89aef8921bfbac22f00e04f8450f6e447db13e42">Cache routingu został usunięty z kernela</a> dość dawno (od wersji v3.6), zatem nie musimy już
wydawać tego poniższego polecenia:</p>
<pre><code># ip route flush cache
</code></pre>
<p>Mamy zatem domyślną trasę w tablicy <code>vpn</code> ale potrzebujemy jeszcze jakiejś reguły, która sprawi, że
ta trasa będzie w ogóle brana pod uwagę. Bez tej reguły, kernel przy routingu pakietów będzie
posługiwał się w zasadzie tablicą <code>main</code> , przez co połączenie VPN nie będzie używane:</p>
<pre><code># ip rule add fwmark 0x1111 priority 20002 table vpn
</code></pre>
<p>Za sprawą tej powyższej reguły, pakiety będą dopasowane na podstawie <code>fwmark</code> nakładanego przez
netfilter ( <code>iptables</code> / <code>nftables</code>). Wartość <code>fwmark</code> możemy określić z zakresu od <code>0x00000000</code> do
<code>0xffffffff</code> , zarówno dziesiętnie, jak i w HEX. Jeśli chcemy podać wartość w HEX, to używamy <code>0x</code> .
Trzeba mieć na uwadze fakt, że niektóre aplikacje (np. <code>conntrack</code> ) przelicza HEX'y na wartości
dziesiętne. W taki sposób <code>0x00001111</code> przyjmie wartość <code>4369</code> . Zatem lepiej uważać jaką wartość w
<code>fwmark</code> podajemy. Priorytet określony w <code>priority</code> nie ma znaczenia, gdy w grę wchodzi tylko jedna
reguła. Niemniej jednak, każda reguła musi mieć określony priorytet i ten priorytet musi być inny
dla każdej z nich. Warto tutaj zaznaczyć, że im wyższa wartość parametru <code>priority</code> , tym niż
priorytet. Z kolei <code>table vpn</code> nakazuje kernelowi sprawdzenie tablicy <code>vpn</code> ilekroć tylko mark w
pakietach zostanie dopasowany.</p>
<p>Po dodaniu tej powyższej reguły, reguły routingu powinny wyglądać mniej więcej tak:</p>
<pre><code># ip rule show
0:      from all lookup local
2002:   from all fwmark 0x1111 lookup vpn
32766:  from all lookup main
32767:  from all lookup default
</code></pre>
<p>Mamy tutaj cztery reguły -- jedna nasza, a trzy pozostałe są domyślnie skonfigurowane na każdym
linux'ie.</p>
<h2 id="konfiguracja-iptablesnftables">Konfiguracja iptables/nftables</h2>
<p>Została nam już ostatnia rzecz do skonfigurowania, tj. filtr pakietów <code>iptables</code> lub <code>nftables</code> . W
tym przypadku będziemy korzystać z <code>nftables</code> ale bez problemu te reguły można przepisać i na
<code>iptables</code> .</p>
<p>Pisząc regułę routingu, określiliśmy w niej <code>fwmark</code> o wartości <code>0x1111</code> . Ten mark może zostać
nałożony przez filtr pakietów w tablicy <code>mangle</code> w łańcuchu <code>OUTPUT</code> . Stwórzmy zatem dodatkowy
łańcuch w tej tablicy i przekierujmy do niego ruch w oparciu <a href="https://wiki.nftables.org/wiki-nftables/index.php/Matching_packet_metainformation">o informacje o pakiecie</a>, tj UID
( <code>skuid</code> ) lub GID ( <code>skgid</code> ):</p>
<pre><code>nft create chain ip mangle force-vpn
nft add rule ip mangle OUTPUT meta skuid 1001 counter jump force-vpn
</code></pre>
<p>Każdy pakiet sieciowy, który zostanie stworzony przez aplikacje uruchomione przez użytkownika
mającego ID <code>1001</code> zostanie dopasowany do tej drugiej reguły i przesłany do łańcucha <code>force-vpn</code> .
W tym łańcuchu dodajemy kolejną regułę, której zadaniem jest oznaczenie pakietów markiem <code>0x1111</code> :</p>
<pre><code>nft add rule ip mangle force-vpn meta skgid 1001 meta mark set 0x1111 counter
</code></pre>
<p>W tej chwili każdy pakiet sieciowy użytkownika z ID <code>1001</code> będzie oznaczany w <code>nftables</code> , a reguła
routingu sprawi, że pakiety zostaną skierowane do kanału VPN. Warto tutaj zaznaczyć, że takie
oznaczanie pakietów dotyczy każdego pakietu z osobna, tj. każdy pakiet tego użytkownika z ID <code>1001</code>
będzie dopasowany do tej reguły, co niekoniecznie jest optymalnym rozwiązaniem jeśli chodzi o
wydajność. Naturalnie taki mechanizm oznaczania pakietów nie sprawi, że prędkość połączenia
sieciowego ucierpi ale to rozwiązanie oznaczania pakietów można poprawić przez oznaczanie całego
połączenia zamiast pojedynczych pakietów. Niemniej jednak, jest to ździebko skomplikowane i nie
będę tej kwestii tutaj poruszał. Ci, których interesuje to zagadnienie, mogą rzucić okiem na
artykuł o <a href="https://morfikov.github.io/post/target-mark-w-iptables/">oznaczaniu połączeń przy pomocy targetu MARK w iptables</a>.</p>
<p>Oznaczenie pakietów i przekierowanie ich pod określony adres mamy z głowy. Problem jednak w tym, że
te pakiety nie będą chciały opuścić naszej maszyny, bo nie jest jeszcze realizowany NAT. Musimy
zatem dodać parę reguł w <code>nftables</code> dla tablicy NAT.</p>
<p>Podobnie jak poprzednio, tworzymy osobny łańcuch i przekierowujemy ruch do niego, tym razem w
oparciu o interfejs wychodzący, który ma wskazywać na interfejs VPN (w tym przypadku <code>tun0</code> ):</p>
<pre><code>nft create chain ip nat force-vpn
nft add rule ip nat POSTROUTING meta oifname tun0 counter jump force-vpn
</code></pre>
<p>W łańcuchu <code>force-vpn</code> dodajemy teraz regułę, która ma przepisać źródło pakietów na adres jaki
klient OpenVPN otrzymał z serwera. W tym przypadku serwer VPN dynamicznie przydziela klientom
adresy IP i nigdy nie wiadomo na jaki się trafi, dlatego lepiej skorzystać z maskarady:</p>
<pre><code>nft add rule ip nat force-vpn meta oifname tun0 counter masquerade
</code></pre>
<p>Jeśli jednak mamy przydzielony stały adres IP, to <a href="https://wiki.nftables.org/wiki-nftables/index.php/Performing_Network_Address_Translation_(NAT)#Source_NAT">można również dać SNAT zamiast maskarady</a>,
choć nie jest to wymagane:</p>
<pre><code>nft add rule ip nat force-vpn meta oifname tun0 counter snat 172.27.100.18
</code></pre>
<h2 id="test-vpn-dla-określonego-użytkownika">Test VPN dla określonego użytkownika</h2>
<p>Te powyżej przeprowadzone kroki to w zasadzie wszystko co jest nam potrzebne do skonfigurowania VPN
dla pojedynczego procesu czy użytkownika/grupy, przy założeniu, że mieliśmy wcześniej działający
VPN. Wystarczy się teraz zalogować na tego określonego usera lub też odpalić jakiś proces z
konkretną grupą i przetestować np. przy pomocy <code>ping</code> czy opóźnienia do tego samego serwera ulegają
zmianie w zależności czy <code>ping</code> leci przez VPN czy bezpośrednio do docelowego hosta. Jak widać na
przykładzie zobrazowanym poniżej, różnica w pingu jest i to dość znaczna. Zawsze można też dla
potwierdzenia odpytać o nasz adres IP jakiś zewnętrzny serwis, by sprawdzić czy faktycznie te
adresy IP widziane przez serwery WWW się różnią:</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2020/09/001-openvpn-process-linux-config-vpn-test-ping-different-users.png" alt=""    class="huge"></p>
<p>Podczas testowania połączenia można także podejrzeć tablicę conntrack'a i sprawdzić czy przy wpisie
od nawiązanego połączenia widnieje ustawiony przez nas mark:</p>
<pre><code># conntrack -L | grep 212.77.98.9
icmp     1 29 src=192.168.1.150 dst=212.77.98.9 type=8 code=0 id=35 src=212.77.98.9 \
              dst=172.27.100.20 type=0 code=0 id=35 mark=4369 use=1
</code></pre>
<p>Jak widać, mamy tutaj <code>mark=4369</code> , czyli <code>0x1111</code> zapisany w formie dziesiętnej. Zatem to
połączenie zostało poprawnie oznaczone przez <code>nftables</code> i wszystkie pakiety tego połączenia lecą
przez VPN.</p>
<h2 id="problemy-związane-z-procesowym-vpn">Problemy związane z procesowym VPN</h2>
<p>Przedstawione w niniejszym artykule rozwiązanie nie jest pozbawione wad. Przede wszystkim, te
poczynione zmiany w konfiguracji systemu nie są permanentne. Z każdym restartem maszyny trzeba by
te wszystkie kroki przeprowadzać ponownie. Podobnie sprawa wygląda w przypadku restartu połączenia
VPN czy też jego rozłączenia w skutek różnych przyczyn. Chodzi generalnie o to, że gdy połączenie
VPN zniknie, to trasy przypisane do interfejsu VPN ( <code>tun0</code> ) również znikną, w efekcie czego
trzeba by je dodać jeszcze raz. Można jednak ten stan rzeczy dość łatwo poprawić pisząc prosty
skrypt shell'owy dla OpenVPN. Poniżej jest przykład takiego skryptu, który zapisujemy w
<code>/etc/openvpn/force-user-traffic-via-vpn.sh</code> :</p>
<pre><code>#!/bin/sh

user_id=&quot;1001&quot;
group_id=&quot;1001&quot;
mark=&quot;0x1111&quot;
route_table=&quot;vpn&quot;
rule_prio=&quot;2002&quot;

[ &quot;$script_type&quot; ] || exit 0
[ &quot;$dev&quot; ] || exit 0

case &quot;$script_type&quot; in
  up)

  if ! grep ${route_table} /etc/iproute2/rt_tables &gt; /dev/null
  then
      echo &quot;200 ${route_table}&quot; &gt;&gt; /etc/iproute2/rt_tables
  fi

  if ip route show table ${route_table} | grep blackhole &gt; /dev/null
  then
    ip route del default table ${route_table}
  fi
  ip route add default dev ${dev} table ${route_table}
  ip route append blackhole default table ${route_table}

  if ! ip rule show | grep ${mark} &gt; /dev/null
  then
    ip rule add fwmark ${mark} priority ${rule_prio} table ${route_table}
  fi

  if ! nft -a list table ip nat | grep force-vpn &gt; /dev/null
  then
    nft create chain ip nat force-vpn
    nft add rule ip nat POSTROUTING meta oifname ${dev} counter jump force-vpn
    nft add rule ip nat force-vpn meta oifname ${dev} counter masquerade
  fi

  if ! nft -a list table ip mangle | grep force-vpn &gt; /dev/null
  then
    nft create chain ip mangle force-vpn
    nft add rule ip mangle OUTPUT meta skuid ${user_id} counter jump force-vpn
    nft add rule ip mangle force-vpn meta skuid ${user_id} meta mark set ${mark} counter
  fi

    ;;
  down)
    ;;
esac
</code></pre>
<p>W zasadzie wszystkie kroki, które przeprowadziliśmy wcześniej, zostały zebrane w tym skrypcie. Ma
on, co prawda, akcje <code>up</code> oraz <code>down</code> ale w <code>down</code> nie ma żadnych poleceń. Chodzi o to, by nie cofać
zmian w konfiguracji systemu, tj. tych wprowadzonych podczas zestawiania połączenia VPN po raz
pierwszy. W ten sposób, gdy nastąpi zerwanie połączenia VPN, to proces korzystający z niego nie
będzie miał dostępu do sieć hosta i nie będzie w stanie przesłać żadnego pakietu przez sieci do
momentu aż to połączenie z VPN zostanie nawiązane ponownie.</p>
<p>By ten skrypt był wykonywany podczas zestawiania połączenia VPN, musimy jeszcze edytować
konfigurację VPN i dodać do niej te poniższe wpisy:</p>
<pre><code>script-security 2
up /etc/openvpn/force-user-traffic-via-vpn.sh
down /etc/openvpn/force-user-traffic-via-vpn.sh
</code></pre>
<p>I to w zasadzie cała robota -- kawałek skryptu w połączeniu z paroma dodatkowymi wpisami w
konfiguracji połączenia VPN. Przy pomocy tego rozwiązania można bez większego problemu
skonfigurować sobie dwa różne profile Firefox'a i ruch jednego z nich puścić tradycyjnie przez
łącze naszego ISP, a ruch drugiego przez VPN, co powinno nieco poprawić naszą prywatność wtedy, gdy
tego potrzebujemy bez dodatkowych zabiegów konfiguracyjnych i ciągłego przełączania się między VPN
a zwykłym połączeniem internetowym.</p></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/debian/">debian</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/vpn/">vpn</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/prywatno%C5%9B%C4%87/">prywatność</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/sie%C4%87/">sieć</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/nftables/">nftables</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f&amp;text=Jak%20zmusi%c4%87%c2%a0jeden%20proces%20do%20korzystania%20z%20VPN%20na%20linux%20%28OpenVPN%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f&amp;title=Jak%20zmusi%c4%87%c2%a0jeden%20proces%20do%20korzystania%20z%20VPN%20na%20linux%20%28OpenVPN%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f&amp;title=Jak%20zmusi%c4%87%c2%a0jeden%20proces%20do%20korzystania%20z%20VPN%20na%20linux%20%28OpenVPN%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f&title=Jak%20zmusi%c4%87%c2%a0jeden%20proces%20do%20korzystania%20z%20VPN%20na%20linux%20%28OpenVPN%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f&amp;title=Jak%20zmusi%c4%87%c2%a0jeden%20proces%20do%20korzystania%20z%20VPN%20na%20linux%20%28OpenVPN%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fjak-zmusic-jeden-proces-do-korzystania-z-vpn-na-linux-openvpn%2f&description=Jak%20zmusi%c4%87%c2%a0jeden%20proces%20do%20korzystania%20z%20VPN%20na%20linux%20%28OpenVPN%29" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-ukryc-ruch-openvpn-przy-pomocy-stunnel/">Jak ukryć ruch OpenVPN przy pomocy stunnel</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-skonfigurowac-serwer-vpn-na-debianie-openvpn/">Jak skonfigurować serwer VPN na Debianie (OpenVPN)</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/przeciek-dns-dns-leak-w-vpn-resolvconf/">Przeciek DNS (DNS leak) w VPN (resolvconf)</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/riseup-vpn-na-strazy-prywatnosci/">Riseup VPN na straży prywatności</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/jak-wlaczyc-stabilne-adresy-prywatne-w-ipv6-na-linux/">Jak włączyć stabilne adresy prywatne w IPv6 na linux</a></li>
		
	</ul>
</div>

	
<section class="comments block">
	<div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "morfitronik" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</section>


	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2021 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
		<img alt="Licencja Creative Commons" style="border-width:0" src="https://licensebuttons.net/l/by-nc-sa/4.0/80x15.png" />
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
</body>
</html>
