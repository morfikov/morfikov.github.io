<!DOCTYPE html>
<html class="no-js" lang="pl-PL">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="theme-color" content="#1b1b1b">
	<title>Bufor połączeń w protokole TCP | Morfitronik</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Bufor połączeń w protokole TCP" />
<meta property="og:description" content="Wraz ze zwiększaniem zapotrzebowania na szybsze łącza internetowe, ograniczenia wynikające z
protokółu TCP zaczęły powoli dawać się ludziom we znaki. Problemem była bariera prędkości, którą
ciężko było pokonać mając do dyspozycji domyślną formę nagłówka protokołu TCP. Było w nim zwyczajnie
za mało miejsca, co zapoczątkowało jego rozbudowę kosztem ilości danych, które można było przesłać w
pojedynczym segmencie. W tym wpisie skupię się głównie na dwóch opcjach jakie zostały dodane do
nagłówka TCP, tj. dynamiczne skalowanie okien oraz znaczniki czasu, bo te dwa parametry nie mogą
wręcz bez siebie istnieć, zwłaszcza gdy rozmawiamy o łączach pokroju 1 czy 10 gbit/s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morfikov.github.io/post/bufor-polaczen-w-protokole-tcp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2015-07-01T10:20:16+00:00" />
<meta property="article:modified_time" content="2015-07-01T10:20:16+00:00" />


		<meta itemprop="name" content="Bufor połączeń w protokole TCP">
<meta itemprop="description" content="Wraz ze zwiększaniem zapotrzebowania na szybsze łącza internetowe, ograniczenia wynikające z
protokółu TCP zaczęły powoli dawać się ludziom we znaki. Problemem była bariera prędkości, którą
ciężko było pokonać mając do dyspozycji domyślną formę nagłówka protokołu TCP. Było w nim zwyczajnie
za mało miejsca, co zapoczątkowało jego rozbudowę kosztem ilości danych, które można było przesłać w
pojedynczym segmencie. W tym wpisie skupię się głównie na dwóch opcjach jakie zostały dodane do
nagłówka TCP, tj. dynamiczne skalowanie okien oraz znaczniki czasu, bo te dwa parametry nie mogą
wręcz bez siebie istnieć, zwłaszcza gdy rozmawiamy o łączach pokroju 1 czy 10 gbit/s."><meta itemprop="datePublished" content="2015-07-01T10:20:16+00:00" />
<meta itemprop="dateModified" content="2015-07-01T10:20:16+00:00" />
<meta itemprop="wordCount" content="1654">
<meta itemprop="keywords" content="tcp,sysctl,sieć," />
		<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Bufor połączeń w protokole TCP"/>
<meta name="twitter:description" content="Wraz ze zwiększaniem zapotrzebowania na szybsze łącza internetowe, ograniczenia wynikające z
protokółu TCP zaczęły powoli dawać się ludziom we znaki. Problemem była bariera prędkości, którą
ciężko było pokonać mając do dyspozycji domyślną formę nagłówka protokołu TCP. Było w nim zwyczajnie
za mało miejsca, co zapoczątkowało jego rozbudowę kosztem ilości danych, które można było przesłać w
pojedynczym segmencie. W tym wpisie skupię się głównie na dwóch opcjach jakie zostały dodane do
nagłówka TCP, tj. dynamiczne skalowanie okien oraz znaczniki czasu, bo te dwa parametry nie mogą
wręcz bez siebie istnieć, zwłaszcza gdy rozmawiamy o łączach pokroju 1 czy 10 gbit/s."/>
<meta name="twitter:site" content="@mikhailmorfikov"/>

	<link rel="stylesheet" href="https://morfikov.github.io/css/bundle.css">
	<link rel="stylesheet" href="https://morfikov.github.io/css/custom.css">
	<link rel="icon" href="https://morfikov.github.io/icons/16.png" sizes="16x16" type="image/png">
	<link rel="icon" href="https://morfikov.github.io/icons/32.png" sizes="32x32" type="image/png">
	<link rel="manifest" href="https://morfikov.github.io/manifest.json">
		
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-119125303-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>
<body>
	<header class="header">
	<a class="logo" href="https://morfikov.github.io/">Morfitronik</a>
	
<nav class="main-nav main-nav--right" role="navigation">
	<button id="toggle" class="main-nav__btn" aria-label="Menu toggle" aria-expanded="false" tabindex="0">
		<div class="main-nav__btn-box" tabindex="-1">
			<svg class="main-nav__icon icon-menu" width="18" height="18" viewBox="0 0 18 18">
				<path class="icon-menu__burger" d="M18 0v3.6H0V0h18zM0 10.8h18V7.2H0v3.6zM0 18h18v-3.6H0V18z"/>
				<path class="icon-menu__x" d="M11.55 9L18 15.45 15.45 18 9 11.55 2.55 18 0 15.45 6.45 9 0 2.55 2.55 0 9 6.45 15.45 0 18 2.55 11.55 9z"/>
			</svg>
		</div>
	</button>
	<ul id="menu" class="main-nav__list">
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/categories/">
					
					<span class="main-nav__text">Kategorie</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/tags/">
					
					<span class="main-nav__text">Tagi</span>
					
				</a>
			</li>
			<li class="main-nav__item">
				<a class="main-nav__link" href="https://morfikov.github.io/page/info-kontakt/">
					
					<span class="main-nav__text">Info/Kontakt</span>
					
				</a>
			</li>
	</ul>
</nav>
</header>
	<div class="primary">
	
	<main class="main">
		
<nav class="breadcrumb block" aria-label="breadcrumb">
	<ol class="breadcrumb__list">
		
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/">Home</a>
		</li>
		<li class="breadcrumb__item">
			<a class="breadcrumbs__link" href="https://morfikov.github.io/post/">Posts</a>
		</li>
		<li class="breadcrumbs__item breadcrumb__item--active" aria-current="page">Bufor połączeń w protokole TCP</li>
	</ol>
</nav>
		<div class="single block">
			<article class="entry">
	<div class="entry__meta meta mb">
	<time class="entry__meta-published meta-published" datetime="2015-07-01T10:20:16Z">Opublikowano: 01/07/2015</time>

<span class="entry__meta-categories meta-categories">
	<span class="meta-categories__list">Kategorie:
		<a class="meta-categories__link" href="https://morfikov.github.io/categories/linux/" rel="category">Linux</a>
	</span>
</span>
	</div>
				<h1 class="entry__title">Bufor połączeń w protokole TCP</h1>
<details class="entry__toc toc" >
	<summary class="toc__title">Spis treści</summary>
	<nav id="TableOfContents">
  <ol>
    <li><a href="#mechanizm-okien-tcp">Mechanizm okien TCP</a></li>
    <li><a href="#bufor-jego-skalowanie-i-znaczniki-czasu">Bufor, jego skalowanie i znaczniki czasu</a></li>
    <li><a href="#konfiguracja-zasobów-pamięci">Konfiguracja zasobów pamięci</a></li>
  </ol>
</nav>
</details>
				<div class="entry__content"><p>Wraz ze zwiększaniem zapotrzebowania na szybsze łącza internetowe, ograniczenia wynikające z
protokółu TCP zaczęły powoli dawać się ludziom we znaki. Problemem była bariera prędkości, którą
ciężko było pokonać mając do dyspozycji domyślną formę nagłówka protokołu TCP. Było w nim zwyczajnie
za mało miejsca, co zapoczątkowało jego rozbudowę kosztem ilości danych, które można było przesłać w
pojedynczym segmencie. W tym wpisie skupię się głównie na dwóch opcjach jakie zostały dodane do
nagłówka TCP, tj. dynamiczne skalowanie okien oraz znaczniki czasu, bo te dwa parametry nie mogą
wręcz bez siebie istnieć, zwłaszcza gdy rozmawiamy o łączach pokroju 1 czy 10 gbit/s.</p>
<h2 id="mechanizm-okien-tcp">Mechanizm okien TCP</h2>
<p>Mechanizm okien w protokole TCP pozwala kontrolować przepływ danych między dwoma punktami, które się
ze sobą komunikują. Jest to nic innego jak bufor, w którym są gromadzone dane w celu ich
późniejszego przetworzenia. Każda ze stron dysponuje osobnym buforem. W przypadku strony nadającej
jest to bufor na dane wysyłane do odbiorców <code>tcp_wmem</code> , natomiast zaś w przypadku strony
odbierającej jest to bufor na dane pochodzące od nadawcy <code>tcp_rmem</code> . Taki bufor ma skończoną
pojemność i określa ilość bajtów w tranzycie, które strona nadająca może przestać nie otrzymując
przy tym pakietu potwierdzającego ich odbiór. Trzeba pamiętać, że strona nadająca musi śledzić
wszystkie bajty, które wysłała i które jeszcze nie zostały potwierdzone przez odbiorcę. W przypadku
kiedy potwierdzenie nie nadejdzie przez pewien określony przedział czasu, nadawca retransmituje
pakiet jeszcze raz i robi to sięgając do swojego bufora nadawczego. W momencie gdy jakaś aplikacja
kliencka uczestnicząca w procesie wymiany informacji nie nadąża z ich obróbką, bufor może się
zapełnić sygnalizując tym samym nadającej maszynie, by wstrzymała się ona na moment z wysłaniem
nowych danych. Generalnie rzecz biorąc, nadający widzi w każdym potwierdzonym segmencie rozmiar okna
odbiorcy i bierze go pod uwagę gdy chce wysłać kolejne dane. Nie może jednak wysłać więcej danych
niż zostało to ściśle określone, przynajmniej do momentu aż wszystkie poprzednie segmenty zostaną
potwierdzone. W chwili gdy się to stanie, nowa porcja danych określona przez rozmiar okna może
zostać wysłana. Im takie okno jest mniejsze, tym wolniej dane będą napływać do punktu docelowego i
podobnie w drugą stronę, tj. im jest ono większe, tym więcej danych może zostać przesłane. Przez
taką zmianę rozmiaru okna, serwer i klient są w stanie zapewnić drugą ze stron, że dane są
przesyłane na tyle szybko, że odbiorca jest je w stanie przetworzyć.</p>
<p>Rozważmy dla przykładu sytuację zobrazowaną na poniżej fotce (<a href="http://www.tcpipguide.com/">źródło</a>).</p>
<p><img loading="lazy" src="https://morfikov.github.io/img/2015/06/1.bufor-polaczen-tcp.png" alt="bufor-polaczen-tcp"    class="big"></p>
<p>Klient wysłał żądanie o jakiś plik. Zarówno klient jak i serwer mają rozmiar okna TCP ustawiony na
560 bajtów. Serwer wysyła pierwsze pakiety. W powyższym przypadku, trzeci pakiet się zgubił. Do
klienta docierają pierwsze dane ( <code>4</code> ) i mogą one już zostać przesłane do warstwy aplikacji. Zatem
bufor ulega opróżnieniu i pozostaje na poziomie 560 bajtów. Jako, że serwer wysłał szereg segmentów,
musi czekać na potwierdzenie każdego z nich. W tym czasie wszystkie one rezydują w buforze u nadawcy
zostawiając tym samym jedynie 60 bajtów wolnego miejsca. Z chwilą gdy docierają do nadawcy pakiety
potwierdzające odbiór 200 bajtów ( <code>7</code> ), te dane mogą zostać usunięte z bufora, wobec czego rozmiar
okna ulega rozszerzeniu o ilość zwolnionego miejsca. Odbiorca otrzymał, co prawda, pakiet numer 4
ale nie wie co się stało z trzecim ( <code>6</code> ), dlatego też nie może wysłać do nadawcy potwierdzenia
odbioru tego pakietu. Gdyby to zrobił, sugerowałoby to nadawcy, że klient odebrał wszystkie 500
bajtów, a przecie tak się nie stało. Po pewnym czasie braku potwierdzenia ze strony klienta, serwer
retransmituje zaginiony pakiet ( <code>8</code> ) jeszcze raz i tym razem pakiet dociera do odbiorcy. Dane z
pakietu 3 i 4 mogą zostać przesłane do aplikacji, zwalniając tym samym zajmowane miejsce w buforze.
Serwer otrzymuje potwierdzenia odbioru tych dwóch pakietów, wobec czego, może usunąć zbędne dane z
bufora rozszerzając okno do 560 bajtów. I tak ten proces przebiega do wyczerpania danych, które
jedna z stron chce przesłać drugiej. Co ciekawe, tylko trzeci pakiet wymagał retransmisji, a nie
trzeci i czwarty. To za sprawą
<a href="https://morfikov.github.io/post/sack-czyli-selektywne-potwierdzenia-pakietow/">SACK</a>, czyli selektywnych
potwierdzeń segmentów.</p>
<p>Rozmiar okna jest kluczowy jeśli chodzi o możliwość przesyłania dużej ilości danych ale to nie jest
jedyny czynnik, który ma tutaj coś do powodzenia. Innym jest RTT (round trip time), czyli czas jaki
jest potrzeby na przesłanie pakietu do odbiorcy i uzyskanie od niego pakietu potwierdzającego
odebranie danych.</p>
<p>Dla przykładu, dla łącz 40 mbit/s o pingu 20 ms, optymalny rozmiar okna to 104,857 bajtów (BDP). BDP
to Bandwidth Delay Product i wylicza się go mnożąc prędkość przez czas opóźnień. W tym przypadku: 40
Mbit/s to 5,242,880 bajtów/s, a 20ms to 0,02/s. Po wymnożeniu tych dwóch wartości przez siebie
dostajemy BDP 104,857. Dobrze jest ustawić maksymalny rozmiar bufora 3-4 krotnie większy, by pakiety
z większymi opóźnieniami mogły podróżować z większą prędkością po kablach.</p>
<h2 id="bufor-jego-skalowanie-i-znaczniki-czasu">Bufor, jego skalowanie i znaczniki czasu</h2>
<p>Mamy zaś tylko jeden problem. Pole od rozmiaru okna w nagłówku TCP ma długość 16 bitów, co daje
maksymalny rozmiar okna 65,535 bajtów, czyli 64KiB. Zatem nawet jeśli mamy do dyspozycji ten
maksymalny rozmiar okna, to przy opóźnieniu 20 ms, największa przepustowość łącza jaką osiągniemy to
zaledwie 3,276,800 bajtów/s, czyli 25 mbitów/s. Więcej się nie da, chyba, że zmniejszymy czas
opóźnienia, a z tym jest ciężko. Co się dzieje w takim przypadku? Ano zwyczajnie tracimy 15
mbitów/s.</p>
<p>Zatem jak to jest możliwe, że nawet obecnie osiągamy o wiele większe prędkości? Robimy to przez
obejście ograniczenia rozmiaru okien przez dodanie do protokołu TCP odpowiednich rozszerzeń. Mowa
oczywiście o <a href="https://tools.ietf.org/html/rfc1323">skalowaniu okien oraz znacznikach czasu</a> .
Skalowanie okna może rozciągnąć jego rozmiar nawet do 1,073,725,440 bajtów, czyniąc tym samym
większy próg dla danych, które mogą być przesyłane przez sieć bez konieczności czekania na pakiet
potwierdzający. Jako, że większa prędkość pociąga za sobą więcej danych, to i <a href="https://morfikov.github.io/post/numery-sekwencyjne-w-strumieniu-tcp/">numery
sekwencyjne</a> skaczą jak szalone. Z
kolei ich pole w nagłówku TCP ma 32 bity, co daję liczbę 4,294,967,296 unikalnych numerów. Może i to
się wydaje dużo ale przy prędkościach rzędu 1 gbit/s, te numery sekwencyjne mogą się wyczerpać, w
zależności od uzyskanej prędkości, po czasie 17-34 sekund. Jeśli jakiś pakiet się w tym czasie
gdzieś zapodzieje, inny może dostać ten sam numer sekwencyjny i zostać zaakceptowany zamiast tego,
który powinien. W takim przypadku nastąpi uszkodzenie danych i my nawet nie zostaniemy o tym w żaden
sposób powiadomieni.</p>
<p>Opcja definiująca skalowanie okien zajmuje 3 bajty w nagłówku TCP. Natomiast jeśli chodzi o
znaczniki czasu, to jest to dodatkowe 10 bajtów. Łącznie daje to 13 bajtów ekstra. Przypominam, że
MTU to 1500 bajtów i im więcej zajmują nagłówki, tym mniej danych może do takiego pakietu się
zmieścić.</p>
<p>Obie te opcje możemy sobie oczywiście dostosować w zależności od tego jakim łączem dysponujemy.
Jeśli mamy jedno z tych nie za szybkich, np. 15 mbit/s , to nie potrzebujemy w sumie żadnych z tych
opcji. Oczywiście przy założeniu, że nie dysponujemy żadną siecią LAN i nie przesyłamy danych
lokalnie z większą prędkością. Jeśli chodzi zaś o sam znacznik czasu, to jeśli nie mamy do
dyspozycji łącz gigabitowych, ta opcja w nagłówku TCP jedynie marnuje nam 10 cennych bajtów, które
mogą zostać przeznaczone na faktyczne dane. Wobec czego przydałoby się wyłączyć ją zupełnie.</p>
<p>Reasumując, musimy skonfigurować dwa parametry i możemy to zrobić przez dopisanie do pliku
<code>/etc/sysctl.conf</code> tych poniższych linijek:</p>
<pre><code>net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_timestamps = 0
net.netfilter.nf_conntrack_timestamp = 0
</code></pre>
<h2 id="konfiguracja-zasobów-pamięci">Konfiguracja zasobów pamięci</h2>
<p>W kernelu mamy szereg innych opcji, które wymagają dostosowania w przypadku gdy przepustowość łącza
jest nie taka jak być powinna. Jako, że większe okna zapewniają większą przepustowość, to pociągają
za sobą także większe wykorzystanie zasobów. Głównie chodzi o pamięć operacyjną RAM. Im większe jest
okno, tym więcej pamięci będzie ono zjadać. Im więcej jest okien, tym jeszcze więcej pamięci będą
one zjadać. Generalnie rzecz biorąc, każde połączenie jakie nawiązujemy w celu pobierania/wysyłania
danych wykorzystuje pewną określoną ilość pamięci. Kiedyś pisałem, że gniazda TCP/UDP identyfikują
konkretne połączenia, w skład których wchodzą lokalny adres, lokalny port, zdalny adres, zdalny port
oraz protokół. Dla każdego z takich gniazd, kernel przydziela kilka stron pamięci. By przeliczyć
strony pamięci na faktyczną jej objętość, trzeba przemnożyć ilość stron przez rozmiar strony. Z
kolei rozmiar strony można uzyskać porównując te dwa poniższe parametry z plików <code>/proc/meminfo</code>
oraz <code>/proc/vmstat</code> :</p>
<pre><code># cat /proc/meminfo | egrep -i &quot;Mapped&quot; &amp;&amp; cat /proc/vmstat | egrep -i &quot;nr_mapped&quot;
Mapped:           158524 kB
nr_mapped 39631
</code></pre>
<p>Rozmiar strony to <code>Mapped/nr_mapped</code> , czyli 158524/39631=4KiB albo 4096 bajtów.</p>
<p>Poniższe 3 wartości określają minimalną, umiarkowaną i maksymalną ilość stron pamięci, które mogą
wykorzystać wszystkie gniazda TCP/UDP łącznie i odpowiadają odpowiednio za 64 MiB, 96 MiB i 144 MiB
pamięci. Ten parametr domyślnie jest kalkulowany przy starcie systemu w oparciu o ilość dostępnej
pamięci RAM i nie musimy go wyraźnie precyzować w pliku <code>/etc/sysctl.conf</code> :</p>
<pre><code>net.ipv4.tcp_mem = 16500 24750 37125
net.ipv4.udp_mem = 16500 24750 37125
</code></pre>
<p>Dodatkowo musimy ustawić ilość pamięci, która zostanie przydzielona buforom połączeń. Poniższe
wartości są w bajtach i odnoszą się do wszystkich protokołów:</p>
<pre><code>net.core.rmem_default = 327680
net.core.rmem_max = 327680
net.core.wmem_default = 327680
net.core.wmem_max = 327680
</code></pre>
<p>Musimy jeszcze określić rozmiar buforów dla poszczególnych gniazd TCP. Druga wartość poniższych
parametrów nadpisuje <code>net.core.rmem_default</code> oraz <code>net.core.wmem_default</code> widoczne wyżej:</p>
<pre><code>net.ipv4.tcp_wmem = 4096 81920 327680
net.ipv4.tcp_rmem = 4096 81920 327680
</code></pre>
<p>W przypadku gdy system ma dostatecznie dużo pamięci sprecyzowanej w <code>tcp_mem</code> , przydziela każdemu
nowo utworzonemu gniazdu z automatu tyle RAMu ile widnieje na drugiej pozycji w parametrze wyżej.
Jeśli istnieje potrzeba, np. w przypadku szybkiego transferu danych czy większych opóźnień, kernel
może zwiększyć limit dla takiego połączenia ale nie może on przekroczyć wartości maksymalnej, w tym
przypadku <code>327680</code> bajtów. Z kolei zaś, gdy pamięć będzie na wyczerpaniu, połączenia już utworzone
będą musiały się podzielić pamięcią z nowo tworzonymi gniazdami. W przypadku tych połączeń,
zostanie ograniczony transfer poprzez zmniejszenie bufora.</p>
<p>Istnieje jeszcze jedna ciekawa opcja, która umożliwia automatyczne dostrajanie wielkości bufora
odbiorczego i co za tym idzie również okna TCP dla każdego połączenia. Maksymalna wartość bufora nie
może jednak przekroczyć tego zdefiniowanego w <code>tcp_rmem</code> . Jeśli interesuje nas tego typu mechanizm,
dopisujemy poniższą linijkę do pliku <code>/etc/sysctl.conf</code> :</p>
<pre><code>net.ipv4.tcp_moderate_rcvbuf = 1
</code></pre>
<p>Po dostosowaniu powyższych opcji, wystarczy wydać poniższe polecenie by zmiany weszły w życie:</p>
<pre><code># sysctl -p
</code></pre></div>
				
				<footer class="entry__footer">
					
<div class="entry__tags">
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/tcp/">tcp</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/sysctl/">sysctl</a>
			<a class="entry__tag btn" href="https://morfikov.github.io/tags/siec/">sieć</a>
</div>
					
<div class="entry__share share">
	<a class="share__link btn" title="Podziel się na Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Facebook', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Facebook" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M330 512V322h64l9-74h-73v-47c0-22 6-36 37-36h39V99c-7-1-30-3-57-3-57 0-95 34-95 98v54h-64v74h64v190z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Twitter" href="https://twitter.com/intent/tweet/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f&amp;text=Bufor%20po%c5%82%c4%85cze%c5%84%20w%20protokole%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Twitter', 'width=800,height=450,resizable=yes,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Reddit" href="https://www.reddit.com/submit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f&amp;title=Bufor%20po%c5%82%c4%85cze%c5%84%20w%20protokole%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Reddit', 'width=832,height=624,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Reddit" role="img" width="32" height="32" viewBox="0 0 512 512"><path fill-rule="evenodd" d="M375 146a32 32 0 1 0-29-46l-65-13c-5-1-9 2-10 6l-22 97c-45 1-85 15-113 36a42 42 0 1 0-45 69l-1 12c0 65 74 117 166 117s166-52 166-117l-1-11a42 42 0 1 0-44-69c-28-21-67-35-111-37l19-86 58 13a32 32 0 0 0 32 29zM190 353c2-1 4 0 5 1 15 11 38 18 61 18s46-6 61-18a7 7 0 0 1 8 10c-18 14-44 21-69 21-25-1-51-7-69-21a6 6 0 0 1 3-11zm23-44a31 31 0 1 1-44-44 31 31 0 0 1 44 44zm130 0a31 31 0 1 0-44-44 31 31 0 0 0 44 44z"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na Telegram" href="https://t.me/share/url?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f&amp;title=Bufor%20po%c5%82%c4%85cze%c5%84%20w%20protokole%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na Telegram', 'width=800,height=600,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na LinkedIn" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f&title=Bufor%20po%c5%82%c4%85cze%c5%84%20w%20protokole%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na LinkedIn', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="LinkedIn" role="img" width="32" height="32" viewBox="0 0 512 512"><circle cx="142" cy="138" r="37"/><path stroke-width="66" d="M244 194v198M142 194v198"/><path d="M276 282c0-20 13-40 36-40 24 0 33 18 33 45v105h66V279c0-61-32-89-76-89-34 0-51 19-59 32"/></svg>
	</a>
	<a class="share__link btn" title="Podziel się na VK" href="https://vk.com/share.php?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Podziel się na VK', 'width=640,height=480,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="VK" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M274 363c5-1 14-3 14-15 0 0-1-30 13-34s32 29 51 42c14 9 25 8 25 8l51-1s26-2 14-23c-1-2-9-15-39-42-31-30-26-25 11-76 23-31 33-50 30-57-4-7-20-6-20-6h-57c-6 0-9 1-12 6 0 0-9 25-21 45-25 43-35 45-40 42-9-5-7-24-7-37 0-45 7-61-13-65-13-2-59-4-73 3-7 4-11 11-8 12 3 0 12 1 17 7 8 13 9 75-2 81-15 11-53-62-62-86-2-6-5-7-12-9H79c-6 0-15 1-11 13 27 56 83 193 184 192z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pocket" href="https://getpocket.com/edit?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f&amp;title=Bufor%20po%c5%82%c4%85cze%c5%84%20w%20protokole%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=480,height=320,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pocket" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M388.8 88.9H123.2A47.4 47.4 0 0 0 76 136.5v131.9c0 2.4.2 4.8.5 7.2a101.8 101.8 0 0 0-.5 10.6c0 75.6 80.6 137 180 137s180-61.4 180-137c0-3.6-.2-7.1-.5-10.6.3-2.4.5-4.8.5-7.2v-132A47.4 47.4 0 0 0 388.8 89zm-22.4 132.6l-93 93c-4.7 4.6-11 7-17.1 7a23.8 23.8 0 0 1-17.7-7l-93-93a24 24 0 0 1 33.8-33.8l76.6 76.5 76.6-76.5a24 24 0 0 1 33.8 33.8z"/></svg>
	</a>
	<a class="share__link btn" title="Zapisz do Pinterest" href="https://pinterest.com/pin/create/button/?url=https%3a%2f%2fmorfikov.github.io%2fpost%2fbufor-polaczen-w-protokole-tcp%2f&description=Bufor%20po%c5%82%c4%85cze%c5%84%20w%20protokole%20TCP" target="_blank" rel="noopener noreferrer" onclick="window.open(this.href, 'Zapisz do Pocket', 'width=800,height=720,toolbar=0,status=0'); return false">
		<svg class="share__icon" aria-label="Pinterest" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="m265 65c-104 0-157 75-157 138 0 37 14 71 45 83 5 2 10 0 12-5l3-18c2-6 1-7-2-12-9-11-15-24-15-43 0-56 41-106 108-106 60 0 92 37 92 85 0 64-28 116-70 116-23 0-40-18-34-42 6-27 19-57 19-77 0-18-9-34-30-34-24 0-42 25-42 58 0 20 7 34 7 34l-29 120a249 249 0 0 0 2 86l3-1c2-3 31-37 40-72l16-61c7 15 29 28 53 28 71 0 119-64 119-151 0-66-56-126-140-126z"/></svg>
	</a>
</div>
				</footer>
				
			</article>
		</div>
	</main>
	
<div class="authorbox block">
	<div class="author">
		<figure class="author__avatar">
			<img class="author__img" alt="Mikhail Morfikov avatar" src="https://morfikov.github.io/img/avatar.png" height="90" width="90">
		</figure>
		<div class="author__body">
			<div class="author__name">
				Mikhail Morfikov
			</div>
			<div class="author__bio">Po ponad 10 latach spędzonych z różnej maści linux&#39;ami (Debian/Ubuntu, OpenWRT, Android) mogę śmiało powiedzieć, że nie ma rzeczy niemożliwych i problemów, których nie da się rozwiązać. Jedną umiejętność, którą ludzki umysł musi posiąść, by wybrnąć nawet z tej najbardziej nieprzyjemniej sytuacji, to zdolność logicznego rozumowania.</div>
		</div>
	</div>
</div>
	



<div class="related block">
	<h3 class="related__title">Powiązane</h3>
	<ul class="related__list">
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/sack-czyli-selektywne-potwierdzenia-pakietow/">SACK, czyli selektywne potwierdzenia pakietów</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/fragmentacja-pakietu-i-zmiana-wartosci-mtu/">Fragmentacja pakietu i zmiana wartości MTU</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/numery-sekwencyjne-w-strumieniu-tcp/">Numery sekwencyjne w strumieniu TCP</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/tso-czyli-odciazenie-segmentacji-tcp/">TSO, czyli odciążenie segmentacji TCP</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/znacznik-czasu-timestamp-w-protokole-tcp/">Znacznik czasu (timestamp) w protokole TCP</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/flagi-tcp-i-przelaczanie-stanow-polaczen/">Flagi TCP i przełączanie stanów połączeń</a></li>
		
		<li class="related__item"><a class="related__link" href="https://morfikov.github.io/post/czas-zycia-pakietow-czyli-zmiana-ttl/">Czas życia pakietów, czyli zmiana TTL</a></li>
		
	</ul>
</div>

	<div id="comments">
		<script src="https://utteranc.es/client.js"
        repo="morfikov/morfitronik-comments"
        issue-term="og:title"
        theme="github-dark"
        crossorigin="anonymous"
        async>
</script>

	</div>

	</div>
	<footer class="footer">
<div class="footer__social social">
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="mailto:morfitronik@gmail.com">
			<svg class="social__icon" aria-label="Email" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M299 268l124 106c-4 4-10 7-17 7H106c-7 0-13-3-17-7l124-106 43 38 43-38zm-43 13L89 138c4-4 10-7 17-7h300c7 0 13 3 17 7L256 281zm54-23l121-105v208L310 258zM81 153l121 105L81 361V153z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://twitter.com/mikhailmorfikov">
			<svg class="social__icon" aria-label="Twitter" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://t.me/morfikov">
			<svg class="social__icon" aria-label="Telegram" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M199 404c-11 0-10-4-13-14l-32-105 245-144"/><path d="M199 404c7 0 11-4 16-8l45-43-56-34"/><path d="M204 319l135 99c14 9 26 4 30-14l55-258c5-22-9-32-24-25L79 245c-21 8-21 21-4 26l83 26 190-121c9-5 17-3 11 4"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://github.com/morfikov">
			<svg class="social__icon" aria-label="Github" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://gitlab.com/morfikov">
			<svg class="social__icon" aria-label="Gitlab" role="img" width="32" height="32" viewBox="0 0 512 512"><path d="M450 282l-22-67-43-133c-2-7-12-7-14 0l-43.3 133H184.3L141 82c-2-7-12-7-14 0L84 215l-22 67c-2 6 0 13 6 16l188 137 188-137c6-3 8-10 6-16z"/></svg>
		</a>
		<a class="social__link" target="_blank" rel="noopener noreferrer" href="https://stackoverflow.com/users/3015317">
			<svg class="social__icon" aria-label="Stack Overflow" role="img" width="32" height="32" viewBox="0 0 512 512"><g stroke-width="30"><path fill="none" d="M125 297v105h241V297"/><path d="M170 341h150m-144-68l148 31M199 204l136 64m-95-129l115 97M293 89l90 120"/></g></svg>
		</a>
</div>
	<div class="footer__copyright">© 2024 Mikhail Morfikov.
	<span class="footer__copyright-credits">Powered by <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/vimux/binario" rel="nofollow noopener" target="_blank">Binario</a> theme.</span>
	<span class="footer__copyright-cc">
		<div class="license-icons">
			<a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" title="Creative Commons Attribution 4.0 International license">
<i class="icon-cc"></i><i class="icon-cc-by"></i><i class="icon-cc-nc"></i><i class="icon-cc-sa"></i>
</a>
		</div>
		Except where otherwise noted, content on this site is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International license</a>.
	</span>
	</div>
</footer>

<script src="https://morfikov.github.io/js/menu.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML" async></script>

<script src="https://morfikov.github.io/js/custom.js"></script>
<script src="https://unpkg.com/vanilla-back-to-top@7.2.1/dist/vanilla-back-to-top.min.js"></script>
<script>addBackToTop({
  diameter: 40,
  textColor: '#c3c3c3'
})</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/medium-zoom/1.0.6/medium-zoom.min.js" integrity="sha512-N9IJRoc3LaP3NDoiGkcPa4gG94kapGpaA5Zq9/Dr04uf5TbLFU5q0o8AbRhLKUUlp8QFS2u7S+Yti0U7QtuZvQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<script>
const images = Array.from(document.querySelectorAll(".entry__content img"));
images.forEach(img => {
  mediumZoom(img, {
    margin: 0,  
    scrollOffset: 40,  
    container: null,  
    template: null,  
    background: 'rgba(0, 0, 0, 0.8)'
  });
});
</script>
</body>
</html>
